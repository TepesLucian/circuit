{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\u26a1\ufe0f Circuit","text":"<p>Circuit is used in production at Slack and ready for general use \ud83d\ude80. The API is considered unstable as we continue to iterate on it.</p>"},{"location":"#overview","title":"Overview","text":"<p>Circuit is a simple, lightweight, and extensible framework for building Kotlin applications that\u2019s Compose from the ground up.</p> <p>Compose Runtime vs. Compose UI</p> <p>Compose itself is essentially two libraries \u2013 Compose Compiler and Compose UI. Most folks usually think of Compose UI, but the compiler (and associated runtime) are actually not specific to UI at all and offer powerful state management APIs.</p> <p>Jake Wharton has an excellent post about this: https://jakewharton.com/a-jetpack-compose-by-any-other-name/</p> <p>It builds upon core principles we already know like Presenters and UDF, and adds native support in its framework for all the other requirements we set out for above. It\u2019s heavily influenced by Cash App\u2019s Broadway architecture (talked about at Droidcon NYC, also very derived from our conversations with them).</p> <p>Circuit\u2019s core components are its <code>Presenter</code> and <code>Ui</code> interfaces.</p> <ol> <li>A <code>Presenter</code> and a <code>Ui</code> cannot directly access each other. They can only communicate through state and event emissions.</li> <li>UIs are compose-first.</li> <li>Presenters are also compose-first. They do not emit Compose UI, but they do use the Compose runtime to manage and emit state.</li> <li>Both <code>Presenter</code> and <code>Ui</code> each have a single composable function.</li> <li>In most cases, Circuit automatically connects presenters and UIs.</li> <li><code>Presenter</code> and <code>Ui</code> are both generic types, with generics to define the <code>UiState</code> types they communicate with.</li> <li>They are keyed by <code>Screen</code>s. One runs a new <code>Presenter</code>/<code>Ui</code> pairing by requesting them with a given <code>Screen</code> that they understand.</li> </ol> <p>Screens</p> <p>The pairing of a <code>Presenter</code> and <code>Ui</code> for a given <code>Screen</code> key is what we semantically call a \u201cscreen\u201d.</p> <ul> <li>Your application is composed of \u201cscreens\u201d.</li> <li>A simple counter <code>Presenter</code> + <code>Ui</code> pairing would be a \u201ccounter screen\u201d.</li> <li>Nested presenter/UIs would be \u201cnested circuits\u201d or \u201csub screen\u201d.</li> <li>Composite presenter/UIs would be \u201ccomposite screen\u201d.</li> <li>etc etc.</li> </ul> <p>Circuit\u2019s repo (https://github.com/slackhq/circuit) is being actively developed in the open, which allows us to continue collaborating with external folks too. We have a trivial-but-not-too-trivial sample app that we have been developing in it to serve as a demo for a number of common patterns in Circuit use.</p>"},{"location":"#counter-example","title":"Counter Example","text":"<p>This is a very simple case of a Counter screen that displays the count and has buttons to increment and decrement.</p> <p></p> <p>There\u2019s some glue code missing from this example that\u2019s covered in the Code Gen section later.</p> <pre><code>@Parcelize\ndata object CounterScreen : Screen {\n  data class CounterState(\n    val count: Int,\n    val eventSink: (CounterEvent) -&gt; Unit,\n  ) : CircuitUiState\n  sealed interface CounterEvent : CircuitUiEvent {\n    data object Increment : CounterEvent\n    data object Decrement : CounterEvent\n  }\n}\n\n@CircuitInject(CounterScreen::class, AppScope::class)\n@Composable\nfun CounterPresenter(): CounterState {\n  var count by rememberSaveable { mutableStateOf(0) }\n\n  return CounterState(count) { event -&gt;\n    when (event) {\n      CounterEvent.Increment -&gt; count++\n      CounterEvent.Decrement -&gt; count--\n    }\n  }\n}\n\n@CircuitInject(CounterScreen::class, AppScope::class)\n@Composable\nfun Counter(state: CounterState) {\n  Box(Modifier.fillMaxSize()) {\n    Column(Modifier.align(Alignment.Center)) {\n      Text(\n        modifier = Modifier.align(CenterHorizontally),\n        text = \"Count: ${state.count}\",\n        style = MaterialTheme.typography.displayLarge\n      )\n      Spacer(modifier = Modifier.height(16.dp))\n      Button(\n        modifier = Modifier.align(CenterHorizontally),\n        onClick = { state.eventSink(CounterEvent.Increment) }\n      ) { Icon(rememberVectorPainter(Icons.Filled.Add), \"Increment\") }\n      Button(\n        modifier = Modifier.align(CenterHorizontally),\n        onClick = { state.eventSink(CounterEvent.Decrement) }\n      ) { Icon(rememberVectorPainter(Icons.Filled.Remove), \"Decrement\") }\n    }\n  }\n}\n</code></pre>"},{"location":"#license","title":"License","text":"<pre><code>Copyright 2022 Slack Technologies, LLC\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#0150","title":"0.15.0","text":"<p>2023-09-20</p>"},{"location":"changelog/#new-allow-retained-state-to-be-retained-whilst-uis-and-presenters-are-on-the-back-stack","title":"New: Allow retained state to be retained whilst UIs and Presenters are on the back stack.","text":"<p>Originally, <code>circuit-retained</code> was implemented as a solution for preserving arbitrary data across configuration changes on Android. With this change it now also acts as a solution for retaining state across the back stack, meaning that traversing the backstack no longer causes restored contents to re-run through their empty states anymore.</p> <p>To support this, each back stack entry now has its own <code>RetainedStateRegistry</code> instance.</p> <p>Note that <code>circuit-retained</code> is still optional for now, but we are considering making it part of <code>CircuitCompositionLocals</code> in the future. Please let us know your thoughts in this issue: https://github.com/slackhq/circuit/issues/891.</p> <p>Full details + demos can be found in https://github.com/slackhq/circuit/pull/888. Big thank you to @chrisbanes for the implementation!</p>"},{"location":"changelog/#other-changes","title":"Other changes","text":"<ul> <li>New: Add <code>collectAsRetainedState</code> utility function, analogous to <code>collectAsState</code> but will retain the previous value across configuration changes and back stack entries.</li> <li>Enhancement: Optimize <code>rememberRetained</code> with a port of the analogous optimization in <code>rememberSaveable</code>. See #850.</li> <li>Enhancement: <code>Presenter</code> and <code>Ui</code> interfaces are now annotated as <code>@Stable</code>.</li> <li>Fix: Fix <code>GestureNavigationDecoration</code> function parameter order.</li> <li>Fix: <code>BackHandler</code> on iOS now has the proper file name.</li> <li>Fix: Key the <code>presenter.present()</code> in <code>CircuitContent</code> on the <code>Screen</code> rather than the <code>presenter</code> itself, which fixes a severe issue that prevented <code>currentCompositeKeyHash</code> from working correctly on <code>rememberRetained</code> and <code>rememberSaveable</code> uses.</li> <li>Update CM compiler to <code>1.5.2</code>.</li> <li>Update CM to <code>1.5.1</code>.</li> <li>Update <code>androidx.compose.animation</code> to <code>1.5.1</code>.</li> <li>Update <code>androidx.compose.foundation</code> to <code>1.5.1</code>.</li> <li>Update <code>androidx.compose.runtime</code> to <code>1.5.1</code>.</li> <li>Update <code>androidx.compose.material</code> to <code>1.5.1</code>.</li> <li>Update <code>androidx.lifecycle</code> to <code>2.6.2</code>.</li> <li>Update <code>androidx.annotation</code> to <code>1.7.0</code>.</li> </ul>"},{"location":"changelog/#0141","title":"0.14.1","text":"<p>2023-09-03</p> <ul> <li>New: Add <code>GestureNavigationDecoration</code> to <code>CircuitX</code> courtesy of @chrisbanes.</li> </ul> <p>This is a new <code>NavDecoration</code> that allows for gesture-based navigation, such as predictive back in Android 14 or drag gestures in iOS. See the docs for more details.</p> <pre><code>NavigableCircuitContent(\n  navigator = navigator,\n  backstack = backstack,\n  decoration = GestureNavigationDecoration(\n    // Pop the back stack once the user has gone 'back'\n    navigator::pop\n  )\n)\n</code></pre> <ul> <li>Fix embedded baseline profiles in published artifacts. Unfortunately GMDs used to generate these are quite finicky to run so these are sometimes tricky to regen each release.</li> </ul> <p>Special thanks to @chrisbanes and @alexvanyo for contributing to this release!</p>"},{"location":"changelog/#0140","title":"0.14.0","text":"<p>2023-08-30</p> <ul> <li>New: Circuit now supports JS targets!</li> <li>New: Introduce CircuitX artifacts. CircuitX is a suite of extension artifacts for Circuit. These artifacts are intended to be   batteries-included implementations of common use cases, such as out-of-the-box <code>Overlay</code> types or   Android navigation interop. See the docs for more details.</li> <li>Enhancement: Promote <code>Screen</code> to its own artifact. This is now under the <code>com.slack.circuit.runtime.screen.Screen</code> name.</li> <li>Enhancement: Use <code>Screen</code> directly in the <code>BackStack</code> in place of <code>route</code>.</li> <li>Enhancement: No longer require <code>SaveableBackStack</code> in <code>NavigableCircuitContent</code>, now any <code>BackStack</code> impl is supported.</li> <li>Enhancement: Make <code>CanRetainChecker</code> more customizable in <code>circuit-retained</code>.</li> <li>Enhancement: Pass the whole list of active records to <code>DecoratedContent</code>, allowing more complex handling of back gestures (predictive back in android, drag gestures in iOS, etc).</li> <li>Enhancement: Refactor out a <code>buildCircuitContentProviders()</code> in <code>NavigableCircuitContent</code>, which enables <code>movableContentOf</code> to work since it\u2019s reusing the same instance for records across changes.</li> <li>Fix: Fix duplicated <code>Modifier</code> for <code>DecoratedContent</code>.</li> <li>Fix: Fix new presenter instances of the same type not being recomposed. See #799 for more details.</li> <li>Fix: Export iOS targets for <code>circuit-test</code> artifact.</li> <li>Demonstrate back handling for Compose Multiplatform in Counter sample.</li> <li>Add <code>kotlinx.collections.immutable</code> to core APIs.</li> <li>Update to Compile SDK 34.</li> <li>Update to Compose Multiplatform <code>1.5.0</code>.</li> <li>Update androidx.compose.compiler to <code>1.5.3</code>.</li> <li>Update androidx.compose.ui to <code>1.5.0</code>.</li> <li>Update androidx.compose.material to <code>1.5.0</code>.</li> <li>Update androidx.compose.runtime to <code>1.5.0</code>.</li> <li>Update androidx.compose.foundation to <code>1.5.0</code>.</li> <li>Update uuid to <code>0.8.1</code>.</li> <li>Update Molecule to <code>1.2.0</code>.</li> <li>Update Kotlin to <code>1.9.10</code>.</li> <li>Update KSP to <code>1.9.10-1.0.13</code>.</li> </ul> <p>Thanks to @chrisbanes and @ashdavies for contributing to this release!</p>"},{"location":"changelog/#0130-beta01","title":"0.13.0-beta01","text":"<p>2023-08-17</p> <ul> <li>New: Circuit now supports JS targets!</li> <li>New: Introduce CircuitX artifacts. CircuitX is a suite of extension artifacts for Circuit. These artifacts are intended to be   batteries-included implementations of common use cases, such as out-of-the-box <code>Overlay</code> types or   Android navigation interop. See the docs for more details.</li> <li>Fix: Fix new presenter instances of the same type not being recomposed. See #799 for more details.</li> <li>Fix: Export iOS targets for <code>circuit-test</code> artifact.</li> <li>Update to Compile SDK 34.</li> <li>Update to Compose Multiplatform <code>1.5.0-beta02</code>.</li> <li>Update androidx.compose.ui to <code>1.5.0</code>.</li> <li>Update androidx.compose.material to <code>1.5.0</code>.</li> <li>Update androidx.compose.runtime to <code>1.5.0</code>.</li> <li>Update androidx.compose.foundation to <code>1.5.0</code>.</li> <li>Update Molecule to <code>1.2.0</code>.</li> <li>Update KSP to <code>1.9.0-1.0.13</code>.</li> </ul> <p>Note this release is a beta release due to the dependency on CM <code>1.5.0-beta02</code>.</p>"},{"location":"changelog/#0121","title":"0.12.1","text":"<p>2023-08-01</p> <ul> <li>Patch release with baseline profiles bundled in the Android artifacts again.</li> <li>Update to Anvil <code>2.4.7</code>.</li> </ul>"},{"location":"changelog/#0120","title":"0.12.0","text":"<p>2023-07-28</p> <ul> <li>[foundation] Rename <code>CircuitConfig</code> -&gt; <code>Circuit</code>. There is a source-compatible typealias for <code>CircuitConfig</code> left with a deprecation replacement to ease migration.</li> <li>[foundation] Rename <code>CircuitContext.config</code> -&gt; <code>CircuitContext.circuit</code>. The previous <code>CircuitContext.config</code> function is left with a deprecation replacement to ease migration.</li> <li>[test] Add new <code>TestEventSink</code> helper for testing event emissions in UI tests.</li> <li>[overlay] Add missing coroutines implementation dependency.</li> <li>Update to Kotlin <code>1.9.0</code>.</li> <li>Update to KSP <code>1.9.0-1.0.12</code>.</li> <li>Update to Compose Multiplatform <code>1.4.3</code>.</li> <li>Update to Coroutines <code>1.7.3</code>.</li> <li>Update to Compose compiler to <code>1.5.1</code> (androidx) and <code>1.5.0</code> (compose-multiplatform).</li> <li>Update uuid to <code>0.8.0</code>.</li> </ul>"},{"location":"changelog/#0110","title":"0.11.0","text":"<p>2023-07-20</p> <ul> <li>[runtime] Fix race condition in <code>EventListener.start()</code> callback.</li> <li>[code gen] Update to Dagger 2.47.</li> <li>[docs] No longer recommend or require extracting intermediate event sink variables. This is no longer an issue \ud83c\udf89.</li> <li>Update Molecule to <code>1.0.0</code>.</li> </ul> <p>Thanks to @bryanstern for contributing to this release!</p>"},{"location":"changelog/#0101","title":"0.10.1","text":"<p>2023-07-09</p> <ul> <li>[runtime] Make <code>CircuitContent</code> overload with <code>Navigator</code> public.</li> <li>[runtime] Remember <code>Presenter</code> and <code>Ui</code> in <code>CircuitContent</code>.</li> <li>[runtime] Fix kdoc typo in <code>RememberRetained</code> .</li> </ul> <p>Special thanks to @chrisbanes and @bryanstern for contributing to this release!</p>"},{"location":"changelog/#0100","title":"0.10.0","text":"<p>2023-06-30</p> <ul> <li>[runtime] Fix wrong compose-compiler used in iOS targets. Now we\u2019re using the compose-multiplatform fork.</li> <li>[runtime] Allow creation of multiple <code>RetainedStateRegistry</code> instances.</li> <li>[docs] Add clarifying links to Events docs.</li> <li>[samples] Add new image detail view in STAR sample.</li> <li>Update Molecule to <code>0.11.0</code>.</li> <li>Update AndroidX compose-compiler to <code>1.4.8</code>.</li> <li>Update compose-multiplatform to <code>1.4.1</code>.</li> <li>Update to coroutines <code>1.7.2</code>.</li> <li>Update to Turbine <code>1.0.0</code>.</li> <li>Update to Kotlin <code>1.8.22</code>.</li> </ul> <p>Special thanks to @bryanstern, @saket, and @chrisbanes for contributing to this release!</p>"},{"location":"changelog/#091","title":"0.9.1","text":"<p>2023-06-02</p> <ul> <li>[runtime] Promote <code>NavEvent</code> subtypes to public API.</li> <li>[runtime] Update <code>com.benasher44:uuid</code> to <code>0.7.1</code>.</li> <li>[code gen] Update Anvil to <code>2.4.6</code>.</li> </ul>"},{"location":"changelog/#090","title":"0.9.0","text":"<p>2023-05-26</p>"},{"location":"changelog/#preliminary-support-for-ios-targets","title":"Preliminary support for iOS targets","text":"<p>Following the announcement of Compose for iOS alpha, this release adds <code>ios()</code> and <code>iosSimulatorArm64()</code> targets for the Circuit core artifacts. Note that this support doesn\u2019t come with any extra APIs yet for iOS, just basic target support only. We\u2019re not super sure what direction we want to take with iOS, but encourage others to try it out and let us know what patterns you like. We have updated the Counter sample to include an iOS app target as well, using Circuit for the presentation layer only and SwiftUI for the UI.</p> <p>Note that circuit-codegen and circuit-codegen-annotations don\u2019t support these yet, as Anvil and Dagger only support JVM targets.</p> <p>More details can be found in the PR: https://github.com/slackhq/circuit/pull/583</p>"},{"location":"changelog/#misc","title":"Misc","text":"<ul> <li>Use new baseline profile plugin for generating baseline profiles.</li> <li>Misc sample app fixes and updates.</li> <li>Add window size class example to STAR sample.</li> <li>Switch to Roborazzi for screenshot test samples.</li> <li>Small documentation updates.</li> <li>Add bi-directional Flow/Circuit interop to interop sample.</li> </ul> <p>Note that we unintentionally used an experimental animation API for <code>NavigatorDefaults.DefaultDecotration</code>, which may cause R8 issues if you use a newer, experimental version of Compose animation. To avoid issues, copy the animation code and use your own copy compiled against the newest animation APIs. We\u2019ll fix this after Compose 1.5.0 is released.</p>"},{"location":"changelog/#dependency-updates","title":"Dependency updates","text":"<pre><code>androidx.activity -&gt; 1.7.2\ncompose -&gt; 1.4.3\ncompose-compiler -&gt; 1.4.7\ncoroutines -&gt; 1.7.1\nkotlin -&gt; 1.8.21\nkotlinpoet -&gt; 1.13.2\nturbine -&gt; 0.13.0\n</code></pre>"},{"location":"changelog/#080","title":"0.8.0","text":"<p>2023-04-06</p>"},{"location":"changelog/#core-split-up-core-artifacts","title":"[Core] Split up core artifacts.","text":"<ul> <li><code>circuit-runtime</code>: common runtime components like <code>Screen</code>, <code>Navigator</code>, etc.</li> <li><code>circuit-runtime-presenter</code>: the <code>Presenter</code> API, depends on <code>circuit-runtime</code>.</li> <li><code>circuit-runtime-ui</code>: the <code>Ui</code> API, depends on <code>circuit-runtime</code>.</li> <li><code>circuit-foundation</code>: the circuit foundational APIs like <code>CircuitConfig</code>, <code>CircuitContent</code>, etc. Depends on the first three.</li> </ul> <p>The goal in this is to allow more granular dependencies and easier building against subsets of the API. For example, this would allow a presenter implementation to easily live in a standalone module that doesn\u2019t depend on any UI dependencies. Vice versa for UI implementations.</p> <p>Where we think this could really shine is in multiplatform projects where Circuit\u2019s UI APIs may be more or less abstracted away in service of using native UI, like in iOS.</p>"},{"location":"changelog/#circuit-runtime-artifact","title":"<code>circuit-runtime</code> artifact","text":"Before After com.slack.circuit.CircuitContext com.slack.circuit.runtime.CircuitContext com.slack.circuit.CircuitUiState com.slack.circuit.runtime.CircuitUiState com.slack.circuit.CircuitUiEvent com.slack.circuit.runtime.CircuitUiEvent com.slack.circuit.Navigator com.slack.circuit.runtime.Navigator com.slack.circuit.Screen com.slack.circuit.runtime.Screen"},{"location":"changelog/#circuit-runtime-presenter-artifact","title":"<code>circuit-runtime-presenter</code> artifact","text":"Before After com.slack.circuit.Presenter com.slack.circuit.runtime.presenter.Presenter"},{"location":"changelog/#circuit-runtime-ui-artifact","title":"<code>circuit-runtime-ui</code> artifact","text":"Before After com.slack.circuit.Ui com.slack.circuit.runtime.presenter.Ui"},{"location":"changelog/#circuit-foundation-artifact","title":"<code>circuit-foundation</code> artifact","text":"Before After com.slack.circuit.CircuitCompositionLocals com.slack.circuit.foundation.CircuitCompositionLocals com.slack.circuit.CircuitConfig com.slack.circuit.foundation.CircuitConfig com.slack.circuit.CircuitContent com.slack.circuit.foundation.CircuitContent com.slack.circuit.EventListener com.slack.circuit.foundation.EventListener com.slack.circuit.NavEvent com.slack.circuit.foundation.NavEvent com.slack.circuit.onNavEvent com.slack.circuit.foundation.onNavEvent com.slack.circuit.NavigableCircuitContent com.slack.circuit.foundation.NavigableCircuitContent com.slack.circuit.NavigatorDefaults com.slack.circuit.foundation.NavigatorDefaults com.slack.circuit.rememberCircuitNavigator com.slack.circuit.foundation.rememberCircuitNavigator com.slack.circuit.push com.slack.circuit.foundation.push com.slack.circuit.screen com.slack.circuit.foundation.screen"},{"location":"changelog/#more-highlights","title":"More Highlights","text":"<ul> <li>[Core] Remove Android-specific <code>NavigableCircuitContent</code> and just use common one. Back handling still runs through <code>BackHandler</code>, but is now configured in <code>rememberCircuitNavigator</code>.</li> <li>[Core] Add <code>defaultNavDecoration</code> to <code>CircuitConfig</code> to allow for customizing the default <code>NavDecoration</code> used in <code>NavigableCircuitContent</code>.</li> <li>[Core] Mark <code>CircuitUiState</code> as <code>@Stable</code> instead of <code>@Immutable</code>.</li> <li>[Code gen] Capitalize generated class names when source is a presenter function.</li> <li>[Sample] New <code>:samples:tacos</code> order builder sample to demonstrate complex state management.</li> <li>[Sample] <code>NavigableCircuitContent</code> example in the desktop counter.</li> <li>[Dependencies] Update compose to <code>1.4.1</code>.</li> <li>[Dependencies] Update compose-compiler to <code>1.4.4</code>.</li> <li>[Dependencies] Update androidx.activity to <code>1.7.0</code>.</li> <li>[Dependencies] Update molecule to <code>0.7.1</code>.</li> </ul>"},{"location":"changelog/#070","title":"0.7.0","text":"<p>2023-02-10</p> <ul> <li>New: Multiplatform support for <code>NavigableCircuitContent</code>! Special thanks to @ashdavies for contributions to make this possible.</li> <li>Fix: <code>circuit-retained</code> minSdk is now 21 again. We accidentally bumped it to 28 when merging in its instrumentation tests.</li> <li>Enhancement: embedded baseline profiles are now embedded per-artifact instead of in the root <code>circuit-core</code> artifact.</li> <li>Enhancement: <code>circuit-retained</code> is now covered in embedded baseline profiles.</li> <li>[Code Gen] Update Dagger to <code>2.45</code>.</li> <li>[Code Gen] Update KSP to <code>1.8.10-1.0.9</code>.</li> <li>Update to compose-compiler <code>1.4.2</code>.</li> <li>Update to Kotlin <code>1.8.10</code>.</li> </ul>"},{"location":"changelog/#060","title":"0.6.0","text":"<p>2023-02-02</p> <p>Happy groundhog day!</p> <ul> <li>Breaking API change: <code>Ui.Content()</code> now contains a <code>Modifier</code> parameter.</li> </ul> <p>This allows you to pass modifiers on to UIs directly.</p> <pre><code> public interface Ui&lt;UiState : CircuitUiState&gt; {\n-  @Composable public fun Content(state: UiState)\n+  @Composable public fun Content(state: UiState, modifier: Modifier)\n }\n</code></pre> <ul> <li>New: Add <code>Navigator.resetRoot(Screen)</code> function to reset the backstack root with a new root screen. There is a corresponding <code>awaitResetRoot()</code> function added to <code>FakeNavigator</code>.</li> <li>New: Add <code>EventListener.start</code> callback function.</li> <li>New: Add Compose UI dependency to circuit-core (to support <code>Modifier</code> in the API).</li> <li>Fix: Fix <code>CircuitContext.putTag</code> generics.</li> <li>Fix: Fix KSP code gen artifact to just be a pure JVM artifact.</li> <li>Fix: <code>EventListener.onState</code>\u2019s type is now <code>CircuitUiState</code> instead of <code>Any</code>.</li> <li>Removed: <code>ScreenUi</code> is now removed and <code>Ui.Factory</code> simply returns <code>Ui</code> instances now.</li> <li> <p>API Change: <code>CircuitConfig.onUnavailableContent</code> is now no longer nullable. By default it displays a big ugly error text. If you want the previous behavior of erroring, replace it with a composable function that just throws an exception.</p> </li> <li> <p>Dependency updates <pre><code>Kotlin 1.8.0\nCompose-JB 1.3.0\nKSP 1.8.0-1.0.9\nCompose Runtime 1.3.3\nCompose UI 1.3.3\nCompose Animation 1.3.3\n</code></pre></p> </li> </ul>"},{"location":"changelog/#050","title":"0.5.0","text":"<p>2022-12-22</p> <ul> <li>Enhancement: Circuit no longer requires manual provisioning of its internal backing <code>ViewModel</code>s. This is now done automatically by the Circuit itself.</li> <li>Enhancement: <code>circuit-retained</code> is now fully optional and not included as a transitive dependency of circuit-core. If you want to use it, see its installation instructions in its README.</li> <li>Enhancement: Mark <code>Screen</code> as <code>@Immutable</code>.</li> <li>Breaking API Change: <code>LocalCircuitOwner</code> is now just <code>LocalCircuitConfig</code> to be more idiomatic.</li> <li>Breaking API Change: <code>LocalRetainedStateRegistryOwner</code> is now just <code>LocalRetainedStateRegistry</code> to be more idiomatic.</li> <li>Breaking API Change: <code>Continuity</code> is now <code>internal</code> and not publicly exposed since it no longer needs to be manually provided.</li> <li>Breaking API Change: <code>ViewModelBackStackRecordLocalProvider</code> is now <code>internal</code> and not publicly exposed since it no longer needs to be manually provided.</li> <li>Fix: Add missing license info to pom.</li> <li>Dependency updates   <pre><code>[versions]\nanvil = \"2.4.3\"\ncompose-jb = \"1.2.2\"\ncompose-animation = \"1.3.2\"\ncompose-compiler = \"1.3.2\"\ncompose-foundation = \"1.3.1\"\ncompose-material = \"1.3.1\"\ncompose-material3 = \"1.0.1\"\ncompose-runtime = \"1.3.2\"\ncompose-ui = \"1.3.2\"\nkotlin = \"1.7.22\"\n</code></pre></li> </ul>"},{"location":"changelog/#040","title":"0.4.0","text":"<p>2022-12-07</p> <ul> <li>Breaking API Change: <code>Presenter</code> and <code>Ui</code> factories\u2019 <code>create()</code> functions now offer a <code>CircuitContext</code> parameter in place of a <code>CircuitConfig</code> parameter. This class contains a <code>CircuitConfig</code>, a tagging API, and access to parent contexts. This allows for plumbing your own metadata through Circuit\u2019s internals such as tracing tools, logging, etc.</li> <li>Enhancement: New lifecycle functions added to <code>EventListener</code>.</li> <li><code>onBeforeCreatePresenter</code></li> <li><code>onAfterCreatePresenter</code></li> <li><code>onBeforeCreateUi</code></li> <li><code>onAfterCreateUi</code></li> <li><code>onUnavailableContent</code></li> <li><code>onStartPresent</code></li> <li><code>onDisposePresent</code></li> <li><code>onStartContent</code></li> <li><code>onDisposeContent</code></li> <li><code>dispose</code></li> <li>Update Compose to <code>1.3.1</code>.</li> <li>Update Compose (JB) to <code>1.2.1</code>.</li> <li>Update Molecule to <code>0.6.1</code>.</li> <li>Added a demo to the STAR sample that shows how to navigate to standard Android components (#275).</li> </ul>"},{"location":"changelog/#031","title":"0.3.1","text":"<p>2022-11-07</p> <ul> <li>Enhancement: Add back the <code>onRootPop()</code> parameter in <code>rememberCircuitNavigator()</code> but use <code>LocalOnBackPressedDispatcherOwner</code> for backpress handling by default.</li> </ul>"},{"location":"changelog/#030","title":"0.3.0","text":"<p>2022-11-01</p> <ul> <li>New: The Overlay API is now extracted to a separate, optional <code>circuit-overlay</code> artifact.</li> <li>New: The <code>circuit-core</code> artifact now packages in baseline profiles.</li> <li>Enhancement: Simplify backstack root pop handling. There is no more <code>onRootPop()</code> option in <code>rememberCircuitNavigator()</code>, instead you should install your own <code>BackHandler()</code> prior to rendering your circuit content to customize back behavior when the circuit <code>Navigator</code> is at root.</li> <li>Fix: <code>circuit-codegen-annotations</code> is now a multiplatform project and doesn\u2019t accidentally impose the compose-desktop dependency.</li> </ul> <p>We\u2019ve also updated a number of docs around code gen, overlays, and interop (including a new interop sample).</p>"},{"location":"changelog/#022","title":"0.2.2","text":"<p>2022-10-27</p> <ul> <li>Enhancement: Code gen now supports non-assisted constructor-injected types.</li> <li>Enhancement: Code gen checks that functions and classes are visible to generated factories.</li> </ul>"},{"location":"changelog/#021","title":"0.2.1","text":"<p>2022-10-27</p> <ul> <li>Fix: Code gen didn\u2019t properly handle instantiating simple class types.</li> </ul>"},{"location":"changelog/#020","title":"0.2.0","text":"<p>2022-10-26</p> <ul> <li> <p>New: Code gen artifact. This targets specifically using Dagger + Anvil and will generate <code>Presenter</code> and <code>Ui.Factory</code> implementations for you. See <code>CircuitInject</code> for more details.   <pre><code>ksp(\"com.slack.circuit:circuit-codegen:x.y.z\")\nimplementation(\"com.slack.circuit:circuit-codegen-annotations:x.y.z\")\n</code></pre></p> </li> <li> <p>New: There is now an <code>EventListener</code> API for instrumenting state changes for a given <code>Screen</code>. See its docs for more details.</p> </li> <li>Fix: Rework <code>rememberRetained</code> implementation and support for multiple variables. Previously it only worked with one variable.</li> <li>Fix: Clean up some unnecessary transitive dependencies in misc artifacts.</li> </ul> <p>Dependency updates</p> <pre><code>androidx.activity 1.6.1\nandroidx.compose 1.3.0\nMolecule 0.5.0\n</code></pre>"},{"location":"changelog/#012","title":"0.1.2","text":"<p>2022-10-12</p> <ul> <li>Update to compose-jb <code>1.2.0</code>.</li> <li>Update to Turbine <code>0.12.0</code>.</li> <li>Fix: Accidentally running molecule twice in <code>Presenter.test()</code>.</li> </ul>"},{"location":"changelog/#011","title":"0.1.1","text":"<p>2022-10-10</p> <ul> <li>Fix: Accidentally bundling more Compose UI dependencies than necessary.</li> </ul>"},{"location":"changelog/#010","title":"0.1.0","text":"<p>2022-10-10</p> <p>Initial release, see the docs: https://slackhq.github.io/circuit/.</p> <p>Note that this library is still under active development and not recommended for production use. We\u2019ll do a more formal announcement when that time comes!</p>"},{"location":"circuit-content/","title":"CircuitContent","text":"<p>The simplest entry point of a Circuit screen is the composable <code>CircuitContent</code> function. This function accepts a <code>Screen</code> and automatically finds and pairs corresponding <code>Presenter</code> and <code>Ui</code> instances to render in it.</p> <pre><code>CircuitCompositionLocals(circuit) {\n  CircuitContent(HomeScreen)\n}\n</code></pre> <p>This can be used for simple screens or as nested components of larger, more complex screens.</p>"},{"location":"circuitx/","title":"CircuitX","text":"<p>CircuitX is a suite of extension artifacts for Circuit. These artifacts are intended to be batteries-included implementations of common use cases, such as out-of-the-box <code>Overlay</code> types or Android navigation interop.</p> <p>These packages differ from Circuit\u2019s core artifacts in a few ways:</p> <ul> <li>Their APIs may change more frequently during Circuit\u2019s development.</li> <li>These artifacts won\u2019t ship with their own baseline profiles.</li> <li>These artifacts are under the <code>com.slack.circuitx</code> package prefix.</li> <li>These artifacts may be platform-specific where appropriate.</li> </ul>"},{"location":"circuitx/#android","title":"Android","text":"<p>The <code>circuitx-android</code> artifact contains Android-specific extensions for Circuit.</p> <pre><code>dependencies {\n  implementation(\"com.slack.circuit:circuitx-android:&lt;version&gt;\")\n}\n</code></pre>"},{"location":"circuitx/#navigation","title":"Navigation","text":"<p>It can be important for Circuit to be able to navigate to Android targets, such as other activities or custom tabs. To support this, decorate your existing <code>Navigator</code> instance with <code>rememberAndroidScreenAwareNavigator()</code>.</p> <pre><code>class MainActivity : Activity {\n  override fun onCreate(savedInstanceState: Bundle?) {\n    setContent {\n      val backstack = rememberSaveableBackStack { push(HomeScreen) }\n      val navigator = rememberAndroidScreenAwareNavigator(\n        rememberCircuitNavigator(backstack), // Decorated navigator\n        this@MainActivity\n      )\n      CircuitCompositionLocals(circuit) {\n        NavigableCircuitContent(navigator, backstack)\n      }\n    }\n  }\n}\n</code></pre> <p><code>rememberAndroidScreenAwareNavigator()</code> has two overloads - one that accepts a <code>Context</code> and one that accepts an <code>AndroidScreenStarter</code>. The former is just a shorthand for the latter that only supports <code>IntentScreen</code>. You can also implement your own starter that supports other screen types.</p> <p><code>AndroidScreen</code> is the base <code>Screen</code> type that this navigator and <code>AndroidScreenStarter</code> interact with. There is a built-in <code>IntentScreen</code> implementation that wraps an <code>Intent</code> and an options <code>Bundle</code> to pass to <code>startActivity()</code>. Custom <code>AndroidScreens</code> can be implemented separately and route through here, but you should be sure to implement your own <code>AndroidScreenStarter</code> to handle them accordingly.</p>"},{"location":"circuitx/#gesture-navigation","title":"Gesture Navigation","text":"<p>CircuitX provides <code>NavDecoration</code> implementation which support navigation through appropriate gestures on certain platforms.</p> <pre><code>dependencies {\n  implementation(\"com.slack.circuit:circuitx-gesture-navigation:&lt;version&gt;\")\n}\n</code></pre> <p>To enable gesture navigation support, you can use the use the <code>GestureNavigationDecoration</code> function:</p> <pre><code>NavigableCircuitContent(\n  navigator = navigator, \n  backstack = backstack,\n  decoration = GestureNavigationDecoration(\n    // Pop the back stack once the user has gone 'back'\n    navigator::pop\n  )\n)\n</code></pre>"},{"location":"circuitx/#android_1","title":"Android","text":"<p>On Android, this supports the Predictive back gesture which is available on Android 14 and later (API level 34+). On older platforms, Circuit\u2019s default <code>NavDecoration</code> decoration is used instead.</p> Star sample running on an Android 14 device"},{"location":"circuitx/#ios","title":"iOS","text":"<p>On iOS, this simulates iOS\u2019s \u2018Interactive Pop Gesture\u2019 in Compose UI, allowing the user to swipe Circuit UIs away. As this is a simulation of the native behavior, it does not match the native functionality perfectly. However, it is a good approximation.</p> Tivi app running on iPhone"},{"location":"circuitx/#other-platforms","title":"Other platforms","text":"<p>On other platforms we defer to Circuit\u2019s default <code>NavDecoration</code> decoration.</p>"},{"location":"circuitx/#overlays","title":"Overlays","text":"<p>CircuitX provides a few out-of-the-box <code>Overlay</code> implementations that you can use to build common UIs.</p> <pre><code>dependencies {\n  implementation(\"com.slack.circuit:circuitx-overlays:&lt;version&gt;\")\n}\n</code></pre>"},{"location":"circuitx/#bottomsheetoverlay","title":"BottomSheetOverlay","text":"<p><code>BottomSheetOverlay</code> is an overlay that shows a bottom sheet with a strongly-typed API for the input model to the sheet content and result type. This allows you to easily use a bottom sheet to prompt for user input and suspend the underlying Circuit content until that result is returned.</p> <pre><code>/** A hypothetical bottom sheet of available actions when long-pressing a list item. */\nsuspend fun OverlayHost.showLongPressActionsSheet(): Action {\n  return show(\n    BottomSheetOverlay(\n      model = listOfActions()\n    ) { actions, overlayNavigator -&gt;\n      ActionsSheet(\n        actions,\n        overlayNavigator::finish // Finish the overlay with the clicked Action\n      )\n    }\n  )\n}\n\n@Composable\nfun ActionsSheet(actions: List&lt;Action&gt;, onActionClicked: (Action) -&gt; Unit) {\n  Column {\n    actions.forEach { action -&gt;\n      TextButton(onClick = { onActionClicked(action) }) {\n        Text(action.title)\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"circuitx/#fullscreenoverlay","title":"FullScreenOverlay","text":"<p>Sometimes it\u2019s useful to have a full-screen overlay that can be used to show a screen in full above the current content. This API is fairly simple to use and just takes a <code>Screen</code> input of what content you want to show in the overlay.</p> <pre><code>overlayHost.showFullScreenOverlay(\n  ImageViewerScreen(id = url, url = url, placeholderKey = name)\n)\n</code></pre> <p>When to use <code>FullScreenOverlay</code> vs navigating to a <code>Screen</code>?</p> <p>While they achieve similar results, the key difference is that <code>FullScreenOverlay</code> is  inherently an ephemeral UI that is controlled by an underlying primary UI. It cannot  navigate elsewhere and it does not participate in the backstack.</p>"},{"location":"code-gen/","title":"Code Generation","text":"<p>If using Dagger and Anvil, Circuit offers a KSP-based code gen solution to ease boilerplate around generating factories.</p>"},{"location":"code-gen/#installation","title":"Installation","text":"<pre><code>plugins {\n  id(\"com.google.devtools.ksp\")\n}\n\ndependencies {\n  api(\"com.slack.circuit:circuit-codegen-annotations:&lt;version&gt;\")\n  ksp(\"com.slack.circuit:circuit-codegen:&lt;version&gt;\")\n}\n</code></pre>"},{"location":"code-gen/#usage","title":"Usage","text":"<p>The primary entry point is the <code>CircuitInject</code> annotation.</p> <p>This annotation is used to mark a UI or presenter class or function for code generation. When annotated, the type\u2019s corresponding factory will be generated and keyed with the defined <code>screen</code>.</p> <p>The generated factories are then contributed to Anvil via <code>ContributesMultibinding</code> and scoped with the provided <code>scope</code> key.</p>"},{"location":"code-gen/#classes","title":"Classes","text":"<p><code>Presenter</code> and <code>Ui</code> classes can be annotated and have their corresponding <code>Presenter.Factory</code> or <code>Ui.Factory</code> classes generated for them.</p> <p>Presenter <pre><code>@CircuitInject(HomeScreen::class, AppScope::class)\nclass HomePresenter @Inject constructor(...) : Presenter&lt;HomeState&gt; { ... }\n\n// Generates\n@ContributesMultibinding(AppScope::class)\nclass HomePresenterFactory @Inject constructor() : Presenter.Factory { ... }\n</code></pre></p> <p>UI <pre><code>@CircuitInject(HomeScreen::class, AppScope::class)\nclass HomeUi @Inject constructor(...) : Ui&lt;HomeState&gt; { ... }\n\n// Generates\n@ContributesMultibinding(AppScope::class)\nclass HomeUiFactory @Inject constructor() : Ui.Factory { ... }\n</code></pre></p>"},{"location":"code-gen/#functions","title":"Functions","text":"<p>Simple functions can be annotated and have a corresponding <code>Presenter.Factory</code> generated. This is primarily useful for simple cases where a class is just technical tedium.</p> <p>Requirements - Presenter function names must end in <code>Presenter</code>, otherwise they will be treated as UI functions. - Presenter functions must return a <code>CircuitUiState</code> type. - UI functions can optionally accept a <code>CircuitUiState</code> type as a parameter, but it is not required. - UI functions must return <code>Unit</code>. - Both presenter and UI functions must be <code>Composable</code>.</p> <p>Presenter <pre><code>@CircuitInject(HomeScreen::class, AppScope::class)\n@Composable\nfun HomePresenter(): HomeState { ... }\n\n// Generates\n@ContributesMultibinding(AppScope::class)\nclass HomePresenterFactory @Inject constructor() : Presenter.Factory { ... }\n</code></pre></p> <p>UI <pre><code>@CircuitInject(HomeScreen::class, AppScope::class)\n@Composable\nfun Home(state: HomeState) { ... }\n*\n// Generates\n@ContributesMultibinding(AppScope::class)\nclass HomeUiFactory @Inject constructor() : Ui.Factory { ... }\n</code></pre></p>"},{"location":"code-gen/#assisted-injection","title":"Assisted injection","text":"<p>Any type that is offered in <code>Presenter.Factory</code> and <code>Ui.Factory</code> can be offered as an assisted injection to types using Dagger <code>AssistedInject</code>. For these cases, the <code>AssistedFactory</code> -annotated interface should be annotated with <code>CircuitInject</code> instead of the enclosing class.</p> <p>Types available for assisted injection are:</p> <ul> <li><code>Screen</code> \u2013 the screen key used to create the <code>Presenter</code> or <code>Ui</code>.</li> <li><code>Navigator</code> \u2013 (presenters only)</li> <li><code>Circuit</code></li> </ul> <p>Each should only be defined at-most once.</p> <p>Examples <pre><code>// Function example\n@CircuitInject(HomeScreen::class, AppScope::class)\n@Composable\nfun HomePresenter(screen: Screen, navigator: Navigator): HomeState { ... }\n\n// Class example\nclass HomePresenter @AssistedInject constructor(\n  @Assisted screen: Screen,\n  @Assisted navigator: Navigator,\n  ...\n) : Presenter&lt;HomeState&gt; {\n  // ...\n  @CircuitInject(HomeScreen::class, AppScope::class)\n  @AssistedFactory\n  fun interface Factory {\n    fun create(screen: Screen, navigator: Navigator, context: CircuitContext): HomePresenter\n  }\n}\n</code></pre></p>"},{"location":"code-of-conduct/","title":"Code of Conduct","text":""},{"location":"code-of-conduct/#introduction","title":"Introduction","text":"<p>Diversity and inclusion make our community strong. We encourage participation from the most varied and diverse backgrounds possible and want to be very clear about where we stand.</p> <p>Our goal is to maintain a safe, helpful and friendly community for everyone, regardless of experience, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, nationality, or other defining characteristic.</p> <p>This code and related procedures also apply to unacceptable behavior occurring outside the scope of community activities, in all community venues (online and in-person) as well as in all one-on-one communications, and anywhere such behavior has the potential to adversely affect the safety and well-being of community members.</p> <p>For more information on our code of conduct, please visit https://slackhq.github.io/code-of-conduct</p>"},{"location":"contributing/","title":"Contributors Guide","text":"<p>Note that this project is considered READ-ONLY. You are welcome to discuss or ask questions in the discussions section of the repo, but we do not normally accept external contributions without prior discussion.</p>"},{"location":"contributing/#development","title":"Development","text":"<p>Check out this repo with Android Studio. It\u2019s a standard gradle project and conventional to checkout.</p> <p>The primary project is <code>circuit</code>. The primary sample is <code>samples/star</code>.</p> <p>This project is written in Kotlin and should only use Kotlin.</p> <p>Code formatting is checked via Spotless. To run the formatter, use the <code>spotlessApply</code> command.</p> <pre><code>./gradlew spotlessApply\n</code></pre>"},{"location":"factories/","title":"Factories","text":"<p>At its core, Circuit works on the Factory pattern. Every <code>Presenter</code> and <code>Ui</code> is contributed to a <code>Circuit</code> instance by a corresponding factory that creates them for given <code>Screen</code>s. These are intended to be aggregated in the DI layer and added to a <code>Circuit</code> instance during construction.</p> <pre><code>val circuit = Circuit.Builder()\n  .addUiFactory(FavoritesUiFactory())\n  .addPresenterFactory(FavoritesPresenterFactory())\n  .build()\n</code></pre> <p>Look familiar?</p> <p>If you\u2019ve used Moshi or Retrofit, these should feel fairly familiar!</p> <p>Presenter factories can be generated or hand-written, depending on if they aggregate an entire screen or are simple one-offs. Presenters are also given access to the current Navigator in this level.</p> <pre><code>class FavoritesScreenPresenterFactory @Inject constructor(\n  private val favoritesPresenterFactory: FavoritesPresenter.Factory,\n) : Presenter.Factory {\n  override fun create(screen: Screen, navigator: Navigator, context: CircuitContext): Presenter&lt;*&gt;? {\n    return when (screen) {\n      is FavoritesScreen -&gt; favoritesPresenterFactory.create(screen, navigator, context)\n      else -&gt; null\n    }\n  }\n}\n</code></pre> <p>UI factories are similar, but generally should not aggregate other UIs unless there\u2019s a DI-specific reason to do so (which there usually isn\u2019t!).</p> <pre><code>class FavoritesScreenUiFactory @Inject constructor() : Ui.Factory {\n  override fun create(screen: Screen, context: CircuitContext): Ui&lt;*&gt;? {\n    return when (screen) {\n      is FavoritesScreen -&gt; favoritesUi()\n      else -&gt; null\n    }\n  }\n}\n\nprivate fun favoritesUi() = ui&lt;State&gt; { state, modifier -&gt; Favorites(state, modifier) }\n</code></pre> <p>Info</p> <p>Note how these include a <code>Modifier</code>. You should pass on these modifiers to your UI. Always provide a modifier!</p> <p>We canonically write these out as a separate function (<code>favoritesUi()</code>) that returns a <code>Ui</code>, which in turn calls through to the real (basic) Compose UI function (<code>Favorites()</code>). This ensures our basic compose functions are top-level and accessible by tests, and also discourages storing anything in class members rather than idiomatic composable state vars. If you use code gen, it handles the intermediate function for you.</p>"},{"location":"interop/","title":"Interop","text":"<p>Circuit can interop anywhere that Compose can interop. This includes common cases like Android  <code>Views</code>, RxJava, Kotlin <code>Flow</code>, and more.</p>"},{"location":"interop/#presenter","title":"<code>Presenter</code>","text":"<p>Lean on first-party interop-APIs where possible! See examples of interop with different libraries in the <code>:samples:interop</code> project.</p>"},{"location":"interop/#ui","title":"<code>UI</code>","text":""},{"location":"interop/#ui-view","title":"<code>Ui</code> -&gt; <code>View</code>","text":"<p>Just embed the Circuit in a <code>ComposeView</code> like any other Compose UI.</p>"},{"location":"interop/#view-ui","title":"<code>View</code> -&gt; <code>Ui</code>","text":"<p>You can wrap your view in an <code>AndroidView</code> in a custom <code>Ui</code> implementation. </p> <pre><code>class ExistingCustomViewUi : Ui&lt;State&gt; {\n  @Composable\n  fun Content(state: State, modifier: Modifier = Modifier) {\n    AndroidView(\n      modifier = ...\n      factory = { context -&gt;\n        ExistingCustomView(context)\n      },\n      update = { view -&gt;\n        view.setState(state)\n        view.setOnClickListener { state.eventSink(Event.Click) }\n      }\n  }\n}\n</code></pre>"},{"location":"navigation/","title":"Navigation","text":"<p>For navigable contents, we have a custom compose-based backstack implementation that the androidx folks shared with us. Navigation becomes two parts:</p> <ol> <li>A <code>BackStack</code>, where we use a <code>SaveableBackStack</code> implementation that saves a stack of <code>Screen</code>s and the <code>ProvidedValues</code> for each record on that stack (allowing us to save and restore on configuration changes automatically).</li> <li>A <code>Navigator</code>, which is a simple interface that we can point at a <code>BackStack</code> and offers simple <code>goTo(&lt;screen&gt;)</code>/<code>pop()</code> semantics. These are offered to presenters to perform navigation as needed to other screens.</li> </ol> <p>A new navigable content surface is handled via the <code>NavigableCircuitContent</code> functions.</p> <pre><code>setContent {\n  val backstack = rememberSaveableBackStack { push(HomeScreen) }\n  val navigator = rememberCircuitNavigator(backstack)\n  NavigableCircuitContent(navigator, backstack)\n}\n</code></pre> <p>Warning</p> <p><code>SaveableBackStack</code> must have a size of 1 or more after initialization. It\u2019s an error to have a backstack with zero items.</p> <p>Presenters are then given access to these navigator instances via <code>Presenter.Factory</code> (described in Factories), which they can save if needed to perform navigation.</p> <pre><code>fun showAddFavorites() {\n  navigator.goTo(\n    AddFavorites(\n      externalId = uuidGenerator.generate()\n    )\n  )\n}\n</code></pre> <p>If you want to have custom behavior for when back is pressed on the root screen (i.e. <code>backstack.size == 1</code>), you should implement your own <code>BackHandler</code> and use it before creating the backstack.</p> <pre><code>setContent {\n  val backstack = rememberSaveableBackStack { push(HomeScreen) }\n  BackHandler(onBack = { /* do something on root */ })\n  // The Navigator's internal BackHandler will take precedence until it is at the root screen.\n  val navigator = rememberCircuitNavigator(backstack)\n  NavigableCircuitContent(navigator, backstack)\n}\n</code></pre>"},{"location":"navigation/#nested-navigation","title":"Nested Navigation","text":"<p>Navigation carries special semantic value in <code>CircuitContent</code> as well, where it\u2019s common for UIs to want to curry navigation events emitted by nested UIs. For this case, there\u2019s a <code>CircuitContent</code> overload that accepts an optional onNavEvent callback that you must then forward to a Navigator instance.</p> <pre><code>@Composable fun ParentUi(state: ParentState, modifier: Modifier = Modifier) {\n  CircuitContent(NestedScreen, modifier = modifier, onNavEvent = { navEvent -&gt; state.eventSink(NestedNav(navEvent)) })\n}\n\n@Composable fun ParentPresenter(navigator: Navigator): ParentState {\n  return ParentState(...) { event -&gt;\n    when (event) {\n      is NestedNav -&gt; navigator.onNavEvent(event.navEvent)\n    }\n  }\n}\n\n@Composable \nfun NestedPresenter(navigator: Navigator): NestedState {\n  // These are forwarded up!\n  navigator.goTo(AnotherScreen)\n\n  // ...\n}\n</code></pre>"},{"location":"overlays/","title":"Overlays","text":"<p>The <code>circuit-overlay</code> artifact contains an optional API for presenting overlays on top of the current UI.</p>"},{"location":"overlays/#usage","title":"Usage","text":"<p>The core APIs are the <code>Overlay</code> and <code>OverlayHost</code> interfaces.</p>"},{"location":"overlays/#overlay","title":"Overlay","text":"<p>An <code>Overlay</code> is composable content that can be shown on top of other content via an <code>OverlayHost</code>. Overlays are typically used for one-off request/result flows and should not usually attempt to do any sort of external navigation or make any assumptions about the state of the app. They should only emit a <code>Result</code> to the given <code>OverlayNavigator</code> parameter when they are done.</p> <pre><code>interface Overlay&lt;Result : Any&gt; {\n  @Composable\n  fun Content(navigator: OverlayNavigator&lt;Result&gt;)\n}\n</code></pre> <p>For common overlays, it\u2019s useful to create a common <code>Overlay</code> subtype that can be reused. For example: <code>BottomSheetOverlay</code>, <code>ModalOverlay</code>, <code>TooltipOverlay</code>, etc.</p>"},{"location":"overlays/#overlayhost","title":"OverlayHost","text":"<p>An <code>OverlayHost</code> is provided via composition local and exposes a <code>suspend show()</code> function to show an overlay and resume with a typed <code>Result</code>.</p> <pre><code>val result = LocalOverlayHost.current.show(BottomSheetOverlay(...))\n</code></pre> <p>Where <code>BottomSheetOverlay</code> is a custom bottom sheet implementation of an <code>Overlay</code>.</p>"},{"location":"overlays/#installation","title":"Installation","text":"<p>Add the dependency.</p> <pre><code>implementation(\"com.slack.circuit:circuit-overlay:$circuit_version\")\n</code></pre> <p>The simplest starting point for adding overlay support is the <code>ContentWithOverlays</code> composable function.</p> <pre><code>ContentWithOverlays {\n  // Your content here\n}\n</code></pre> <p>This will expose a <code>LocalOverlayHost</code> composition local that can be used by UIs to show overlays.</p>"},{"location":"presenter/","title":"Presenter","text":"<p>The core Presenter interface is this:</p> <pre><code>interface Presenter&lt;UiState : CircuitUiState&gt; {\n  @Composable fun present(): UiState\n}\n</code></pre> <p>Presenters are solely intended to be business logic for your UI and a translation layer in front of your data layers. They are generally Dagger-injected types as the data layers they interpret are usually coming from the DI graph. In simple cases, they can be typed as a simple <code>@Composable</code> presenter function allowing Circuit code gen to generate the corresponding interface and factory for you.</p> <p>A very simple presenter can look like this:</p> <pre><code>class FavoritesPresenter(...) : Presenter&lt;State&gt; {\n  @Composable override fun present(): State {\n    var favorites by remember { mutableStateOf(&lt;initial&gt;) }\n\n    return State(favorites) { event -&gt; ... }\n  }\n}\n</code></pre> <p>In this example, the <code>present()</code> function simply computes a <code>state</code> and returns it. If it has UI events to handle, an <code>eventSink: (Event) -&gt; Unit</code> property should be exposed in the <code>State</code> type it returns.</p> <p>With DI, the above example becomes something more like this:</p> <pre><code>class FavoritesPresenter @AssistedInject constructor(\n  @Assisted private val screen: FavoritesScreen,\n  @Assisted private val navigator: Navigator,\n  private val favoritesRepository: FavoritesRepository\n) : Presenter&lt;State&gt; {\n  @Composable override fun present(): State {\n    // ...\n  }\n  @AssistedFactory\n  fun interface Factory {\n    fun create(screen: FavoritesScreen, navigator: Navigator, context: CircuitContext): FavoritesPresenter\n  }\n}\n</code></pre> <p>Assisted injection allows passing on the <code>screen</code> and <code>navigator</code> from the relevant <code>Presenter.Factory</code> to this presenter for further reference.</p> <p>When dealing with nested presenters, a presenter could bypass implementing a class entirely by simply being written as a function that other presenters can use. </p> <pre><code>// From cashapp/molecule's README examples\n@Composable\nfun ProfilePresenter(\n  userFlow: Flow&lt;User&gt;,\n  balanceFlow: Flow&lt;Long&gt;,\n): ProfileModel {\n  val user by userFlow.collectAsState(null)\n  val balance by balanceFlow.collectAsState(0L)\n\n  return if (user == null) {\n    Loading\n  } else {\n    Data(user.name, balance)\n  }\n}\n</code></pre> <p>Presenters can present other presenters by injecting their assisted factories/providers, but note that this makes them a composite presenter that is now assuming responsibility for managing state of multiple nested presenters.</p>"},{"location":"presenter/#retention","title":"Retention","text":"<p>There are three types of composable retention functions used in Circuit.</p> <ol> <li><code>remember</code> \u2013 from Compose, remembers a value across recompositions. Can be any type.</li> <li><code>rememberRetained</code> \u2013 custom, remembers a value across recompositions and configuration changes. Can be any type, but should not retain leak-able things like <code>Navigator</code> instances or <code>Context</code> instances. Backed by a hidden <code>ViewModel</code> on Android. Note that this is not necessary in most cases if handling configuration changes yourself via <code>android:configChanges</code>.</li> <li><code>rememberSaveable</code> \u2013 from Compose, remembers a value across recompositions, configuration changes, and process death. Must be <code>Parcelable</code> or implement a custom <code>Saver</code>, should not retain leakable things like <code>Navigator</code> instances or <code>Context</code> instances. Backed by the framework saved instance state system.</li> </ol> <p>Developers should use the right tool accordingly depending on their use case. Consider these three examples.</p> <p>The first one will preserve the <code>count</code> value across recompositions, but not configuration changes or process death.</p> <pre><code>@Composable\nfun CounterPresenter(): CounterState {\n  var count by remember { mutableStateOf(0) }\n\n  return CounterState(count) { event -&gt;\n    when (event) {\n      is CounterEvent.Increment -&gt; count++\n      is CounterEvent.Decrement -&gt; count--\n    }\n  }\n}\n</code></pre> <p>The second one will preserve the state across recompositions and configuration changes, but not process death.</p> <pre><code>@Composable\nfun CounterPresenter(): CounterState {\n  var count by rememberRetained { mutableStateOf(0) }\n\n  return CounterState(count) { event -&gt;\n    when (event) {\n      is CounterEvent.Increment -&gt; count++\n      is CounterEvent.Decrement -&gt; count--\n    }\n  }\n}\n</code></pre> <p>The third case will preserve the <code>count</code> state across recompositions, configuration changes, and process death. However, it only works with primitives or <code>Parcelable</code> state types.</p> <pre><code>@Composable\nfun CounterPresenter(): CounterState {\n  var count by rememberSaveable { mutableStateOf(0) }\n\n  return CounterState(count) { event -&gt;\n    when (event) {\n      is CounterEvent.Increment -&gt; count++\n      is CounterEvent.Decrement -&gt; count--\n    }\n  }\n}\n</code></pre>"},{"location":"screen/","title":"Screen","text":"<p>Screens are keys for Presenter and UI pairings.</p> <p>The core <code>Screen</code> interface is this:</p> <pre><code>interface Screen : Parcelable\n</code></pre> <p>These types are <code>Parcelable</code> on Android for saveability in our backstack and easy deeplinking. A  <code>Screen</code> can be a simple marker <code>data object</code> or a <code>data class</code> with information to pass on.</p> <pre><code>@Parcelize\ndata object HomeScreen : Screen\n\n@Parcelize\ndata class AddFavoritesScreen(val externalId: UUID) : Screen\n</code></pre> <p>These are used by <code>Navigator</code>s (when called from presenters) or <code>CircuitContent</code> (when called from UIs) to start a new sub-circuit or nested circuit.</p> <pre><code>// In a presenter class\nfun showAddFavorites() {\n  navigator.goTo(\n    AddFavoritesScreen(\n      externalId = uuidGenerator.generate()\n    )\n  )\n}\n</code></pre> <p>The information passed into a screen can also be used to interact with the data layer. In the example here, we are getting the <code>externalId</code> from the screen in order to get information back from our repository. </p> <pre><code>// In a presenter class\nclass AddFavoritesPresenter\n@AssistedInject\nconstructor(\n  @Assisted private val screen: AddFavoritesScreen,\n  private val favoritesRepository: FavoritesRepository,\n) : Presenter&lt;AddFavoritesScreen.State&gt; {\n  @Composable\n  override fun present() : AddFavoritesScreen.State {\n      val favorite = favoritesRepository.getFavorite(screen.externalId)\n      // ...\n  }\n}\n</code></pre> <p>Screens are also used to look up those corresponding components in <code>Circuit</code>.</p> <pre><code>val presenter: Presenter&lt;*&gt;? = circuit.presenter(addFavoritesScreen, navigator)\nval ui: Ui&lt;*&gt;? = circuit.ui(addFavoritesScreen)\n</code></pre> <p>Nomenclature</p> <p>Semantically, in this example we would call all of these components together the \u201cAddFavorites Screen\u201d.</p>"},{"location":"setup/","title":"Setting up Circuit","text":"<p>Setting up Circuit is a breeze! Just add the following to your build:</p>"},{"location":"setup/#installation","title":"Installation","text":"<p>The simplest way to get up and running is with the <code>circuit-foundation</code> dependency, which includes all the core Circuit artifacts.</p> <pre><code>dependencies {\n  implementation(\"com.slack.circuit:circuit-foundation:&lt;version&gt;\")\n}\n</code></pre>"},{"location":"setup/#setup","title":"Setup","text":"<p>Create a <code>Circuit</code> instance. This controls all your common configuration, Presenter/Ui factories, etc.</p> <pre><code>val circuit = Circuit.Builder()\n  .addUiFactory(AddFavoritesUiFactory())\n  .addPresenterFactory(AddFavoritesPresenterFactory())\n  .build()\n</code></pre> <p>This configuration can be rebuilt via <code>newBuilder()</code> and usually would live in your program\u2019s DI graph.</p> <p>Once you have a configuration ready, the simplest way to get going with Circuit is via <code>CircuitCompositionLocals</code>. This automatically exposes the config to all child Circuit composables and allows you to get off the ground quickly with <code>CircuitContent</code>, <code>NavigableCircuitContent</code>, etc.</p> <pre><code>CircuitCompositionLocals(circuit) {\n  CircuitContent(AddFavoritesScreen())\n}\n</code></pre> <p>See the docs for <code>CircuitContent</code> and <code>NavigableCircuitContent</code> for more information.</p>"},{"location":"setup/#granular-artifacts","title":"Granular Artifacts","text":"<p>Circuit is split into a few different artifacts to allow for more granular control over your dependencies. The following table shows the available artifacts and their purpose:</p> Artifact ID Dependencies <code>circuit-backstack</code> Circuit\u2019s backstack implementation. <code>circuit-runtime</code> Common runtime components like <code>Screen</code>, <code>Navigator</code>, etc. <code>circuit-runtime-presenter</code> The <code>Presenter</code> API, depends on <code>circuit-runtime</code>. <code>circuit-runtime-ui</code> The <code>Ui</code> API, depends on <code>circuit-runtime</code>. <code>circuit-foundation</code> The Circuit foundational APIs like <code>Circuit</code>, <code>CircuitContent</code>, etc. Depends on the first three. <code>circuit-test</code> First-party test APIs for testing navigation, state emissions, and event sinks. <code>circuit-overlay</code> Optional <code>Overlay</code> APIs. <code>circuit-retained</code> Optional <code>rememberRetained()</code> APIs."},{"location":"setup/#platform-support","title":"Platform Support","text":"<p>Circuit is a multiplatform library, but not all features are available on all platforms. The following table shows which features are available on which platforms:</p> <ul> <li>\u2705 Available</li> <li>\u274c Not available</li> <li>\u2013 Not applicable</li> </ul> Feature Android JVM iOS JS Notes <code>Backstack</code> \u2705 \u2705 \u2705 \u2705 <code>CircuitContent</code> \u2705 \u2705 \u2705 \u2705 <code>ContentWithOverlays</code> \u2705 \u2705 \u2705 \u2705 <code>NavigableCircuitContent</code> \u2705 \u2705 \u2705 \u2705 <code>Navigator</code> \u2705 \u2705 \u2705 \u2705 <code>SaveableBackstack</code> \u2705 \u2705 \u2705 \u2705 Saveable is a no-op on non-android. <code>rememberCircuitNavigator</code> \u2705 \u2705 \u2705 \u2705 <code>rememberRetained</code> \u2705 \u2705 \u2705 \u2705 <code>TestEventSink</code> \u2705 \u2705 \u2705 \u2705 On JS you must use <code>asEventSinkFunction()</code>."},{"location":"states-and-events/","title":"States and Events","text":"<p>The core state and event interfaces in Circuit are <code>CircuitUiState</code> and <code>CircuitUiEvent</code>. All state and event types should implement/extend these marker interfaces.</p> <p>Presenters are simple functions that determine and return composable states. UIs are simple functions that render states. Uis can emit events via <code>eventSink</code> properties in state classes, which presenters then handle. These are the core building blocks!</p> <p>States should be <code>@Stable</code>; events should be <code>@Immutable</code>.</p> <p>Wait, event callbacks in state types?</p> <p>Yep! This may feel like a departure from how you\u2019ve written UDF patterns in the past, but we really like it. We tried different patterns before with event <code>Flow</code>s and having Circuit internals manage these for you, but we found they came with tradeoffs and friction points that we could avoid by just treating event emissions as another aspect of state. The end result is a tidier structure of state + event flows.</p> <ul> <li>Simpler cognitive overheads due to not always using <code>Flow</code> for events, which comes with caveats in compose (wrapping operators in <code>remember</code> calls, pipelining nested event flows, etc)</li> <li>Simple event-less UIs \u2013 state just doesn\u2019t have an event sink.</li> <li>Simpler testing \u2013 no manual event flow needed. You end up writing more realistic tests where you tick along your presenter by emitting with its returned states directly.</li> <li>Different state types can have different event handling (e.g. <code>Click</code> may not make sense for <code>Loading</code> states).</li> <li>No internal ceremony around setting up a <code>Channel</code> and multicasting event streams.</li> <li>No risk of dropping events (unlike <code>Flow</code>).</li> </ul> <p>Note</p> <p>Currently, while functions are treated as implicitly <code>Stable</code> by the compose compiler, they\u2019re not skippable when they\u2019re non-composable Unit-returning lambdas with equal-but-unstable captures. This may change though, and would be another free benefit for this case.</p> <p>A longer-form writeup can be found in this PR.</p>"},{"location":"testing/","title":"Testing","text":"<p>Circuit is designed to make testing as easy as possible. Its core components are not mockable nor do they need to be mocked. Fakes are provided where needed, everything else can be used directly.</p> <p>Circuit will have a test artifact containing APIs to aid testing both presenters and composable UIs:</p> <ul> <li><code>Presenter.test()</code> - an extension function that bridges the Compose and coroutines world. Use of this function is recommended for testing presenter state emissions and incoming UI events. Under the hood it leverages Molecule and Turbine.</li> <li><code>FakeNavigator</code> - a test fake implementing the Circuit/Navigator interface. Use of this object is recommended when testing screen navigation (ie. goTo, pop/back).</li> <li><code>TestEventSink</code> - a generic test fake for recording and asserting event emissions through an event sink function.</li> </ul>"},{"location":"testing/#installation","title":"Installation","text":"<p>Test helpers are available via the <code>circuit-test</code> artifact.</p> <pre><code>testImplementation(\"com.slack.circuit:circuit-test:&lt;version&gt;\")\n</code></pre> <p>For Gradle JVM projects, you can use Gradle test fixtures syntax on the core circuit artifact.</p> <pre><code>testImplementation(testFixtures(\"com.slack.circuit:circuit:&lt;version&gt;\"))\n</code></pre>"},{"location":"testing/#example","title":"Example","text":"<p>Testing a Circuit Presenter and UI is a breeze! Consider the following example:</p> <pre><code>data class Favorite(id: Long, ...)\n\n@Parcelable\ndata object FavoritesScreen : Screen {\n  sealed interface State : CircuitUiState {\n    data object Loading : State\n    data object NoFavorites : State\n    data class Results(\n      val list: List&lt;Favorite&gt;,\n      val eventSink: (Event) -&gt; Unit\n    ) : State\n  }\n\n  sealed interface Event : CircuitUiEvent {\n    data class ClickFavorite(id: Long): Event\n  }\n}\n\nclass FavoritesPresenter @Inject constructor(\n    navigator: Navigator,\n    repo: FavoritesRepository\n) : Presenter&lt;State&gt; {\n  @Composable override fun present(): State {\n    val favorites by produceState&lt;List&lt;Favorites&gt;?&gt;(null) {\n      value = repo.getFavorites()\n    }\n\n    return when {\n      favorites == null -&gt; Loading\n      favorites.isEmpty() -&gt; NoFavorites\n      else -&gt;\n        Results(favorites) { event -&gt;\n          when (event) {\n            is ClickFavorite -&gt; navigator.goTo(FavoriteScreen(event.id))\n          }\n        }\n    }\n  }\n}\n\n@Composable\nfun FavoritesList(state: FavoritesScreen.State) {\n  when (state) {\n    Loading -&gt; Text(text = stringResource(R.string.loading_favorites))\n    NoFavorites -&gt; Text(\n      modifier = Modifier.testTag(\"no favorites\"),\n      text = stringResource(R.string.no_favorites)\n    )\n    is Results -&gt; {\n      Text(text = \"Your Favorites\")\n      LazyColumn {\n        items(state.list) { Favorite(it, state.eventSink) }\n      }\n    }\n  }\n}\n\n@Composable\nprivate fun Favorite(favorite: Favorite, eventSink: (FavoritesScreen.Event) -&gt; Unit) {\n  Row(\n    modifier = Modifier.testTag(\"favorite\"),\n    onClick = { eventSink(ClickFavorite(favorite.id)) }\n  ) {\n    Image(\n      drawable = favorite.drawable, \n      contentDescription = stringResource(R.string.favorite_image_desc)\n    )\n    Text(text = favorite.name)\n    Text(text = favorite.date)\n  }\n}\n</code></pre>"},{"location":"testing/#presenter-unit-tests","title":"Presenter Unit Tests","text":"<p>Here\u2019s a test to verify presenter emissions using the <code>Presenter.test()</code> helper. This function acts as a shorthand over Molecule + Turbine to give you a <code>ReceiveTurbine.() -&gt; Unit</code> lambda.</p> <pre><code>@Test \nfun `present - emit loading state then list of favorites`() = runTest {\n  val favorites = listOf(Favorite(1L, ...))\n\n  val repo = TestFavoritesRepository(favorites)\n  val presenter = FavoritesPresenter(navigator, repo)\n\n  presenter.test {\n    assertThat(awaitItem()).isEqualTo(FavoritesScreen.State.Loading)\n    val resultsItem = awaitItem() as Results\n    assertThat(resultsItem.favorites).isEqualTo(favorites)\n  }\n}\n</code></pre> <p>The same helper can be used when testing how the presenter responds to incoming events: </p> <pre><code>@Test \nfun `present - navigate to favorite screen`() = runTest {\n  val repo = TestFavoritesRepository(Favorite(123L))\n  val presenter = FavoritesPresenter(navigator, repo)\n\n  presenter.test {\n    assertThat(awaitItem()).isEqualTo(FavoritesScreen.State.Loading)\n    val resultsItem = awaitItem() as Results\n    assertThat(resultsItem.favorites).isEqualTo(favorites)\n    val clickFavorite = FavoriteScreen.Event.ClickFavorite(123L)\n\n    // simulate user tapping favorite in UI\n    resultsItem.eventSink(clickFavorite)\n\n    assertThat(navigator.awaitNextScreen()).isEqualTo(FavoriteScreen(clickFavorite.id))\n  }\n}\n</code></pre>"},{"location":"testing/#android-ui-instrumentation-tests","title":"Android UI Instrumentation Tests","text":"<p>UI tests can be driven directly through <code>ComposeTestRule</code> and use its Espresso-esque API for assertions:</p> <p>Here is also a good place to use a <code>TestEventSink</code> and assert expected event emissions from specific UI interactions.</p> <pre><code>@Test\nfun favoritesList_show_favorites_for_result_state() = runTest {\n  val favorites = listOf(Favorite(1L, ...))\n  val events = TestEventSink&lt;FavoriteScreen.Event&gt;()\n\n  composeTestRule.run {\n    setContent { \n      // bootstrap the UI in the desired state\n      FavoritesList(\n        state = FavoriteScreen.State.Results(favorites, events)\n      )\n    }\n\n    onNodeWithTag(\"no favorites\").assertDoesNotExist()\n    onNodeWithText(\"Your Favorites\").assertIsDisplayed()\n    onAllNodesWithTag(\"favorite\").assertCountEquals(1)\n      .get(1)\n      .performClick()\n\n    events.assertEvent(FavoriteScreen.Event.ClickFavorite(1L))\n  }\n}\n</code></pre>"},{"location":"testing/#snapshot-tests","title":"Snapshot Tests","text":"<p>Because Circuit UIs simply take an input state parameter, snapshot tests via Paparazzi or Roborazzi are a breeze.</p> <p>This allows allows you to render UI without a physical device or emulator and assert pixel-perfection on the result.</p> <pre><code>@Test\nfun previewFavorite() {\n  paparazzi.snapshot { PreviewFavorite() }\n}\n</code></pre> <p>These are easy to maintain and review in GitHub.</p> <p>Another neat idea is we think this will make it easy to stand up compose preview functions for IDE use and reuse them.</p> <pre><code>// In your main source\n@Preview\n@Composable\ninternal fun PreviewFavorite() {\n  Favorite()\n}\n\n// In your unit test\n@Test\nfun previewFavorite() {\n  paparazzi.snapshot { PreviewFavorite() }\n}\n</code></pre>"},{"location":"ui/","title":"UI","text":"<p>The core Ui interface is simply this:</p> <pre><code>interface Ui&lt;UiState : CircuitUiState&gt; {\n  @Composable fun Content(state: UiState, modifier: Modifier)\n}\n</code></pre> <p>Like presenters, simple UIs can also skip the class all together for use in other UIs. Core unit of granularity is just the @Composable function. In fact, when implementing these in practice they rarely use dependency injection at all and can normally just be written as top-level composable functions annotated with<code>@CircuitInject</code>.</p> <pre><code>@CircuitInject&lt;FavoritesScreen&gt; // Relevant DI wiring is generated\n@Composable\nprivate fun Favorites(state: FavoritesState, modifier: Modifier = Modifier) {\n  // ...\n}\n</code></pre> <p>Writing UIs like this has a number of benefits.</p> <ul> <li>Functions-only nudges developers toward writing idiomatic compose code and not keeping un-scoped/un-observable state elsewhere (such as class properties).</li> <li>These functions are extremely easy to stand up in tests.</li> <li>These functions are extremely easy to stand up in Compose preview functions.</li> </ul> <p>Let\u2019s look a little more closely at the last bullet point about preview functions. With the above example, we can easily stand up previews for all of our different states!</p> <pre><code>@Preview\n@Composable\nprivate fun PreviewFavorites() = Favorites(FavoritesState(listOf(\"Reeses\", \"Lola\")))\n\n@Preview\n@Composable\nprivate fun PreviewEmptyFavorites() = Favorites(FavoritesState(listOf()))\n</code></pre>"}]}