{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\u26a1\ufe0f Circuit","text":"<p>\ud83d\udea7 Under construction \ud83d\udea7</p> <p>This project is very much a work in progress and far from finished!</p>"},{"location":"#overview","title":"Overview","text":"<p>Circuit is a simple, lightweight, and extensible framework for building Kotlin applications that\u2019s Compose from the ground up.</p> <p>Compose Runtime vs. Compose UI</p> <p>Compose itself is essentially two libraries \u2013 Compose Compiler and Compose UI. Most folks usually think of Compose UI, but the compiler (and associated runtime) are actually not specific to UI at all and offer powerful state management APIs.</p> <p>Jake Wharton has an excellent post about this: https://jakewharton.com/a-jetpack-compose-by-any-other-name/</p> <p>It builds upon core principles we already know like Presenters and UDF, and adds native support in its framework for all the other requirements we set out for above. It\u2019s heavily influenced by Cash App\u2019s Broadway architecture (talked about at Droidcon NYC, also very derived from our conversations with them).</p> <p>Circuit\u2019s core components are its <code>Presenter</code> and <code>Ui</code> interfaces.</p> <ol> <li>A <code>Presenter</code> and a <code>Ui</code> cannot directly access each other. They can only communicate through state and event emissions.</li> <li>UIs are compose-first.</li> <li>Presenters are also compose-first. They do not emit Compose UI, but they do use the Compose runtime to manage and emit state.</li> <li>Both <code>Presenter</code> and <code>Ui</code> each have a single composable function.</li> <li>In most cases, Circuit automatically connects presenters and UIs.</li> <li><code>Presenter</code> and <code>Ui</code> are both generic types, with generics to define the <code>UiState</code> types they communicate with.</li> <li>They are keyed by <code>Screen</code>s. One runs a new <code>Presenter</code>/<code>Ui</code> pairing by requesting them with a given <code>Screen</code> that they understand.</li> </ol> <p>Circuits</p> <p>The pairing of a <code>Presenter</code> and <code>Ui</code> for a given <code>Screen</code> key is what we semantically call a \u201ccircuit\u201d.</p> <ul> <li>Your application is composed of \u201ccircuits\u201d.</li> <li>A simple counter <code>Presenter</code> + <code>Ui</code> pairing would be a \u201ccounter circuit\u201d.</li> <li>Nested presenter/UIs would be \u201cnested circuits\u201d or \u201csub circuits\u201d</li> <li>Composite presenter/UIs would be \u201ccomposite circuits\u201d</li> <li>etc etc.</li> </ul> <p>Circuit\u2019s repo (https://github.com/slackhq/circuit) is being actively developed in the open, which allows us to continue collaborating with external folks too. We have a trivial-but-not-too-trivial sample app that we have been developing in it to serve as a demo for a number of common patterns in Circuit use.</p>"},{"location":"#counter-example","title":"Counter Example","text":"<p>This is a very simple case of a Counter circuit that displays the count and has buttons to increment and decrement.</p> <p></p> <p>There\u2019s some glue code missing from this example that\u2019s covered in the Code Gen (TODO link) section later.</p> <pre><code>@Parcelize\nobject CounterScreen : Screen {\ndata class CounterState(\nval count: Int,\nval eventSink: (CounterEvent) -&gt; Unit,\n) : CircuitUiState\nsealed interface CounterEvent : CircuitUiEvent {\nobject Increment : CounterEvent\nobject Decrement : CounterEvent\n}\n}\n\n@CircuitInject(CounterScreen::class, AppScope::class)\n@Composable\nfun CounterPresenter(): CounterState {\nvar count by rememberSaveable { mutableStateOf(0) }\n\nreturn CounterState(count) { event -&gt;\nwhen (event) {\nis CounterEvent.Increment -&gt; count++\nis CounterEvent.Decrement -&gt; count--\n}\n}\n}\n\n@CircuitInject(CounterScreen::class, AppScope::class)\n@Composable\nfun Counter(state: CounterState) {\nBox(Modifier.fillMaxSize()) {\nColumn(Modifier.align(Alignment.Center)) {\nText(\nmodifier = Modifier.align(CenterHorizontally),\ntext = \"Count: ${state.count}\",\nstyle = MaterialTheme.typography.displayLarge\n)\nSpacer(modifier = Modifier.height(16.dp))\nval eventSink = state.eventSink\nButton(\nmodifier = Modifier.align(CenterHorizontally),\nonClick = { eventSink(CounterEvent.Increment) }\n) { Icon(rememberVectorPainter(Icons.Filled.Add), \"Increment\") }\nButton(\nmodifier = Modifier.align(CenterHorizontally),\nonClick = { eventSink(CounterEvent.Decrement) }\n) { Icon(rememberVectorPainter(Icons.Filled.Remove), \"Decrement\") }\n}\n}\n}\n</code></pre>"},{"location":"#license","title":"License","text":"<pre><code>Copyright 2022 Slack Technologies, LLC\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#080","title":"0.8.0","text":"<p>2023-04-06</p>"},{"location":"changelog/#core-split-up-core-artifacts","title":"[Core] Split up core artifacts.","text":"<ul> <li><code>circuit-runtime</code>: common runtime components like <code>Screen</code>, <code>Navigator</code>, etc.</li> <li><code>circuit-runtime-presenter</code>: the <code>Presenter</code> API, depends on <code>circuit-runtime</code>.</li> <li><code>circuit-runtime-ui</code>: the <code>Ui</code> API, depends on <code>circuit-runtime</code>.</li> <li><code>circuit-foundation</code>: the circuit foundational APIs like <code>CircuitConfig</code>, <code>CircuitContent</code>, etc. Depends on the first three.</li> </ul> <p>The goal in this is to allow more granular dependencies and easier building against subsets of the API. For example, this would allow a presenter implementation to easily live in a standalone module that doesn\u2019t depend on any UI dependencies. Vice versa for UI implementations.</p> <p>Where we think this could really shine is in multiplatform projects where Circuit\u2019s UI APIs may be more or less abstracted away in service of using native UI, like in iOS.</p>"},{"location":"changelog/#circuit-runtime-artifact","title":"<code>circuit-runtime</code> artifact","text":"Before After com.slack.circuit.CircuitContext com.slack.circuit.runtime.CircuitContext com.slack.circuit.CircuitUiState com.slack.circuit.runtime.CircuitUiState com.slack.circuit.CircuitUiEvent com.slack.circuit.runtime.CircuitUiEvent com.slack.circuit.Navigator com.slack.circuit.runtime.Navigator com.slack.circuit.Screen com.slack.circuit.runtime.Screen"},{"location":"changelog/#circuit-runtime-presenter-artifact","title":"<code>circuit-runtime-presenter</code> artifact","text":"Before After com.slack.circuit.Presenter com.slack.circuit.runtime.presenter.Presenter"},{"location":"changelog/#circuit-runtime-ui-artifact","title":"<code>circuit-runtime-ui</code> artifact","text":"Before After com.slack.circuit.Ui com.slack.circuit.runtime.presenter.Ui"},{"location":"changelog/#circuit-foundation-artifact","title":"<code>circuit-foundation</code> artifact","text":"Before After com.slack.circuit.CircuitCompositionLocals com.slack.circuit.foundation.CircuitCompositionLocals com.slack.circuit.CircuitConfig com.slack.circuit.foundation.CircuitConfig com.slack.circuit.CircuitContent com.slack.circuit.foundation.CircuitContent com.slack.circuit.EventListener com.slack.circuit.foundation.EventListener com.slack.circuit.NavEvent com.slack.circuit.foundation.NavEvent com.slack.circuit.onNavEvent com.slack.circuit.foundation.onNavEvent com.slack.circuit.NavigableCircuitContent com.slack.circuit.foundation.NavigableCircuitContent com.slack.circuit.NavigatorDefaults com.slack.circuit.foundation.NavigatorDefaults com.slack.circuit.rememberCircuitNavigator com.slack.circuit.foundation.rememberCircuitNavigator com.slack.circuit.push com.slack.circuit.foundation.push com.slack.circuit.screen com.slack.circuit.foundation.screen"},{"location":"changelog/#more-highlights","title":"More Highlights","text":"<ul> <li>[Core] Remove Android-specific <code>NavigableCircuitContent</code> and just use common one. Back handling still runs through <code>BackHandler</code>, but is now configured in <code>rememberCircuitNavigator</code>.</li> <li>[Core] Add <code>defaultNavDecoration</code> to <code>CircuitConfig</code> to allow for customizing the default <code>NavDecoration</code> used in <code>NavigableCircuitContent</code>.</li> <li>[Core] Mark <code>CircuitUiState</code> as <code>@Stable</code> instead of <code>@Immutable</code>.</li> <li>[Code gen] Capitalize generated class names when source is a presenter function.</li> <li>[Sample] New <code>:samples:tacos</code> order builder sample to demonstrate complex state management.</li> <li>[Sample] <code>NavigableCircuitContent</code> example in the desktop counter.</li> <li>[Dependencies] Update compose to <code>1.4.1</code>.</li> <li>[Dependencies] Update compose-compiler to <code>1.4.4</code>.</li> <li>[Dependencies] Update androidx.activity to <code>1.7.0</code>.</li> <li>[Dependencies] Update molecule to <code>0.7.1</code>.</li> </ul>"},{"location":"changelog/#070","title":"0.7.0","text":"<p>2023-02-10</p> <ul> <li>New: Multiplatform support for <code>NavigableCircuitContent</code>! Special thanks to @ashdavies for contributions to make this possible.</li> <li>Fix: <code>circuit-retained</code> minSdk is now 21 again. We accidentally bumped it to 28 when merging in its instrumentation tests.</li> <li>Enhancement: embedded baseline profiles are now embedded per-artifact instead of in the root <code>circuit-core</code> artifact.</li> <li>Enhancement: <code>circuit-retained</code> is now covered in embedded baseline profiles.</li> <li>[Code Gen] Update Dagger to <code>2.45</code>.</li> <li>[Code Gen] Update KSP to <code>1.8.10-1.0.9</code>.</li> <li>Update to compose-compiler <code>1.4.2</code>.</li> <li>Update to Kotlin <code>1.8.10</code>.</li> </ul>"},{"location":"changelog/#060","title":"0.6.0","text":"<p>2023-02-02</p> <p>Happy groundhog day!</p> <ul> <li>Breaking API change: <code>Ui.Content()</code> now contains a <code>Modifier</code> parameter.</li> </ul> <p>This allows you to pass modifiers on to UIs directly.</p> <pre><code> public interface Ui&lt;UiState : CircuitUiState&gt; {\n-  @Composable public fun Content(state: UiState)\n+  @Composable public fun Content(state: UiState, modifier: Modifier)\n}\n</code></pre> <ul> <li>New: Add <code>Navigator.resetRoot(Screen)</code> function to reset the backstack root with a new root screen. There is a corresponding <code>awaitResetRoot()</code> function added to <code>FakeNavigator</code>.</li> <li>New: Add <code>EventListener.start</code> callback function.</li> <li>New: Add Compose UI dependency to circuit-core (to support <code>Modifier</code> in the API).</li> <li>Fix: Fix <code>CircuitContext.putTag</code> generics.</li> <li>Fix: Fix KSP code gen artifact to just be a pure JVM artifact.</li> <li>Fix: <code>EventListener.onState</code>\u2018s type is now <code>CircuitUiState</code> instead of <code>Any</code>.</li> <li>Removed: <code>ScreenUi</code> is now removed and <code>Ui.Factory</code> simply returns <code>Ui</code> instances now.</li> <li> <p>API Change: <code>CircuitConfig.onUnavailableContent</code> is now no longer nullable. By default it displays a big ugly error text. If you want the previous behavior of erroring, replace it with a composable function that just throws an exception.</p> </li> <li> <p>Dependency updates <pre><code>Kotlin 1.8.0\nCompose-JB 1.3.0\nKSP 1.8.0-1.0.9\nCompose Runtime 1.3.3\nCompose UI 1.3.3\nCompose Animation 1.3.3\n</code></pre></p> </li> </ul>"},{"location":"changelog/#050","title":"0.5.0","text":"<p>2022-12-22</p> <ul> <li>Enhancement: Circuit no longer requires manual provisioning of its internal backing <code>ViewModel</code>s. This is now done automatically by the Circuit itself.</li> <li>Enhancement: <code>circuit-retained</code> is now fully optional and not included as a transitive dependency of circuit-core. If you want to use it, see its installation instructions in its README.</li> <li>Enhancement: Mark <code>Screen</code> as <code>@Immutable</code>.</li> <li>Breaking API Change: <code>LocalCircuitOwner</code> is now just <code>LocalCircuitConfig</code> to be more idiomatic.</li> <li>Breaking API Change: <code>LocalRetainedStateRegistryOwner</code> is now just <code>LocalRetainedStateRegistry</code> to be more idiomatic.</li> <li>Breaking API Change: <code>Continuity</code> is now <code>internal</code> and not publicly exposed since it no longer needs to be manually provided.</li> <li>Breaking API Change: <code>ViewModelBackStackRecordLocalProvider</code> is now <code>internal</code> and not publicly exposed since it no longer needs to be manually provided.</li> <li>Fix: Add missing license info to pom.</li> <li>Dependency updates   <pre><code>[versions]\nanvil = \"2.4.3\"\ncompose-jb = \"1.2.2\"\ncompose-animation = \"1.3.2\"\ncompose-compiler = \"1.3.2\"\ncompose-foundation = \"1.3.1\"\ncompose-material = \"1.3.1\"\ncompose-material3 = \"1.0.1\"\ncompose-runtime = \"1.3.2\"\ncompose-ui = \"1.3.2\"\nkotlin = \"1.7.22\"\n</code></pre></li> </ul>"},{"location":"changelog/#040","title":"0.4.0","text":"<p>2022-12-07</p> <ul> <li>Breaking API Change: <code>Presenter</code> and <code>Ui</code> factories\u2019 <code>create()</code> functions now offer a <code>CircuitContext</code> parameter in place of a <code>CircuitConfig</code> parameter. This class contains a <code>CircuitConfig</code>, a tagging API, and access to parent contexts. This allows for plumbing your own metadata through Circuit\u2019s internals such as tracing tools, logging, etc.</li> <li>Enhancement: New lifecycle functions added to <code>EventListener</code>.</li> <li><code>onBeforeCreatePresenter</code></li> <li><code>onAfterCreatePresenter</code></li> <li><code>onBeforeCreateUi</code></li> <li><code>onAfterCreateUi</code></li> <li><code>onUnavailableContent</code></li> <li><code>onStartPresent</code></li> <li><code>onDisposePresent</code></li> <li><code>onStartContent</code></li> <li><code>onDisposeContent</code></li> <li><code>dispose</code></li> <li>Update Compose to <code>1.3.1</code>.</li> <li>Update Compose (JB) to <code>1.2.1</code>.</li> <li>Update Molecule to <code>0.6.1</code>.</li> <li>Added a demo to the STAR sample that shows how to navigate to standard Android components (#275).</li> </ul>"},{"location":"changelog/#031","title":"0.3.1","text":"<p>2022-11-07</p> <ul> <li>Enhancement: Add back the <code>onRootPop()</code> parameter in <code>rememberCircuitNavigator()</code> but use <code>LocalOnBackPressedDispatcherOwner</code> for backpress handling by default.</li> </ul>"},{"location":"changelog/#030","title":"0.3.0","text":"<p>2022-11-01</p> <ul> <li>New: The Overlay API is now extracted to a separate, optional <code>circuit-overlay</code> artifact.</li> <li>New: The <code>circuit-core</code> artifact now packages in baseline profiles.</li> <li>Enhancement: Simplify backstack root pop handling. There is no more <code>onRootPop()</code> option in <code>rememberCircuitNavigator()</code>, instead you should install your own <code>BackHandler()</code> prior to rendering your circuit content to customize back behavior when the circuit <code>Navigator</code> is at root.</li> <li>Fix: <code>circuit-codegen-annotations</code> is now a multiplatform project and doesn\u2019t accidentally impose the compose-desktop dependency.</li> </ul> <p>We\u2019ve also updated a number of docs around code gen, overlays, and interop (including a new interop sample).</p>"},{"location":"changelog/#022","title":"0.2.2","text":"<p>2022-10-27</p> <ul> <li>Enhancement: Code gen now supports non-assisted constructor-injected types.</li> <li>Enhancement: Code gen checks that functions and classes are visible to generated factories.</li> </ul>"},{"location":"changelog/#021","title":"0.2.1","text":"<p>2022-10-27</p> <ul> <li>Fix: Code gen didn\u2019t properly handle instantiating simple class types.</li> </ul>"},{"location":"changelog/#020","title":"0.2.0","text":"<p>2022-10-26</p> <ul> <li> <p>New: Code gen artifact. This targets specifically using Dagger + Anvil and will generate <code>Presenter</code> and <code>Ui.Factory</code> implementations for you. See <code>CircuitInject</code> for more details.   <pre><code>ksp(\"com.slack.circuit:circuit-codegen:x.y.z\")\nimplementation(\"com.slack.circuit:circuit-codegen-annotations:x.y.z\")\n</code></pre></p> </li> <li> <p>New: There is now an <code>EventListener</code> API for instrumenting state changes for a given <code>Screen</code>. See its docs for more details.</p> </li> <li>Fix: Rework <code>rememberRetained</code> implementation and support for multiple variables. Previously it only worked with one variable.</li> <li>Fix: Clean up some unnecessary transitive dependencies in misc artifacts.</li> </ul> <p>Dependency updates</p> <pre><code>androidx.activity 1.6.1\nandroidx.compose 1.3.0\nMolecule 0.5.0\n</code></pre>"},{"location":"changelog/#012","title":"0.1.2","text":"<p>2022-10-12</p> <ul> <li>Update to compose-jb <code>1.2.0</code>.</li> <li>Update to Turbine <code>0.12.0</code>.</li> <li>Fix: Accidentally running molecule twice in <code>Presenter.test()</code>.</li> </ul>"},{"location":"changelog/#011","title":"0.1.1","text":"<p>2022-10-10</p> <ul> <li>Fix: Accidentally bundling more Compose UI dependencies than necessary.</li> </ul>"},{"location":"changelog/#010","title":"0.1.0","text":"<p>2022-10-10</p> <p>Initial release, see the docs: https://slackhq.github.io/circuit/.</p> <p>Note that this library is still under active development and not recommended for production use. We\u2019ll do a more formal announcement when that time comes!</p>"},{"location":"circuit-content/","title":"CircuitContent","text":"<p>The simplest entry point of a circuit is the composable <code>CircuitContent</code> function. This function accepts a <code>Screen</code> and automatically finds and pairs corresponding <code>Presenter</code> and <code>Ui</code> instances to render in it.</p> <pre><code>setContent {\nCircuitContent(HomeScreen)\n}\n</code></pre>"},{"location":"code-gen/","title":"Code Generation","text":"<p>If using Dagger and Anvil, Circuit offers a KSP-based code gen solution to ease boilerplate around generating factories.</p>"},{"location":"code-gen/#installation","title":"Installation","text":"<pre><code>plugins {\nid(\"com.google.devtools.ksp\")\n}\n\ndependencies {\napi(\"com.slack.circuit:circuit-codegen-annotations:&lt;version&gt;\")\nksp(\"com.slack.circuit:circuit-codegen:&lt;version&gt;\")\n}\n</code></pre>"},{"location":"code-gen/#usage","title":"Usage","text":"<p>The primary entry point is the <code>CircuitInject</code> annotation.</p> <p>This annotation is used to mark a UI or presenter class or function for code generation. When annotated, the type\u2019s corresponding factory will be generated and keyed with the defined <code>screen</code>.</p> <p>The generated factories are then contributed to Anvil via <code>ContributesMultibinding</code> and scoped with the provided <code>scope</code> key.</p>"},{"location":"code-gen/#classes","title":"Classes","text":"<p><code>Presenter</code> and <code>Ui</code> classes can be annotated and have their corresponding <code>Presenter.Factory</code> or <code>Ui.Factory</code> classes generated for them.</p> <p>Presenter <pre><code>@CircuitInject(HomeScreen::class, AppScope::class)\nclass HomePresenter @Inject constructor(...) : Presenter&lt;HomeState&gt; { ... }\n\n// Generates\n@ContributesMultibinding(AppScope::class)\nclass HomePresenterFactory @Inject constructor() : Presenter.Factory { ... }\n</code></pre></p> <p>UI <pre><code>@CircuitInject(HomeScreen::class, AppScope::class)\nclass HomeUi @Inject constructor(...) : Ui&lt;HomeState&gt; { ... }\n\n// Generates\n@ContributesMultibinding(AppScope::class)\nclass HomeUiFactory @Inject constructor() : Ui.Factory { ... }\n</code></pre></p>"},{"location":"code-gen/#functions","title":"Functions","text":"<p>Simple functions can be annotated and have a corresponding <code>Presenter.Factory</code> generated. This is primarily useful for simple cases where a class is just technical tedium.</p> <p>Requirements - Presenter function names must end in <code>Presenter</code>, otherwise they will be treated as UI functions. - Presenter functions must return a <code>CircuitUiState</code> type. - UI functions can optionally accept a <code>CircuitUiState</code> type as a parameter, but it is not required. - UI functions must return <code>Unit</code>. - Both presenter and UI functions must be <code>Composable</code>.</p> <p>Presenter <pre><code>@CircuitInject(HomeScreen::class, AppScope::class)\n@Composable\nfun HomePresenter(): HomeState { ... }\n\n// Generates\n@ContributesMultibinding(AppScope::class)\nclass HomePresenterFactory @Inject constructor() : Presenter.Factory { ... }\n</code></pre></p> <p>UI <pre><code>@CircuitInject(HomeScreen::class, AppScope::class)\n@Composable\nfun Home(state: HomeState) { ... }\n*\n// Generates\n@ContributesMultibinding(AppScope::class)\nclass HomeUiFactory @Inject constructor() : Ui.Factory { ... }\n</code></pre></p>"},{"location":"code-gen/#assisted-injection","title":"Assisted injection","text":"<p>Any type that is offered in <code>Presenter.Factory</code> and <code>Ui.Factory</code> can be offered as an assisted injection to types using Dagger <code>AssistedInject</code>. For these cases, the <code>AssistedFactory</code> -annotated interface should be annotated with <code>CircuitInject</code> instead of the enclosing class.</p> <p>Types available for assisted injection are: - <code>Screen</code> \u2013 the screen key used to create the <code>Presenter</code> or <code>Ui</code>. - <code>Navigator</code> \u2013 (presenters only) - <code>CircuitConfig</code></p> <p>Each should only be defined at-most once.</p> <p>Examples <pre><code>// Function example\n@CircuitInject(HomeScreen::class, AppScope::class)\n@Composable\nfun HomePresenter(screen: Screen, navigator: Navigator): HomeState { ... }\n\n// Class example\nclass HomePresenter @AssistedInject constructor(\n@Assisted screen: Screen,\n@Assisted navigator: Navigator,\n...\n) : Presenter&lt;HomeState&gt; {\n// ...\n@CircuitInject(HomeScreen::class, AppScope::class)\n@AssistedFactory\nfun interface Factory {\nfun create(screen: Screen, navigator: Navigator, context: CircuitContext): HomePresenter\n}\n}\n</code></pre></p>"},{"location":"code-of-conduct/","title":"Code of Conduct","text":""},{"location":"code-of-conduct/#introduction","title":"Introduction","text":"<p>Diversity and inclusion make our community strong. We encourage participation from the most varied and diverse backgrounds possible and want to be very clear about where we stand.</p> <p>Our goal is to maintain a safe, helpful and friendly community for everyone, regardless of experience, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, nationality, or other defining characteristic.</p> <p>This code and related procedures also apply to unacceptable behavior occurring outside the scope of community activities, in all community venues (online and in-person) as well as in all one-on-one communications, and anywhere such behavior has the potential to adversely affect the safety and well-being of community members.</p> <p>For more information on our code of conduct, please visit https://slackhq.github.io/code-of-conduct</p>"},{"location":"contributing/","title":"Contributors Guide","text":"<p>Note that this project is considered READ-ONLY. You are welcome to discuss or ask questions in the discussions section of the repo, but we do not normally accept external contributions without prior discussion.</p>"},{"location":"contributing/#development","title":"Development","text":"<p>Check out this repo with Android Studio. It\u2019s a standard gradle project and conventional to checkout.</p> <p>The primary project is <code>circuit</code>. The primary sample is <code>samples/star</code>.</p> <p>This project is written in Kotlin and should only use Kotlin.</p> <p>Code formatting is checked via Spotless. To run the formatter, use the <code>spotlessApply</code> command.</p> <pre><code>./gradlew spotlessApply\n</code></pre>"},{"location":"factories/","title":"Factories","text":"<p>At its core, Circuit works on the Factory pattern. Every <code>Presenter</code> and <code>Ui</code> is contributed to a <code>CircuitConfig</code> instance by a corresponding factory that creates them for given <code>Screen</code>s. These are intended to be aggregated in the DI layer and added to a <code>CircuitConfig</code> instance during construction.</p> <pre><code>val circuitConfig = CircuitConfig.Builder()\n.addUiFactory(FavoritesUiFactory())\n.addPresenterFactory(FavoritesPresenterFactory())\n.build()\n</code></pre> <p>Look familiar?</p> <p>If you\u2019ve used Moshi or Retrofit, these should feel fairly familiar!</p> <p>Presenter factories can be generated or hand-written, depending on if they aggregate an entire screen or are simple one-offs. Presenters are also given access to the current Navigator in this level.</p> <pre><code>class FavoritesScreenPresenterFactory @Inject constructor(\nprivate val favoritesPresenterFactory: FavoritesPresenter.Factory,\n) : Presenter.Factory {\noverride fun create(screen: Screen, navigator: Navigator, context: CircuitContext): Presenter&lt;*&gt;? {\nreturn when (screen) {\nis FavoritesScreen -&gt; favoritesPresenterFactory.create(screen, navigator, context)\nelse -&gt; null\n}\n}\n}\n</code></pre> <p>UI factories are similar, but generally should not aggregate other UIs unless there\u2019s a DI-specific reason to do so (which there usually isn\u2019t!).</p> <pre><code>class FavoritesScreenUiFactory @Inject constructor() : Ui.Factory {\noverride fun create(screen: Screen, context: CircuitContext): Ui&lt;*&gt;? {\nreturn when (screen) {\nis FavoritesScreen -&gt; favoritesUi()\nelse -&gt; null\n}\n}\n}\n\nprivate fun favoritesUi() = ui&lt;State&gt; { state, modifier -&gt; Favorites(state, modifier) }\n</code></pre> <p>Info</p> <p>Note how these include a <code>Modifier</code>. You should pass on these modifiers to your UI. Always provide a modifier!</p> <p>We canonically write these out as a separate function (<code>favoritesUi()</code>) that returns a <code>Ui</code>, which in turn calls through to the real (basic) Compose UI function (<code>Favorites()</code>). This ensures our basic compose functions are top-level and accessible by tests, and also discourages storing anything in class members rather than idiomatic composable state vars. If you use code gen, it handles the intermediate function for you.</p>"},{"location":"interop/","title":"Interop","text":"<p>Circuit can interop anywhere that Compose can interop. This includes common cases like Android  <code>Views</code>, RxJava, Kotlin <code>Flow</code>, and more.</p>"},{"location":"interop/#presenter","title":"<code>Presenter</code>","text":"<p>Lean on first-party interop-APIs where possible! See examples of interop with different libraries in the <code>:samples:interop</code> project.</p>"},{"location":"interop/#ui","title":"<code>UI</code>","text":""},{"location":"interop/#ui-view","title":"<code>Ui</code> -&gt; <code>View</code>","text":"<p>Just embed the Circuit in a <code>ComposeView</code> like any other Compose UI.</p>"},{"location":"interop/#view-ui","title":"<code>View</code> -&gt; <code>Ui</code>","text":"<p>You can wrap your view in an <code>AndroidView</code> in a custom <code>Ui</code> implementation. </p> <pre><code>class ExistingCustomViewUi : Ui&lt;State&gt; {\n@Composable\nfun Content(state: State, modifier: Modifier = Modifier) {\nAndroidView(\nmodifier = ...\nfactory = { context -&gt;\nExistingCustomView(context)\n},\nupdate = { view -&gt;\nview.setState(state)\nview.setOnClickListener { state.eventSink(Event.Click) }\n}\n}\n}\n</code></pre>"},{"location":"navigation/","title":"Navigation","text":"<p>For navigable contents, we have a custom compose-based backstack implementation that the androidx folks shared with us. Navigation becomes two parts:</p> <ol> <li>A <code>BackStack</code>, where we use a <code>SaveableBackStack</code> implementation that saves a stack of <code>Screen</code>s and the <code>ProvidedValues</code> for each record on that stack (allowing us to save and restore on configuration changes automatically).</li> <li>A <code>Navigator</code>, which is a simple interface that we can point at a <code>BackStack</code> and offers simple <code>goTo(&lt;screen&gt;)</code>/<code>pop()</code> semantics. These are offered to presenters to perform navigation as needed to other screens.</li> </ol> <p>A new navigable content surface is handled via the <code>NavigableCircuitContent</code> functions.</p> <pre><code>setContent {\nval backstack = rememberSaveableBackStack { push(HomeScreen) }\nval navigator = rememberCircuitNavigator(backstack)\nNavigableCircuitContent(navigator, backstack)\n}\n</code></pre> <p>Warning</p> <p><code>SaveableBackStack</code> must have a size of 1 or more after initialization. It\u2019s an error to have a backstack with zero items.</p> <p>Presenters are then given access to these navigator instances via <code>Presenter.Factory</code> (described in Factories), which they can save if needed to perform navigation.</p> <pre><code>fun showAddFavorites() {\nnavigator.goTo(\nAddFavorites(\nexternalId = uuidGenerator.generate()\n)\n)\n}\n</code></pre> <p>If you want to have custom behavior for when back is pressed on the root screen (i.e. <code>backstack.size == 1</code>), you should implement your own <code>BackHandler</code> and use it before creating the backstack.</p> <pre><code>setContent {\nval backstack = rememberSaveableBackStack { push(HomeScreen) }\nBackHandler(onBack = { /* do something on root */ })\n// The Navigator's internal BackHandler will take precedence until it is at the root screen.\nval navigator = rememberCircuitNavigator(backstack)\nNavigableCircuitContent(navigator, backstack)\n}\n</code></pre>"},{"location":"navigation/#nested-navigation","title":"Nested Navigation","text":"<p>Navigation carries special semantic value in <code>CircuitContent</code> as well, where it\u2019s common for UIs to want to curry navigation events emitted by nested UIs. For this case, there\u2019s a <code>CircuitContent</code> overload that accepts an optional onNavEvent callback that you must then forward to a Navigator instance.</p> <pre><code>@Composable fun ParentUi(state: ParentState, modifier: Modifier = Modifier) {\nCircuitContent(NestedScreen, modifier = modifier, onNavEvent = { navEvent -&gt; state.eventSink(NestedNav(navEvent)) })\n}\n\n@Composable fun ParentPresenter(navigator: Navigator): ParentState {\nreturn ParentState(...) { event -&gt;\nwhen (event) {\nis NestedNav -&gt; navigator.onNavEvent(event.navEvent)\n}\n}\n}\n\n@Composable fun NestedPresenter(navigator: Navigator): NestedState {\n// These are forwarded up!\nnavigator.goTo(AnotherScreen)\n\n// ...\n}\n</code></pre>"},{"location":"overlays/","title":"Overlays","text":"<p>The <code>circuit-overlay</code> artifact contains an optional API for presenting overlays on top of the current UI.</p>"},{"location":"overlays/#usage","title":"Usage","text":"<p>The core APIs are the <code>Overlay</code> and <code>OverlayHost</code> interfaces.</p>"},{"location":"overlays/#overlay","title":"Overlay","text":"<p>An <code>Overlay</code> is composable content that can be shown on top of other content via an <code>OverlayHost</code>. Overlays are typically used for one-off request/result flows and should not usually attempt to do any sort of external navigation or make any assumptions about the state of the app. They should only emit a <code>Result</code> to the given <code>OverlayNavigator</code> parameter when they are done.</p> <pre><code>interface Overlay&lt;Result : Any&gt; {\n@Composable\nfun Content(navigator: OverlayNavigator&lt;Result&gt;)\n}\n</code></pre> <p>For common overlays, it\u2019s useful to create a common <code>Overlay</code> subtype that can be reused. For example: <code>BottomSheetOverlay</code>, <code>ModalOverlay</code>, <code>TooltipOverlay</code>, etc.</p>"},{"location":"overlays/#overlayhost","title":"OverlayHost","text":"<p>An <code>OverlayHost</code> is provided via composition local and exposes a <code>suspend show()</code> function to show an overlay and resume with a typed <code>Result</code>.</p> <pre><code>val result = LocalOverlayHost.current.show(BottomSheetOverlay(...))\n</code></pre> <p>Where <code>BottomSheetOverlay</code> is a custom bottom sheet implementation of an <code>Overlay</code>.</p>"},{"location":"overlays/#installation","title":"Installation","text":"<p>Add the dependency.</p> <pre><code>implementation(\"com.slack.circuit:circuit-overlay:$circuit_version\")\n</code></pre> <p>The simplest starting point for adding overlay support is the <code>ContentWithOverlays</code> composable function.</p> <pre><code>ContentWithOverlays {\n// Your content here\n}\n</code></pre> <p>This will expose a <code>LocalOverlayHost</code> composition local that can be used by UIs to show overlays.</p>"},{"location":"presenter/","title":"Presenter","text":"<p>The core Presenter interface is this:</p> <pre><code>interface Presenter&lt;UiState : CircuitUiState&gt; {\n@Composable fun present(): UiState\n}\n</code></pre> <p>Presenters are solely intended to be business logic for your UI and a translation layer in front of your data layers. They are generally Dagger-injected types as the data layers they interpret are usually coming from the DI graph. In simple cases, they can be typed as a simple <code>@Composable</code> presenter function and Circuit code gen (TODO link) can generate the corresponding interface and (TODO link) factory for you.</p> <p>A very simple presenter can look like this:</p> <pre><code>class FavoritesPresenter(...) : Presenter&lt;State&gt; {\n@Composable override fun present(): State {\nvar favorites by remember { mutableStateOf(&lt;initial&gt;) }\n\nreturn State(favorites) { event -&gt; ... }\n}\n}\n</code></pre> <p>In this example, the <code>present()</code> function simply computes a <code>state</code> and returns it. If it has UI events to handle, an <code>eventSink: (Event) -&gt; Unit</code> property should be exposed in the <code>State</code> type it returns.</p> <p>With DI, the above example becomes something more like this:</p> <pre><code>class FavoritesPresenter @AssistedInject constructor(\n@Assisted private val screen: FavoritesScreen,\n@Assisted private val navigator: Navigator,\nprivate val favoritesRepository: FavoritesRepository\n) : Presenter&lt;State&gt; {\n@Composable override fun present(): State {\n// ...\n}\n@AssistedFactory\nfun interface Factory {\nfun create(screen: FavoritesScreen, navigator: Navigator, context: CircuitContext): FavoritesPresenter\n}\n}\n</code></pre> <p>Assisted injection allows passing on the <code>screen</code> and <code>navigator</code> from the relevant <code>Presenter.Factory</code> to this presenter for further reference.</p> <p>When dealing with nested presenters, a presenter could bypass implementing a class entirely by simply being written as a function that other presenters can use. </p> <pre><code>// From cashapp/molecule's README examples\n@Composable\nfun ProfilePresenter(\nuserFlow: Flow&lt;User&gt;,\nbalanceFlow: Flow&lt;Long&gt;,\n): ProfileModel {\nval user by userFlow.collectAsState(null)\nval balance by balanceFlow.collectAsState(0L)\n\nreturn if (user == null) {\nLoading\n} else {\nData(user.name, balance)\n}\n}\n</code></pre> <p>Presenters can present other presenters by injecting their assisted factories/providers, but note that this makes them a composite presenter that is now assuming responsibility for managing state of multiple nested presenters. We have an example of this in the Circuit repo.</p>"},{"location":"presenter/#retention","title":"Retention","text":"<p>There are three types of composable retention functions used in Circuit.</p> <ol> <li><code>remember</code> \u2013 from Compose, remembers a value across recompositions. Can be any type.</li> <li><code>rememberRetained</code> \u2013 custom, remembers a value across recompositions and configuration changes. Can be any type, but should not retain leak-able things like <code>Navigator</code> instances or <code>Context</code> instances. Backed by a hidden <code>ViewModel</code> on Android. Note that this is not necessary in most cases if handling configuration changes yourself via <code>android:configChanges</code>.</li> <li><code>rememberSaveable</code> \u2013 from Compose, remembers a value across recompositions, configuration changes, and process death. Must be <code>Parcelable</code> or implement a custom <code>Saver</code>, should not retain leakable things like <code>Navigator</code> instances or <code>Context</code> instances. Backed by the framework saved instance state system.</li> </ol> <p>Developers should use the right tool accordingly depending on their use case. Consider these three examples.</p> <p>The first one will preserve the <code>count</code> value across recompositions, but not configuration changes or process death.</p> <pre><code>@Composable\nfun CounterPresenter(): CounterState {\nvar count by remember { mutableStateOf(0) }\n\nreturn CounterState(count) { event -&gt;\nwhen (event) {\nis CounterEvent.Increment -&gt; count++\nis CounterEvent.Decrement -&gt; count--\n}\n}\n}\n</code></pre> <p>The second one will preserve the state across recompositions and configuration changes, but not process death.</p> <pre><code>@Composable\nfun CounterPresenter(): CounterState {\nvar count by rememberRetained { mutableStateOf(0) }\n\nreturn CounterState(count) { event -&gt;\nwhen (event) {\nis CounterEvent.Increment -&gt; count++\nis CounterEvent.Decrement -&gt; count--\n}\n}\n}\n</code></pre> <p>The third case will preserve the <code>count</code> state across recompositions, configuration changes, and process death. However, it only works with primitives or <code>Parcelable</code> state types.</p> <pre><code>@Composable\nfun CounterPresenter(): CounterState {\nvar count by rememberSaveable { mutableStateOf(0) }\n\nreturn CounterState(count) { event -&gt;\nwhen (event) {\nis CounterEvent.Increment -&gt; count++\nis CounterEvent.Decrement -&gt; count--\n}\n}\n}\n</code></pre>"},{"location":"screen/","title":"Screen","text":"<p>Screens are keys for Presenter and UI pairings. Semantically, the pairing of a Presenter and UI for a given <code>Screen</code> key is called a circuit.</p> <p>The core <code>Screen</code> interface is this:</p> <pre><code>interface Screen : Parcelable\n</code></pre> <p>These types are <code>Parcelable</code> for saveability in our backstack and easy deeplinking. A <code>Screen</code> can be a simple marker object type or a data object with information to pass on.</p> <pre><code>@Parcelize\ndata class AddFavoritesScreen(val externalId: UUID) : Screen\n</code></pre> <p>These are used by <code>Navigator</code>s (when called from presenters) or <code>CircuitContent</code> (when called from UIs) to start a new sub-circuit or nested circuit.</p> <pre><code>// In a presenter class\nfun showAddFavorites() {\nnavigator.goTo(\nAddFavoritesScreen(\nexternalId = uuidGenerator.generate()\n)\n)\n}\n</code></pre> <p>The information passed into a screen can also be used to interact with the data layer. In the example here, we are getting the <code>externalId</code> from the screen in order to get information back from our repository. </p> <pre><code>// In a presenter class\nclass AddFavoritesPresenter\n@AssistedInject\nconstructor(\n@Assisted private val screen: AddFavoritesScreen,\nprivate val favoritesRepository: FavoritesRepository,\n) : Presenter&lt;AddFavoritesScreen.State&gt; {\n@Composable\noverride fun present() : AddFavoritesScreen.State {\nval favorite = favoritesRepository.getFavorite(screen.externalId)\n// ...\n}\n}\n</code></pre>"},{"location":"setup/","title":"Setting up Circuit","text":"<p>Setting up Circuit is a breeze! Just add the following to your build:</p>"},{"location":"setup/#installation","title":"Installation","text":"<pre><code>dependencies {\nimplementation(\"com.slack.circuit:circuit-core:&lt;version&gt;\")\n}\n</code></pre>"},{"location":"setup/#setup","title":"Setup","text":""},{"location":"setup/#android","title":"Android","text":"<p>Circuit requires two headless <code>ViewModel</code>s to be available in your application: <code>BackStackRecordLocalProviderViewModel</code> and <code>Continuity</code>. These would usually be wired up in a DI framework like Dagger, but a simple <code>ViewModelProvider.Factory</code> can be used as well.</p> <pre><code>val circuitViewModelProviderFactory = object : ViewModelProvider.Factory {\noverride fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T {\nreturn when (modelClass) {\nBackStackRecordLocalProviderViewModel::class.java -&gt; BackStackRecordLocalProviderViewModel()\nContinuity::class.java -&gt; Continuity()\nelse -&gt; ...\n} as T\n}\n}\n</code></pre>"},{"location":"setup/#jvm","title":"JVM","text":"<p>No extra configuration needed!</p>"},{"location":"setup/#platform-support","title":"Platform Support","text":"<p>Circuit is a multiplatform library, but not all features are available on all platforms. The following table shows which features are available on which platforms:</p> <ul> <li>\u2705 Available</li> <li>\u274c Not available</li> <li>\u2013 Not applicable</li> </ul> Feature Android JVM Notes <code>Backstack</code> \u2705 \u2705 <code>CircuitContent</code> \u2705 \u2705 <code>ContentWithOverlays</code> \u2705 \u2705 <code>NavigableCircuitContent</code> \u2705 \u2705 <code>Navigator</code> \u2705 \u2705 <code>SaveableBackstack</code> \u2705 \u2705 Saveable is a no-op on desktop. <code>rememberCircuitNavigator</code> \u2705 \u2705 <code>rememberRetained</code> \u2705 \u2705"},{"location":"states-and-events/","title":"States and Events","text":"<p>The core state and event interfaces in Circuit are <code>CircuitUiState</code> and <code>CircuitUiEvent</code>. All state and event types should implement/extend these marker interfaces.</p> <p>Presenters are simple functions that determine and return composable states. UIs are simple functions that render states. Uis can emit events via <code>eventSink</code> properties in state classes, which presenters then handle. These are the core building blocks!</p> <p>States and events should be immutable value types.</p> <p>Wait, event callbacks in state types?</p> <p>Yep! This may feel like a departure from how you\u2019ve written UDF patterns in the past, but we really like it. We tried different patterns before with event <code>Flow</code>s and having Circuit internals manage these for you, but we found they came with tradeoffs and friction points that we could avoid by just treating event emissions as another aspect of state. The end result is a tidier structure of state + event flows.</p> <ul> <li>Simpler cognitive overheads due to not always using <code>Flow</code> for events, which comes with caveats in compose (wrapping operators in <code>remember</code> calls, pipelining nested event flows, etc)</li> <li>Simple event-less UIs \u2013 state just doesn\u2019t have an event sink.</li> <li>Simpler testing \u2013 no manual event flow needed. You end up writing more realistic tests where you tick along your presenter by emitting with its returned states directly.</li> <li>Different state types can have different event handling (e.g. <code>Click</code> may not make sense for <code>Loading</code> states).</li> <li>No internal ceremony around setting up a <code>Channel</code> and multicasting event streams.</li> <li>No risk of dropping events (unlike <code>Flow</code>).</li> </ul> <p>Warning</p> <p>Due to this issue, you need to extract the <code>eventSink</code> into local variables first.</p> <p>Note</p> <p>Currently, while functions are treated as implicitly <code>Stable</code> by the compose compiler, they not skippable when they\u2019re non-composable Unit-returning lambdas with equal-but-unstable captures. This may change though, and would be another free benefit for this case.</p> <p>A longer-form writeup can be found in this PR.</p>"},{"location":"testing/","title":"Testing","text":"<p>Circuit is designed to make testing as easy as possible. Its core components are not mockable nor do they need to be mocked. Fakes are provided where needed, everything else can be used directly.</p> <p>Circuit will have a test artifact containing APIs to aid testing both presenters and composable UIs:</p> <ol> <li><code>Presenter.test()</code> - an extension function that bridges the Compose and coroutines world. Use of this function is recommended for testing presenter state emissions and incoming UI events. Under the hood it leverages Molecule and Turbine.</li> <li><code>FakeNavigator</code> - a test fake implementing the Circuit/Navigator interface. Use of this object is recommended when testing screen navigation (ie. goTo, pop/back).</li> </ol>"},{"location":"testing/#installation","title":"Installation","text":"<p>Test helpers are available via the <code>circuit-test</code> artifact.</p> <pre><code>testImplementation(\"com.slack.circuit:circuit-test:&lt;version&gt;\")\n</code></pre> <p>For Gradle JVM projects, you can use Gradle test fixtures syntax on the core circuit artifact.</p> <pre><code>testImplementation(testFixtures(\"com.slack.circuit:circuit:&lt;version&gt;\"))\n</code></pre>"},{"location":"testing/#example","title":"Example","text":"<p>Testing a Circuit Presenter and UI is a breeze! Consider the following example:</p> <pre><code>data class Favorite(id: Long, ...)\n\n@Parcelable\nobject FavoritesScreen : Screen {\nsealed interface State : CircuitUiState {\nobject Loading : State\nobject NoFavorites : State\ndata class Results(\nval list: List&lt;Favorite&gt;,\nval eventSink: (Event) -&gt; Unit\n) : State\n}\n\nsealed interface Event : CircuitUiEvent {\ndata class ClickFavorite(id: Long): Event\n}\n}\n\nclass FavoritesPresenter @Inject constructor(\nnavigator: Navigator,\nrepo: FavoritesRepository\n) : Presenter&lt;State&gt; {\n@Composable override fun present(): State {\nval favorites by produceState&lt;List&lt;Favorites&gt;?&gt;(null) {\nvalue = repo.getFavorites()\n}\n\nreturn when {\nfavorites == null -&gt; Loading\nfavorites.isEmpty() -&gt; NoFavorites\nelse -&gt;\nResults(favorites) { event -&gt;\nwhen (event) {\nis ClickFavorite -&gt; navigator.goTo(FavoriteScreen(event.id))\n}\n}\n}\n}\n}\n\n@Composable\nfun FavoritesList(state: FavoritesScreen.State) {\nwhen (state) {\nLoading -&gt; Text(text = stringResource(R.string.loading_favorites))\nNoFavorites -&gt; Text(\nmodifier = Modifier.testTag(\"no favorites\"),\ntext = stringResource(R.string.no_favorites)\n)\nis Results -&gt; {\nText(text = \"Your Favorites\")\nLazyColumn {\nitems(state.list) { Favorite(it, state.eventSink) }\n}\n}\n}\n}\n\n@Composable\nprivate fun Favorite(favorite: Favorite, eventSink: (FavoritesScreen.Event) -&gt; Unit) {\nRow(\nmodifier = Modifier.testTag(\"favorite\"),\nonClick = { eventSink(ClickFavorite(favorite.id)) }\n) {\nImage(\ndrawable = favorite.drawable, contentDescription = stringResource(R.string.favorite_image_desc)\n)\nText(text = favorite.name)\nText(text = favorite.date)\n}\n}\n</code></pre>"},{"location":"testing/#presenter-unit-tests","title":"Presenter Unit Tests","text":"<p>Here\u2019s a test to verify presenter emissions using the <code>Presenter.test()</code> helper. This function acts as a shorthand over Molecule + Turbine to give you a <code>ReceiveTurbine.() -&gt; Unit</code> lambda.</p> <pre><code>@Test fun `present - emit loading state then list of favorites`() = runTest {\nval favorites = listOf(Favorite(1L, ...))\n\nval repo = TestFavoritesRepository(favorites)\nval presenter = PetListPresenter(navigator, repo)\n\npresenter.test {\nassertThat(awaitItem()).isEqualTo(PetListScreen.State.Loading)\nval resultsItem = awaitItem() as Results\nassertThat(resultsItem.favorites).isEqualTo(favorites)\n}\n}\n\nThe same helper can be used when testing how the presenter responds to incoming events: @Test fun `present - navigate to favorite screen`() = runTest {\nval repo = TestFavoritesRepository(Favorite(123L))\nval presenter = PetListPresenter(navigator, repo)\n\npresenter.test {\nassertThat(awaitItem()).isEqualTo(PetListScreen.State.Loading)\nval resultsItem = awaitItem() as Results\nassertThat(resultsItem.favorites).isEqualTo(favorites)\nval clickFavorite = FavoriteScreen.Event.ClickFavorite(123L)\n\n// simulate user tapping favorite in UI\nresultsItem.eventSink(clickFavorite)\n\nassertThat(navigator.awaitNextScreen()).isEqualTo(FavoriteScreen(clickFavorite.id))\n}\n}\n</code></pre>"},{"location":"testing/#android-ui-instrumentation-tests","title":"Android UI Instrumentation Tests","text":"<p>UI tests can be driven directly through ComposeTestRule and use its Espresso-esque API for assertions:</p> <pre><code>@Test\nfun favoritesList_show_favorites_for_result_state() = runTest {\nval favorites = listOf(Favorite(1L, ...)\n\ncomposeTestRule.run {\nsetContent { // bootstrap the UI in the desired state\nFavoritesList(\nstate = FavoriteScreen.State.Results(favorites) { /* event callback */ }\n)\n}\n\nonNodeWithTag(\"no favorites\").assertDoesNotExist()\nonNodeWithText(\"Your Favorites\").assertIsDisplayed()\nonAllNodesWithTag(\"favorite\").assertCountEquals(1)\n}\n}\n</code></pre>"},{"location":"testing/#future-android-ui-unit-tests-via-paparazzi","title":"Future: Android UI Unit Tests via Paparazzi","text":"<p>We\u2019ve started exploring use of Paparazzi, which allows us to render Android UI without a physical device or emulator. More to come soon, but in short it would work similar to the above but be for purely non-functional 1:1 state \u2194 UI tests.</p> <pre><code>@Test\nfun previewFavorite() {\npaparazzi.snapshot { PreviewFavorite() }\n}\n</code></pre> <p>These are easy to maintain and review in GitHub.</p> <p>Another neat idea is we think this will make it easy to stand up compose preview functions for IDE use and reuse them.</p> <pre><code>// In your main source\n@Preview\n@Composable\ninternal fun PreviewFavorite() {\nFavorite()\n}\n\n// In your unit test\n@Test\nfun previewFavorite() {\npaparazzi.snapshot { PreviewFavorite() }\n}\n</code></pre>"},{"location":"ui/","title":"UI","text":"<p>The core Ui interface is simply this:</p> <pre><code>interface Ui&lt;UiState : CircuitUiState&gt; {\n@Composable fun Content(state: UiState, modifier: Modifier)\n}\n</code></pre> <p>Like presenters, simple UIs can also skip the class all together for use in other UIs. Core unit of granularity is just the @Composable function. In fact, when implementing these in practice they rarely use dependency injection at all and can normally just be written as top-level composable functions annotated with<code>@CircuitInject</code>.</p> <pre><code>@CircuitInject&lt;FavoritesScreen&gt; // Relevant DI wiring is generated\n@Composable\nprivate fun Favorites(state: FavoritesState, modifier: Modifier = Modifier) {\n// ...\n}\n</code></pre> <p>Writing UIs like this has a number of benefits.</p> <ul> <li>Functions-only nudges developers toward writing idiomatic compose code and not keeping un-scoped/un-observable state elsewhere (such as class properties).</li> <li>These functions are extremely easy to stand up in tests.</li> <li>These functions are extremely easy to stand up in Compose preview functions.</li> </ul> <p>Let\u2019s look a little more closely at the last bullet point about preview functions. With the above example, we can easily stand up previews for all of our different states!</p> <pre><code>@Preview\n@Composable\nprivate fun PreviewFavorites() = Favorites(FavoritesState(listOf(\"Reeses\", \"Lola\")))\n\n@Preview\n@Composable\nprivate fun PreviewEmptyFavorites() = Favorites(FavoritesState(listOf()))\n</code></pre> <p>TODO image sample of IDE preview</p>"},{"location":"api/0.x/","title":"Index","text":"<p>//circuit-test</p>"},{"location":"api/0.x/#circuit-test","title":"circuit-test","text":""},{"location":"api/0.x/#packages","title":"Packages","text":"Name com.slack.circuit.test"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/","title":"backstack","text":"<p>//backstack/com.slack.circuit.backstack</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/#package-level-declarations","title":"Package-level declarations","text":""},{"location":"api/0.x/backstack/com.slack.circuit.backstack/#types","title":"Types","text":"Name Summary BackStack [common]@Stableinterface BackStack&lt;R : BackStack.Record&gt; : Iterable&lt;R&gt; A caller-supplied stack of Records for presentation with the Navigator composable. Iteration order is top-first (first element is the top of the stack). BackStackRecordLocalProvider [common]fun interface BackStackRecordLocalProvider&lt;in R : BackStack.Record&gt; NavDecoration [common]@Stableinterface NavDecorationPresentation logic for currently visible routes of a navigable UI. ProvidedValues [common]fun interface ProvidedValues SaveableBackStack [common]class SaveableBackStack : BackStack&lt;SaveableBackStack.Record&gt; A BackStack that supports saving its state via rememberSaveable. See rememberSaveableBackStack. SaveableStateRegistryBackStackRecordLocalProvider [android]object SaveableStateRegistryBackStackRecordLocalProvider : BackStackRecordLocalProvider&lt;BackStack.Record&gt; A BackStackRecordLocalProvider that provides a SaveableStateRegistry for each record."},{"location":"api/0.x/backstack/com.slack.circuit.backstack/#functions","title":"Functions","text":"Name Summary popUntil [common]inline fun SaveableBackStack.popUntil(predicate: (SaveableBackStack.Record) -&gt; Boolean) providedValuesForBackStack [common]@Composablefun &lt;R : BackStack.Record&gt; providedValuesForBackStack(backStack: BackStack&lt;R&gt;, stackLocalProviders: List&lt;BackStackRecordLocalProvider&lt;R&gt;&gt; = emptyList(), includeDefaults: Boolean = true): Map&lt;R, ProvidedValues&gt; push [common]fun SaveableBackStack.push(route: String, args: Map&lt;String, Any?&gt; = emptyMap()) rememberSaveableBackStack [common]@Composablefun rememberSaveableBackStack(init: SaveableBackStack.() -&gt; Unit): SaveableBackStack"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/#properties","title":"Properties","text":"Name Summary isAtRoot [common]val BackStack&lt;*&gt;.isAtRoot: Boolean<code>true</code> if the BackStack contains exactly one record. isEmpty [common]val BackStack&lt;*&gt;.isEmpty: Boolean<code>true</code> if the BackStack contains no records. BackStack.firstOrNull will return <code>null</code>."},{"location":"api/0.x/backstack/com.slack.circuit.backstack/is-at-root/","title":"Is at root","text":"<p>//backstack/com.slack.circuit.backstack/isAtRoot</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/is-at-root/#isatroot","title":"isAtRoot","text":"<p>[common]\\ val BackStack&lt;*&gt;.isAtRoot: Boolean</p> <p><code>true</code> if the BackStack contains exactly one record.</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/is-empty/","title":"Is empty","text":"<p>//backstack/com.slack.circuit.backstack/isEmpty</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/is-empty/#isempty","title":"isEmpty","text":"<p>[common]\\ val BackStack&lt;*&gt;.isEmpty: Boolean</p> <p><code>true</code> if the BackStack contains no records. BackStack.firstOrNull will return <code>null</code>.</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/pop-until/","title":"Pop until","text":"<p>//backstack/com.slack.circuit.backstack/popUntil</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/pop-until/#popuntil","title":"popUntil","text":"<p>[common]\\ inline fun SaveableBackStack.popUntil(predicate: (SaveableBackStack.Record) -&gt; Boolean)</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/provided-values-for-back-stack/","title":"Provided values for back stack","text":"<p>//backstack/com.slack.circuit.backstack/providedValuesForBackStack</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/provided-values-for-back-stack/#providedvaluesforbackstack","title":"providedValuesForBackStack","text":"<p>[common]\\</p> <p>@Composable</p> <p>fun &lt;R : BackStack.Record&gt; providedValuesForBackStack(backStack: BackStack&lt;R&gt;, stackLocalProviders: List&lt;BackStackRecordLocalProvider&lt;R&gt;&gt; = emptyList(), includeDefaults: Boolean = true): Map&lt;R, ProvidedValues&gt;</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/push/","title":"Push","text":"<p>//backstack/com.slack.circuit.backstack/push</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/push/#push","title":"push","text":"<p>[common]\\ fun SaveableBackStack.push(route: String, args: Map&lt;String, Any?&gt; = emptyMap())</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/remember-saveable-back-stack/","title":"Remember saveable back stack","text":"<p>//backstack/com.slack.circuit.backstack/rememberSaveableBackStack</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/remember-saveable-back-stack/#remembersaveablebackstack","title":"rememberSaveableBackStack","text":"<p>[common]\\</p> <p>@Composable</p> <p>fun rememberSaveableBackStack(init: SaveableBackStack.() -&gt; Unit): SaveableBackStack</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/","title":"Index","text":"<p>//backstack/com.slack.circuit.backstack/BackStack</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/#backstack","title":"BackStack","text":"<p>@Stable</p> <p>interface BackStack&lt;R : BackStack.Record&gt; : Iterable&lt;R&gt; </p> <p>A caller-supplied stack of Records for presentation with the Navigator composable. Iteration order is top-first (first element is the top of the stack).</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/#inheritors","title":"Inheritors","text":"SaveableBackStack"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/#types","title":"Types","text":"Name Summary Record [common]interface Record"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/#functions","title":"Functions","text":"Name Summary iterator [common]abstract operator fun iterator(): Iterator&lt;R&gt; pop [common]abstract fun pop(): R?Attempt to pop the top item off of the back stack, returning the popped Record if popping was successful or <code>null</code> if no entry was popped."},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/#properties","title":"Properties","text":"Name Summary isAtRoot [common]val BackStack&lt;*&gt;.isAtRoot: Boolean<code>true</code> if the BackStack contains exactly one record. isEmpty [common]val BackStack&lt;*&gt;.isEmpty: Boolean<code>true</code> if the BackStack contains no records. BackStack.firstOrNull will return <code>null</code>. size [common]abstract val size: IntThe number of records contained in this BackStack that will be seen by an iterator."},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/pop/","title":"Pop","text":"<p>//backstack/com.slack.circuit.backstack/BackStack/pop</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/pop/#pop","title":"pop","text":"<p>[common]\\ abstract fun pop(): R?</p> <p>Attempt to pop the top item off of the back stack, returning the popped Record if popping was successful or <code>null</code> if no entry was popped.</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/size/","title":"Size","text":"<p>//backstack/com.slack.circuit.backstack/BackStack/size</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/size/#size","title":"size","text":"<p>[common]\\ abstract val size: Int</p> <p>The number of records contained in this BackStack that will be seen by an iterator.</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/-record/","title":"Index","text":"<p>//backstack/com.slack.circuit.backstack/BackStack/Record</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/-record/#record","title":"Record","text":"<p>interface Record</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/-record/#inheritors","title":"Inheritors","text":"Record"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/-record/#properties","title":"Properties","text":"Name Summary key [common]abstract val key: StringA value that identifies this record uniquely, even if it shares the same route with another record. This key may be used by BackStackRecordLocalProviders to associate presentation data with a record across composition recreation. route [common]abstract val route: StringThe name of the route that should present this record."},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/-record/key/","title":"Key","text":"<p>//backstack/com.slack.circuit.backstack/BackStack/Record/key</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/-record/key/#key","title":"key","text":"<p>[common]\\ abstract val key: String</p> <p>A value that identifies this record uniquely, even if it shares the same route with another record. This key may be used by BackStackRecordLocalProviders to associate presentation data with a record across composition recreation.</p> <p>key MUST NOT change for the life of the record.</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/-record/route/","title":"Route","text":"<p>//backstack/com.slack.circuit.backstack/BackStack/Record/route</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/-record/route/#route","title":"route","text":"<p>[common]\\ abstract val route: String</p> <p>The name of the route that should present this record.</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack-record-local-provider/","title":"Index","text":"<p>//backstack/com.slack.circuit.backstack/BackStackRecordLocalProvider</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack-record-local-provider/#backstackrecordlocalprovider","title":"BackStackRecordLocalProvider","text":"<p>fun interface BackStackRecordLocalProvider&lt;in R : BackStack.Record&gt;</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack-record-local-provider/#inheritors","title":"Inheritors","text":"SaveableStateRegistryBackStackRecordLocalProvider"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack-record-local-provider/#functions","title":"Functions","text":"Name Summary providedValuesFor [common]@Composableabstract fun providedValuesFor(record: R): ProvidedValues"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack-record-local-provider/provided-values-for/","title":"Provided values for","text":"<p>//backstack/com.slack.circuit.backstack/BackStackRecordLocalProvider/providedValuesFor</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack-record-local-provider/provided-values-for/#providedvaluesfor","title":"providedValuesFor","text":"<p>[common]\\</p> <p>@Composable</p> <p>abstract fun providedValuesFor(record: R): ProvidedValues</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-nav-decoration/","title":"Index","text":"<p>//backstack/com.slack.circuit.backstack/NavDecoration</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-nav-decoration/#navdecoration","title":"NavDecoration","text":"<p>[common]\\ @Stable</p> <p>interface NavDecoration</p> <p>Presentation logic for currently visible routes of a navigable UI.</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-nav-decoration/#functions","title":"Functions","text":"Name Summary DecoratedContent [common]@Composableabstract fun &lt;T&gt; DecoratedContent(arg: T, backStackDepth: Int, modifier: Modifier, content: @Composable(T) -&gt; Unit)"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-nav-decoration/-decorated-content/","title":"decorated content","text":"<p>//backstack/com.slack.circuit.backstack/NavDecoration/DecoratedContent</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-nav-decoration/-decorated-content/#decoratedcontent","title":"DecoratedContent","text":"<p>[common]\\</p> <p>@Composable</p> <p>abstract fun &lt;T&gt; DecoratedContent(arg: T, backStackDepth: Int, modifier: Modifier, content: @Composable(T) -&gt; Unit)</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-provided-values/","title":"Index","text":"<p>//backstack/com.slack.circuit.backstack/ProvidedValues</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-provided-values/#providedvalues","title":"ProvidedValues","text":"<p>[common]\\ fun interface ProvidedValues</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-provided-values/#functions","title":"Functions","text":"Name Summary provideValues [common]@Composableabstract fun provideValues(): List&lt;ProvidedValue&lt;*&gt;&gt;"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-provided-values/provide-values/","title":"Provide values","text":"<p>//backstack/com.slack.circuit.backstack/ProvidedValues/provideValues</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-provided-values/provide-values/#providevalues","title":"provideValues","text":"<p>[common]\\</p> <p>@Composable</p> <p>abstract fun provideValues(): List&lt;ProvidedValue&lt;*&gt;&gt;</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/","title":"Index","text":"<p>//backstack/com.slack.circuit.backstack/SaveableBackStack</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/#saveablebackstack","title":"SaveableBackStack","text":"<p>[common]\\ class SaveableBackStack : BackStack&lt;SaveableBackStack.Record&gt; </p> <p>A BackStack that supports saving its state via rememberSaveable. See rememberSaveableBackStack.</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/#constructors","title":"Constructors","text":"SaveableBackStack [common]constructor()"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/#types","title":"Types","text":"Name Summary Record [common]data class Record(val route: String, val args: Map&lt;String, Any?&gt; = emptyMap(), val key: String = UUID.randomUUID().toString()) : BackStack.Record"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/#functions","title":"Functions","text":"Name Summary iterator [common]open operator override fun iterator(): Iterator&lt;SaveableBackStack.Record&gt; pop [common]open override fun pop(): SaveableBackStack.Record?Attempt to pop the top item off of the back stack, returning the popped Record if popping was successful or <code>null</code> if no entry was popped. popUntil [common]inline fun SaveableBackStack.popUntil(predicate: (SaveableBackStack.Record) -&gt; Boolean) push [common]fun push(record: SaveableBackStack.Record) push [common]fun SaveableBackStack.push(route: String, args: Map&lt;String, Any?&gt; = emptyMap())"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/#properties","title":"Properties","text":"Name Summary isAtRoot [common]val BackStack&lt;*&gt;.isAtRoot: Boolean<code>true</code> if the BackStack contains exactly one record. isEmpty [common]val BackStack&lt;*&gt;.isEmpty: Boolean<code>true</code> if the BackStack contains no records. BackStack.firstOrNull will return <code>null</code>. size [common]open override val size: IntThe number of records contained in this BackStack that will be seen by an iterator. topRecord [common]val topRecord: SaveableBackStack.Record?"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/-saveable-back-stack/","title":"saveable back stack","text":"<p>//backstack/com.slack.circuit.backstack/SaveableBackStack/SaveableBackStack</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/-saveable-back-stack/#saveablebackstack","title":"SaveableBackStack","text":"<p>[common]\\ constructor()</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/iterator/","title":"Iterator","text":"<p>//backstack/com.slack.circuit.backstack/SaveableBackStack/iterator</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/iterator/#iterator","title":"iterator","text":"<p>[common]\\ open operator override fun iterator(): Iterator&lt;SaveableBackStack.Record&gt;</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/pop/","title":"Pop","text":"<p>//backstack/com.slack.circuit.backstack/SaveableBackStack/pop</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/pop/#pop","title":"pop","text":"<p>[common]\\ open override fun pop(): SaveableBackStack.Record?</p> <p>Attempt to pop the top item off of the back stack, returning the popped Record if popping was successful or <code>null</code> if no entry was popped.</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/push/","title":"Push","text":"<p>//backstack/com.slack.circuit.backstack/SaveableBackStack/push</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/push/#push","title":"push","text":"<p>[common]\\ fun push(record: SaveableBackStack.Record)</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/size/","title":"Size","text":"<p>//backstack/com.slack.circuit.backstack/SaveableBackStack/size</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/size/#size","title":"size","text":"<p>[common]\\ open override val size: Int</p> <p>The number of records contained in this BackStack that will be seen by an iterator.</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/top-record/","title":"Top record","text":"<p>//backstack/com.slack.circuit.backstack/SaveableBackStack/topRecord</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/top-record/#toprecord","title":"topRecord","text":"<p>[common]\\ val topRecord: SaveableBackStack.Record?</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/-record/","title":"Index","text":"<p>//backstack/com.slack.circuit.backstack/SaveableBackStack/Record</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/-record/#record","title":"Record","text":"<p>[common]\\ data class Record(val route: String, val args: Map&lt;String, Any?&gt; = emptyMap(), val key: String = UUID.randomUUID().toString()) : BackStack.Record</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/-record/#constructors","title":"Constructors","text":"Record [common]constructor(route: String, args: Map&lt;String, Any?&gt; = emptyMap(), key: String = UUID.randomUUID().toString())"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/-record/#properties","title":"Properties","text":"Name Summary args [common]val args: Map&lt;String, Any?&gt; key [common]open override val key: StringA value that identifies this record uniquely, even if it shares the same route with another record. This key may be used by BackStackRecordLocalProviders to associate presentation data with a record across composition recreation. route [common]open override val route: StringThe name of the route that should present this record."},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/-record/-record/","title":"record","text":"<p>//backstack/com.slack.circuit.backstack/SaveableBackStack/Record/Record</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/-record/-record/#record","title":"Record","text":"<p>[common]\\ constructor(route: String, args: Map&lt;String, Any?&gt; = emptyMap(), key: String = UUID.randomUUID().toString())</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/-record/args/","title":"Args","text":"<p>//backstack/com.slack.circuit.backstack/SaveableBackStack/Record/args</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/-record/args/#args","title":"args","text":"<p>[common]\\ val args: Map&lt;String, Any?&gt;</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/-record/key/","title":"Key","text":"<p>//backstack/com.slack.circuit.backstack/SaveableBackStack/Record/key</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/-record/key/#key","title":"key","text":"<p>[common]\\ open override val key: String</p> <p>A value that identifies this record uniquely, even if it shares the same route with another record. This key may be used by BackStackRecordLocalProviders to associate presentation data with a record across composition recreation.</p> <p>key MUST NOT change for the life of the record.</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/-record/route/","title":"Route","text":"<p>//backstack/com.slack.circuit.backstack/SaveableBackStack/Record/route</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/-record/route/#route","title":"route","text":"<p>[common]\\ open override val route: String</p> <p>The name of the route that should present this record.</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-state-registry-back-stack-record-local-provider/","title":"Index","text":"<p>//backstack/com.slack.circuit.backstack/SaveableStateRegistryBackStackRecordLocalProvider</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-state-registry-back-stack-record-local-provider/#saveablestateregistrybackstackrecordlocalprovider","title":"SaveableStateRegistryBackStackRecordLocalProvider","text":"<p>[android]\\ object SaveableStateRegistryBackStackRecordLocalProvider : BackStackRecordLocalProvider&lt;BackStack.Record&gt; </p> <p>A BackStackRecordLocalProvider that provides a SaveableStateRegistry for each record.</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-state-registry-back-stack-record-local-provider/#functions","title":"Functions","text":"Name Summary providedValuesFor [android]@Composableopen override fun providedValuesFor(record: BackStack.Record): ProvidedValues"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-state-registry-back-stack-record-local-provider/provided-values-for/","title":"Provided values for","text":"<p>//backstack/com.slack.circuit.backstack/SaveableStateRegistryBackStackRecordLocalProvider/providedValuesFor</p>"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-state-registry-back-stack-record-local-provider/provided-values-for/#providedvaluesfor","title":"providedValuesFor","text":"<p>[android]\\</p> <p>@Composable</p> <p>open override fun providedValuesFor(record: BackStack.Record): ProvidedValues</p>"},{"location":"api/0.x/circuit-codegen/com.slack.circuit.codegen/","title":"Index","text":"<p>//circuit-codegen/com.slack.circuit.codegen</p>"},{"location":"api/0.x/circuit-codegen/com.slack.circuit.codegen/#package-level-declarations","title":"Package-level declarations","text":""},{"location":"api/0.x/circuit-codegen/com.slack.circuit.codegen/#types","title":"Types","text":"Name Summary CircuitSymbolProcessorProvider [jvm]@AutoService(value = [SymbolProcessorProvider::class])class CircuitSymbolProcessorProvider : SymbolProcessorProvider"},{"location":"api/0.x/circuit-codegen/com.slack.circuit.codegen/-circuit-symbol-processor-provider/","title":"Index","text":"<p>//circuit-codegen/com.slack.circuit.codegen/CircuitSymbolProcessorProvider</p>"},{"location":"api/0.x/circuit-codegen/com.slack.circuit.codegen/-circuit-symbol-processor-provider/#circuitsymbolprocessorprovider","title":"CircuitSymbolProcessorProvider","text":"<p>[jvm]\\ @AutoService(value = [SymbolProcessorProvider::class])</p> <p>class CircuitSymbolProcessorProvider : SymbolProcessorProvider</p>"},{"location":"api/0.x/circuit-codegen/com.slack.circuit.codegen/-circuit-symbol-processor-provider/#constructors","title":"Constructors","text":"CircuitSymbolProcessorProvider [jvm]constructor()"},{"location":"api/0.x/circuit-codegen/com.slack.circuit.codegen/-circuit-symbol-processor-provider/#functions","title":"Functions","text":"Name Summary create [jvm]open override fun create(environment: SymbolProcessorEnvironment): SymbolProcessor"},{"location":"api/0.x/circuit-codegen/com.slack.circuit.codegen/-circuit-symbol-processor-provider/-circuit-symbol-processor-provider/","title":"circuit symbol processor provider","text":"<p>//circuit-codegen/com.slack.circuit.codegen/CircuitSymbolProcessorProvider/CircuitSymbolProcessorProvider</p>"},{"location":"api/0.x/circuit-codegen/com.slack.circuit.codegen/-circuit-symbol-processor-provider/-circuit-symbol-processor-provider/#circuitsymbolprocessorprovider","title":"CircuitSymbolProcessorProvider","text":"<p>[jvm]\\ constructor()</p>"},{"location":"api/0.x/circuit-codegen/com.slack.circuit.codegen/-circuit-symbol-processor-provider/create/","title":"Create","text":"<p>//circuit-codegen/com.slack.circuit.codegen/CircuitSymbolProcessorProvider/create</p>"},{"location":"api/0.x/circuit-codegen/com.slack.circuit.codegen/-circuit-symbol-processor-provider/create/#create","title":"create","text":"<p>[jvm]\\ open override fun create(environment: SymbolProcessorEnvironment): SymbolProcessor</p>"},{"location":"api/0.x/circuit-codegen-annotations/com.slack.circuit.codegen.annotations/","title":"circuit-codegen-annotations","text":"<p>//circuit-codegen-annotations/com.slack.circuit.codegen.annotations</p>"},{"location":"api/0.x/circuit-codegen-annotations/com.slack.circuit.codegen.annotations/#package-level-declarations","title":"Package-level declarations","text":""},{"location":"api/0.x/circuit-codegen-annotations/com.slack.circuit.codegen.annotations/#types","title":"Types","text":"Name Summary CircuitInject [common]@Target(allowedTargets = [AnnotationTarget.CLASS, AnnotationTarget.FUNCTION])annotation class CircuitInject(val screen: KClass&lt;out &lt;Error class: unknown class&gt;&gt;, val scope: KClass&lt;*&gt;)This annotation is used to mark a UI or presenter class or function for code generation. When annotated, the type\u2019s corresponding factory will be generated and keyed with the defined screen ."},{"location":"api/0.x/circuit-codegen-annotations/com.slack.circuit.codegen.annotations/-circuit-inject/","title":"Index","text":"<p>//circuit-codegen-annotations/com.slack.circuit.codegen.annotations/CircuitInject</p>"},{"location":"api/0.x/circuit-codegen-annotations/com.slack.circuit.codegen.annotations/-circuit-inject/#circuitinject","title":"CircuitInject","text":"<p>[common]\\ @Target(allowedTargets = [AnnotationTarget.CLASS, AnnotationTarget.FUNCTION])</p> <p>annotation class CircuitInject(val screen: KClass&lt;out &lt;Error class: unknown class&gt;&gt;, val scope: KClass&lt;*&gt;)</p> <p>This annotation is used to mark a UI or presenter class or function for code generation. When annotated, the type\u2019s corresponding factory will be generated and keyed with the defined screen .</p> <p>The generated factories are then contributed to Anvil via ContributesMultibinding and scoped with the provided scope key.</p>"},{"location":"api/0.x/circuit-codegen-annotations/com.slack.circuit.codegen.annotations/-circuit-inject/#classes","title":"Classes","text":"<p>Presenter and Ui classes can be annotated and have their corresponding Presenter.Factory or Ui.Factory classes generated for them.</p> <p>Presenter</p> <pre><code>@CircuitInject(HomeScreen::class, AppScope::class)\nclass HomePresenter @Inject constructor(...) : Presenter&lt;HomeState&gt; { ... }\n\n// Generates\n@ContributesMultibinding(AppScope::class)\nclass HomePresenterFactory @Inject constructor() : Presenter.Factory { ... }\n</code></pre> <p>UI</p> <pre><code>@CircuitInject(HomeScreen::class, AppScope::class)\nclass HomeUi @Inject constructor(...) : Ui&lt;HomeState&gt; { ... }\n\n// Generates\n@ContributesMultibinding(AppScope::class)\nclass HomeUiFactory @Inject constructor() : Ui.Factory { ... }\n</code></pre>"},{"location":"api/0.x/circuit-codegen-annotations/com.slack.circuit.codegen.annotations/-circuit-inject/#functions","title":"Functions","text":"<p>Simple functions can be annotated and have a corresponding Presenter.Factory generated. This is primarily useful for simple cases where a class is just technical tedium.</p> <p>Requirements</p> <ul> <li>Presenter function names must end in <code>Presenter</code>, otherwise they will be treated as UI functions.</li> <li>Presenter functions must return a CircuitUiState type.</li> <li>UI functions can optionally accept a CircuitUiState type as a parameter, but it is not required.</li> <li>UI functions must return Unit.</li> <li>Both presenter and UI functions must be Composable.</li> </ul> <p>Presenter</p> <pre><code>@CircuitInject(HomeScreen::class, AppScope::class)\n@Composable\nfun HomePresenter(): HomeState { ... }\n\n// Generates\n@ContributesMultibinding(AppScope::class)\nclass HomePresenterFactory @Inject constructor() : Presenter.Factory { ... }\n</code></pre> <p>UI</p> <pre><code>@CircuitInject(HomeScreen::class, AppScope::class)\n@Composable\nfun Home(state: HomeState) { ... }\n\n// Generates\n@ContributesMultibinding(AppScope::class)\nclass HomeUiFactory @Inject constructor() : Ui.Factory { ... }\n</code></pre>"},{"location":"api/0.x/circuit-codegen-annotations/com.slack.circuit.codegen.annotations/-circuit-inject/#assisted-injection","title":"Assisted injection","text":"<p>Any type that is offered in Presenter.Factory and Ui.Factory can be offered as an assisted injection to types using Dagger AssistedInject. For these cases, the AssistedFactory -annotated interface should be annotated with CircuitInject instead of the enclosing class.</p> <p>Types available for assisted injection are:</p> <ul> <li>Screen \u2013 the screen key used to create the Presenter or Ui.</li> <li>Navigator \u2013 (presenters only)</li> <li>CircuitConfig</li> </ul> <p>Each should only be defined at-most once.</p> <p>Examples</p> <pre><code>// Function example\n@CircuitInject(HomeScreen::class, AppScope::class)\n@Composable\nfun HomePresenter(screen: Screen, navigator: Navigator): HomeState { ... }\n\n// Class example\nclass HomePresenter @AssistedInject constructor(\n@Assisted screen: Screen,\n@Assisted navigator: Navigator,\n...\n) : Presenter&lt;HomeState&gt; {\n// ...\n\n@CircuitInject(HomeScreen::class, AppScope::class)\n@AssistedFactory\nfun interface Factory {\nfun create(screen: Screen, navigator: Navigator): HomePresenter\n}\n}\n</code></pre>"},{"location":"api/0.x/circuit-codegen-annotations/com.slack.circuit.codegen.annotations/-circuit-inject/#properties","title":"Properties","text":"Name Summary scope [common]val scope: KClass&lt;*&gt; screen [common]val screen: KClass&lt;out &lt;Error class: unknown class&gt;&gt;"},{"location":"api/0.x/circuit-codegen-annotations/com.slack.circuit.codegen.annotations/-circuit-inject/scope/","title":"Scope","text":"<p>//circuit-codegen-annotations/com.slack.circuit.codegen.annotations/CircuitInject/scope</p>"},{"location":"api/0.x/circuit-codegen-annotations/com.slack.circuit.codegen.annotations/-circuit-inject/scope/#scope","title":"scope","text":"<p>[common]\\ val scope: KClass&lt;*&gt;</p>"},{"location":"api/0.x/circuit-codegen-annotations/com.slack.circuit.codegen.annotations/-circuit-inject/screen/","title":"Screen","text":"<p>//circuit-codegen-annotations/com.slack.circuit.codegen.annotations/CircuitInject/screen</p>"},{"location":"api/0.x/circuit-codegen-annotations/com.slack.circuit.codegen.annotations/-circuit-inject/screen/#screen","title":"screen","text":"<p>[common]\\ val screen: KClass&lt;out &lt;Error class: unknown class&gt;&gt;</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/","title":"Index","text":"<p>//circuit-foundation/com.slack.circuit.foundation</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/#package-level-declarations","title":"Package-level declarations","text":""},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/#types","title":"Types","text":"Name Summary CircuitConfig [common]@Immutableclass CircuitConfigCircuitConfig adapts Presenter.Factory to their corresponding Ui.Factory using Screen. Create instances using the Builder and create new CircuitContent with it to run presenter/UI pairings. EventListener [common]interface EventListenerA listener for tracking the state changes of a given Screen. This can be used for instrumentation and other telemetry. NavEvent [common]interface NavEventA sealed navigation interface intended to be used when making a navigation call back. NavigatorDefaults [common]object NavigatorDefaultsDefault values and common alternatives used by navigable composables."},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/#functions","title":"Functions","text":"Name Summary CircuitCompositionLocals [common]@Composablefun CircuitCompositionLocals(circuitConfig: CircuitConfig, content: @Composable() -&gt; Unit)Provides the given circuitConfig as a CompositionLocal to all composables within content. Also adds any other composition locals that Circuit needs. CircuitContent [common]@Composablefun CircuitContent(screen: &lt;Error class: unknown class&gt;, modifier: Modifier = Modifier, circuitConfig: CircuitConfig = requireNotNull(LocalCircuitConfig.current), unavailableContent: @Composable(&lt;Error class: unknown class&gt;, modifier: Modifier) -&gt; Unit = circuitConfig.onUnavailableContent)@Composablefun CircuitContent(screen: &lt;Error class: unknown class&gt;, modifier: Modifier = Modifier, onNavEvent: (event: NavEvent) -&gt; Unit, circuitConfig: CircuitConfig = requireNotNull(LocalCircuitConfig.current), unavailableContent: @Composable(&lt;Error class: unknown class&gt;, modifier: Modifier) -&gt; Unit = circuitConfig.onUnavailableContent) NavigableCircuitContent [common]@Composablefun NavigableCircuitContent(navigator: &lt;Error class: unknown class&gt;, backstack: &lt;Error class: unknown class&gt;, modifier: Modifier = Modifier, circuitConfig: CircuitConfig = requireNotNull(LocalCircuitConfig.current), providedValues: Map&lt;out &lt;Error class: unknown class&gt;, &lt;Error class: unknown class&gt;&gt; = providedValuesForBackStack(backstack), decoration: &lt;Error class: unknown class&gt; = circuitConfig.defaultNavDecoration, unavailableRoute: @Composable(&lt;Error class: unknown class&gt;, modifier: Modifier) -&gt; Unit = circuitConfig.onUnavailableContent) onNavEvent [common]fun &lt;Error class: unknown class&gt;.onNavEvent(event: NavEvent)A Circuit call back to help navigate to different screens. Intended to be used when forwarding NavEvents from nested Presenters. push [common]fun &lt;Error class: unknown class&gt;.push(screen: &lt;Error class: unknown class&gt;) rememberCircuitNavigator [common]@Composablefun rememberCircuitNavigator(backstack: &lt;Error class: unknown class&gt;, onRootPop: () -&gt; Unit): &lt;Error class: unknown class&gt;Returns a new Navigator for navigating within CircuitContents.[android]@Composablefun rememberCircuitNavigator(backstack: SaveableBackStack, enableBackHandler: Boolean = true): NavigatorReturns a new Navigator for navigating within CircuitContents. Delegates onRootPop to the LocalOnBackPressedDispatcherOwner."},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/#properties","title":"Properties","text":"Name Summary config [common]var &lt;Error class: unknown class&gt;.config: CircuitConfigThe CircuitConfig used in this context. LocalCircuitConfig [common]val LocalCircuitConfig: ProvidableCompositionLocal&lt;CircuitConfig?&gt;CompositionLocal with a current CircuitConfig instance. screen [common]val &lt;Error class: unknown class&gt;.screen: &lt;Error class: unknown class&gt;"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-composition-locals/","title":"circuit composition locals","text":"<p>//circuit-foundation/com.slack.circuit.foundation/CircuitCompositionLocals</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-composition-locals/#circuitcompositionlocals","title":"CircuitCompositionLocals","text":"<p>[common]\\</p> <p>@Composable</p> <p>fun CircuitCompositionLocals(circuitConfig: CircuitConfig, content: @Composable() -&gt; Unit)</p> <p>Provides the given circuitConfig as a CompositionLocal to all composables within content. Also adds any other composition locals that Circuit needs.</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-content/","title":"circuit content","text":"<p>//circuit-foundation/com.slack.circuit.foundation/CircuitContent</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-content/#circuitcontent","title":"CircuitContent","text":"<p>[common]\\</p> <p>@Composable</p> <p>fun CircuitContent(screen: &lt;Error class: unknown class&gt;, modifier: Modifier = Modifier, circuitConfig: CircuitConfig = requireNotNull(LocalCircuitConfig.current), unavailableContent: @Composable(&lt;Error class: unknown class&gt;, modifier: Modifier) -&gt; Unit = circuitConfig.onUnavailableContent)</p> <p>@Composable</p> <p>fun CircuitContent(screen: &lt;Error class: unknown class&gt;, modifier: Modifier = Modifier, onNavEvent: (event: NavEvent) -&gt; Unit, circuitConfig: CircuitConfig = requireNotNull(LocalCircuitConfig.current), unavailableContent: @Composable(&lt;Error class: unknown class&gt;, modifier: Modifier) -&gt; Unit = circuitConfig.onUnavailableContent)</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-local-circuit-config/","title":"local circuit config","text":"<p>//circuit-foundation/com.slack.circuit.foundation/LocalCircuitConfig</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-local-circuit-config/#localcircuitconfig","title":"LocalCircuitConfig","text":"<p>[common]\\ val LocalCircuitConfig: ProvidableCompositionLocal&lt;CircuitConfig?&gt;</p> <p>CompositionLocal with a current CircuitConfig instance.</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-navigable-circuit-content/","title":"navigable circuit content","text":"<p>//circuit-foundation/com.slack.circuit.foundation/NavigableCircuitContent</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-navigable-circuit-content/#navigablecircuitcontent","title":"NavigableCircuitContent","text":"<p>[common]\\</p> <p>@Composable</p> <p>fun NavigableCircuitContent(navigator: &lt;Error class: unknown class&gt;, backstack: &lt;Error class: unknown class&gt;, modifier: Modifier = Modifier, circuitConfig: CircuitConfig = requireNotNull(LocalCircuitConfig.current), providedValues: Map&lt;out &lt;Error class: unknown class&gt;, &lt;Error class: unknown class&gt;&gt; = providedValuesForBackStack(backstack), decoration: &lt;Error class: unknown class&gt; = circuitConfig.defaultNavDecoration, unavailableRoute: @Composable(&lt;Error class: unknown class&gt;, modifier: Modifier) -&gt; Unit = circuitConfig.onUnavailableContent)</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/config/","title":"Config","text":"<p>//circuit-foundation/com.slack.circuit.foundation/config</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/config/#config","title":"config","text":"<p>[common]\\ var &lt;Error class: unknown class&gt;.config: CircuitConfig</p> <p>The CircuitConfig used in this context.</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/on-nav-event/","title":"On nav event","text":"<p>//circuit-foundation/com.slack.circuit.foundation/onNavEvent</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/on-nav-event/#onnavevent","title":"onNavEvent","text":"<p>[common]\\ fun &lt;Error class: unknown class&gt;.onNavEvent(event: NavEvent)</p> <p>A Circuit call back to help navigate to different screens. Intended to be used when forwarding NavEvents from nested Presenters.</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/push/","title":"Push","text":"<p>//circuit-foundation/com.slack.circuit.foundation/push</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/push/#push","title":"push","text":"<p>[common]\\ fun &lt;Error class: unknown class&gt;.push(screen: &lt;Error class: unknown class&gt;)</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/remember-circuit-navigator/","title":"Remember circuit navigator","text":"<p>//circuit-foundation/com.slack.circuit.foundation/rememberCircuitNavigator</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/remember-circuit-navigator/#remembercircuitnavigator","title":"rememberCircuitNavigator","text":"<p>[android]\\</p> <p>@Composable</p> <p>fun rememberCircuitNavigator(backstack: SaveableBackStack, enableBackHandler: Boolean = true): Navigator</p> <p>Returns a new Navigator for navigating within CircuitContents. Delegates onRootPop to the LocalOnBackPressedDispatcherOwner.</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/remember-circuit-navigator/#parameters","title":"Parameters","text":"<p>android</p> backstack The backing SaveableBackStack to navigate. enableBackHandler Indicates whether or not Navigator.pop should be called by the system back handler. Defaults to true."},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/remember-circuit-navigator/#see-also","title":"See also","text":"NavigableCircuitContent <p>[common]\\</p> <p>@Composable</p> <p>fun rememberCircuitNavigator(backstack: &lt;Error class: unknown class&gt;, onRootPop: () -&gt; Unit): &lt;Error class: unknown class&gt;</p> <p>Returns a new Navigator for navigating within CircuitContents.</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/remember-circuit-navigator/#parameters_1","title":"Parameters","text":"<p>common</p> backstack The backing SaveableBackStack to navigate. onRootPop Invoked when the backstack is at root (size 1) and the user presses the back button."},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/remember-circuit-navigator/#see-also_1","title":"See also","text":"NavigableCircuitContent"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/screen/","title":"Screen","text":"<p>//circuit-foundation/com.slack.circuit.foundation/screen</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/screen/#screen","title":"screen","text":"<p>[common]\\ val &lt;Error class: unknown class&gt;.screen: &lt;Error class: unknown class&gt;</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-config/","title":"Index","text":"<p>//circuit-foundation/com.slack.circuit.foundation/CircuitConfig</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-config/#circuitconfig","title":"CircuitConfig","text":"<p>@Immutable</p> <p>class CircuitConfig</p> <p>CircuitConfig adapts Presenter.Factory to their corresponding Ui.Factory using Screen. Create instances using the Builder and create new CircuitContent with it to run presenter/UI pairings.</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-config/#construction","title":"Construction","text":"<p>Construction of CircuitConfig instances is done using the Builder.</p> <pre><code>val circuitConfig = CircuitConfig.Builder()\n.addUiFactory(AddFavoritesUiFactory()\n.addPresenterFactory(AddFavoritesPresenterFactory())\n.build()\n</code></pre>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-config/#usage","title":"Usage","text":"<p>These instances can then be used with the composable CircuitContent functions to run presenter/UI pairings for individual Screen.</p> <p>Circuit instances are consumed within these composable functions via the CircuitCompositionLocals CompositionLocalProvider.</p> <pre><code>CircuitCompositionLocals(circuitConfig) {\nCircuitContent(AddFavoritesScreen())\n}\n</code></pre> <p>If using navigation, use <code>NavigableCircuitContent</code> instead.</p> <pre><code>val backstack = rememberSaveableBackStack { push(AddFavoritesScreen()) }\nval navigator = rememberCircuitNavigator(backstack, ::onBackPressed)\nCircuitCompositionLocals(circuitConfig) {\nNavigableCircuitContent(navigator, backstack)\n}\n</code></pre>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-config/#see-also","title":"See also","text":"CircuitContent"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-config/#types","title":"Types","text":"Name Summary Builder [common]class Builder"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-config/#functions","title":"Functions","text":"Name Summary newBuilder [common]fun newBuilder(): CircuitConfig.Builder nextPresenter [common]fun nextPresenter(skipPast: &lt;Error class: unknown class&gt;?, screen: &lt;Error class: unknown class&gt;, navigator: &lt;Error class: unknown class&gt;, context: &lt;Error class: unknown class&gt;): &lt;Error class: unknown class&gt;&lt;out &lt;Error class: unknown class&gt;&gt;? nextUi [common]fun nextUi(skipPast: &lt;Error class: unknown class&gt;?, screen: &lt;Error class: unknown class&gt;, context: &lt;Error class: unknown class&gt;): &lt;Error class: unknown class&gt;&lt;out &lt;Error class: unknown class&gt;&gt;? presenter [common]fun presenter(screen: &lt;Error class: unknown class&gt;, navigator: &lt;Error class: unknown class&gt;, context: &lt;Error class: unknown class&gt; = CircuitContext(null).also { it.config = this }): &lt;Error class: unknown class&gt;&lt;out &lt;Error class: unknown class&gt;&gt;? ui [common]fun ui(screen: &lt;Error class: unknown class&gt;, context: &lt;Error class: unknown class&gt; = CircuitContext(null).also { it.config = this }): &lt;Error class: unknown class&gt;&lt;out &lt;Error class: unknown class&gt;&gt;?"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-config/#properties","title":"Properties","text":"Name Summary defaultNavDecoration [common]val defaultNavDecoration: &lt;Error class: unknown class&gt; onUnavailableContent [common]val onUnavailableContent: @Composable(&lt;Error class: unknown class&gt;, modifier: Modifier) -&gt; Unit"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-config/default-nav-decoration/","title":"Default nav decoration","text":"<p>//circuit-foundation/com.slack.circuit.foundation/CircuitConfig/defaultNavDecoration</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-config/default-nav-decoration/#defaultnavdecoration","title":"defaultNavDecoration","text":"<p>[common]\\ val defaultNavDecoration: &lt;Error class: unknown class&gt;</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-config/new-builder/","title":"New builder","text":"<p>//circuit-foundation/com.slack.circuit.foundation/CircuitConfig/newBuilder</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-config/new-builder/#newbuilder","title":"newBuilder","text":"<p>[common]\\ fun newBuilder(): CircuitConfig.Builder</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-config/next-presenter/","title":"Next presenter","text":"<p>//circuit-foundation/com.slack.circuit.foundation/CircuitConfig/nextPresenter</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-config/next-presenter/#nextpresenter","title":"nextPresenter","text":"<p>[common]\\ fun nextPresenter(skipPast: &lt;Error class: unknown class&gt;?, screen: &lt;Error class: unknown class&gt;, navigator: &lt;Error class: unknown class&gt;, context: &lt;Error class: unknown class&gt;): &lt;Error class: unknown class&gt;&lt;out &lt;Error class: unknown class&gt;&gt;?</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-config/next-ui/","title":"Next ui","text":"<p>//circuit-foundation/com.slack.circuit.foundation/CircuitConfig/nextUi</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-config/next-ui/#nextui","title":"nextUi","text":"<p>[common]\\ fun nextUi(skipPast: &lt;Error class: unknown class&gt;?, screen: &lt;Error class: unknown class&gt;, context: &lt;Error class: unknown class&gt;): &lt;Error class: unknown class&gt;&lt;out &lt;Error class: unknown class&gt;&gt;?</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-config/on-unavailable-content/","title":"On unavailable content","text":"<p>//circuit-foundation/com.slack.circuit.foundation/CircuitConfig/onUnavailableContent</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-config/on-unavailable-content/#onunavailablecontent","title":"onUnavailableContent","text":"<p>[common]\\ val onUnavailableContent: @Composable(&lt;Error class: unknown class&gt;, modifier: Modifier) -&gt; Unit</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-config/presenter/","title":"Presenter","text":"<p>//circuit-foundation/com.slack.circuit.foundation/CircuitConfig/presenter</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-config/presenter/#presenter","title":"presenter","text":"<p>[common]\\ fun presenter(screen: &lt;Error class: unknown class&gt;, navigator: &lt;Error class: unknown class&gt;, context: &lt;Error class: unknown class&gt; = CircuitContext(null).also { it.config = this }): &lt;Error class: unknown class&gt;&lt;out &lt;Error class: unknown class&gt;&gt;?</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-config/ui/","title":"Ui","text":"<p>//circuit-foundation/com.slack.circuit.foundation/CircuitConfig/ui</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-config/ui/#ui","title":"ui","text":"<p>[common]\\ fun ui(screen: &lt;Error class: unknown class&gt;, context: &lt;Error class: unknown class&gt; = CircuitContext(null).also { it.config = this }): &lt;Error class: unknown class&gt;&lt;out &lt;Error class: unknown class&gt;&gt;?</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-config/-builder/","title":"Index","text":"<p>//circuit-foundation/com.slack.circuit.foundation/CircuitConfig/Builder</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-config/-builder/#builder","title":"Builder","text":"<p>[common]\\ class Builder</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-config/-builder/#constructors","title":"Constructors","text":"Builder [common]constructor()"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-config/-builder/#functions","title":"Functions","text":"Name Summary addPresenterFactories [common]fun addPresenterFactories(factories: Iterable&lt;&lt;Error class: unknown class&gt;&gt;): CircuitConfig.Builder addPresenterFactory [common]fun addPresenterFactory(factory: &lt;Error class: unknown class&gt;): CircuitConfig.Builderfun addPresenterFactory(vararg factory: &lt;Error class: unknown class&gt;): CircuitConfig.Builder addUiFactories [common]fun addUiFactories(factories: Iterable&lt;&lt;Error class: unknown class&gt;&gt;): CircuitConfig.Builder addUiFactory [common]fun addUiFactory(factory: &lt;Error class: unknown class&gt;): CircuitConfig.Builderfun addUiFactory(vararg factory: &lt;Error class: unknown class&gt;): CircuitConfig.Builder build [common]fun build(): CircuitConfig eventListenerFactory [common]fun eventListenerFactory(factory: EventListener.Factory): CircuitConfig.Builder setDefaultNavDecoration [common]fun setDefaultNavDecoration(decoration: &lt;Error class: unknown class&gt;): CircuitConfig.Builder setOnUnavailableContent [common]fun setOnUnavailableContent(content: @Composable(&lt;Error class: unknown class&gt;, modifier: Modifier) -&gt; Unit): CircuitConfig.Builder"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-config/-builder/#properties","title":"Properties","text":"Name Summary defaultNavDecoration [common]var defaultNavDecoration: &lt;Error class: unknown class&gt; eventListenerFactory [common]var eventListenerFactory: EventListener.Factory? onUnavailableContent [common]var onUnavailableContent: @Composable(&lt;Error class: unknown class&gt;, modifier: Modifier) -&gt; Unit presenterFactories [common]val presenterFactories: MutableList&lt;&lt;Error class: unknown class&gt;&gt; uiFactories [common]val uiFactories: MutableList&lt;&lt;Error class: unknown class&gt;&gt;"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-config/-builder/-builder/","title":"builder","text":"<p>//circuit-foundation/com.slack.circuit.foundation/CircuitConfig/Builder/Builder</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-config/-builder/-builder/#builder","title":"Builder","text":"<p>[common]\\ constructor()</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-config/-builder/add-presenter-factories/","title":"Add presenter factories","text":"<p>//circuit-foundation/com.slack.circuit.foundation/CircuitConfig/Builder/addPresenterFactories</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-config/-builder/add-presenter-factories/#addpresenterfactories","title":"addPresenterFactories","text":"<p>[common]\\ fun addPresenterFactories(factories: Iterable&lt;&lt;Error class: unknown class&gt;&gt;): CircuitConfig.Builder</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-config/-builder/add-presenter-factory/","title":"Add presenter factory","text":"<p>//circuit-foundation/com.slack.circuit.foundation/CircuitConfig/Builder/addPresenterFactory</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-config/-builder/add-presenter-factory/#addpresenterfactory","title":"addPresenterFactory","text":"<p>[common]\\ fun addPresenterFactory(factory: &lt;Error class: unknown class&gt;): CircuitConfig.Builder</p> <p>fun addPresenterFactory(vararg factory: &lt;Error class: unknown class&gt;): CircuitConfig.Builder</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-config/-builder/add-ui-factories/","title":"Add ui factories","text":"<p>//circuit-foundation/com.slack.circuit.foundation/CircuitConfig/Builder/addUiFactories</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-config/-builder/add-ui-factories/#adduifactories","title":"addUiFactories","text":"<p>[common]\\ fun addUiFactories(factories: Iterable&lt;&lt;Error class: unknown class&gt;&gt;): CircuitConfig.Builder</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-config/-builder/add-ui-factory/","title":"Add ui factory","text":"<p>//circuit-foundation/com.slack.circuit.foundation/CircuitConfig/Builder/addUiFactory</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-config/-builder/add-ui-factory/#adduifactory","title":"addUiFactory","text":"<p>[common]\\ fun addUiFactory(factory: &lt;Error class: unknown class&gt;): CircuitConfig.Builder</p> <p>fun addUiFactory(vararg factory: &lt;Error class: unknown class&gt;): CircuitConfig.Builder</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-config/-builder/build/","title":"Build","text":"<p>//circuit-foundation/com.slack.circuit.foundation/CircuitConfig/Builder/build</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-config/-builder/build/#build","title":"build","text":"<p>[common]\\ fun build(): CircuitConfig</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-config/-builder/default-nav-decoration/","title":"Default nav decoration","text":"<p>//circuit-foundation/com.slack.circuit.foundation/CircuitConfig/Builder/defaultNavDecoration</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-config/-builder/default-nav-decoration/#defaultnavdecoration","title":"defaultNavDecoration","text":"<p>[common]\\ var defaultNavDecoration: &lt;Error class: unknown class&gt;</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-config/-builder/event-listener-factory/","title":"Event listener factory","text":"<p>//circuit-foundation/com.slack.circuit.foundation/CircuitConfig/Builder/eventListenerFactory</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-config/-builder/event-listener-factory/#eventlistenerfactory","title":"eventListenerFactory","text":"<p>[common]\\ fun eventListenerFactory(factory: EventListener.Factory): CircuitConfig.Builder</p> <p>var eventListenerFactory: EventListener.Factory?</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-config/-builder/on-unavailable-content/","title":"On unavailable content","text":"<p>//circuit-foundation/com.slack.circuit.foundation/CircuitConfig/Builder/onUnavailableContent</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-config/-builder/on-unavailable-content/#onunavailablecontent","title":"onUnavailableContent","text":"<p>[common]\\ var onUnavailableContent: @Composable(&lt;Error class: unknown class&gt;, modifier: Modifier) -&gt; Unit</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-config/-builder/presenter-factories/","title":"Presenter factories","text":"<p>//circuit-foundation/com.slack.circuit.foundation/CircuitConfig/Builder/presenterFactories</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-config/-builder/presenter-factories/#presenterfactories","title":"presenterFactories","text":"<p>[common]\\ val presenterFactories: MutableList&lt;&lt;Error class: unknown class&gt;&gt;</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-config/-builder/set-default-nav-decoration/","title":"Set default nav decoration","text":"<p>//circuit-foundation/com.slack.circuit.foundation/CircuitConfig/Builder/setDefaultNavDecoration</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-config/-builder/set-default-nav-decoration/#setdefaultnavdecoration","title":"setDefaultNavDecoration","text":"<p>[common]\\ fun setDefaultNavDecoration(decoration: &lt;Error class: unknown class&gt;): CircuitConfig.Builder</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-config/-builder/set-on-unavailable-content/","title":"Set on unavailable content","text":"<p>//circuit-foundation/com.slack.circuit.foundation/CircuitConfig/Builder/setOnUnavailableContent</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-config/-builder/set-on-unavailable-content/#setonunavailablecontent","title":"setOnUnavailableContent","text":"<p>[common]\\ fun setOnUnavailableContent(content: @Composable(&lt;Error class: unknown class&gt;, modifier: Modifier) -&gt; Unit): CircuitConfig.Builder</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-config/-builder/ui-factories/","title":"Ui factories","text":"<p>//circuit-foundation/com.slack.circuit.foundation/CircuitConfig/Builder/uiFactories</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-circuit-config/-builder/ui-factories/#uifactories","title":"uiFactories","text":"<p>[common]\\ val uiFactories: MutableList&lt;&lt;Error class: unknown class&gt;&gt;</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-event-listener/","title":"Index","text":"<p>//circuit-foundation/com.slack.circuit.foundation/EventListener</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-event-listener/#eventlistener","title":"EventListener","text":"<p>[common]\\ interface EventListener</p> <p>A listener for tracking the state changes of a given Screen. This can be used for instrumentation and other telemetry.</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-event-listener/#types","title":"Types","text":"Name Summary Companion [common]object Companion Factory [common]fun interface Factory"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-event-listener/#functions","title":"Functions","text":"Name Summary dispose [common]open fun dispose()Called once when this EventListener should be disposed and the corresponding circuit is disposed. onAfterCreatePresenter [common]open fun onAfterCreatePresenter(screen: &lt;Error class: unknown class&gt;, navigator: &lt;Error class: unknown class&gt;, presenter: &lt;Error class: unknown class&gt;&lt;out &lt;Error class: unknown class&gt;&gt;?, context: &lt;Error class: unknown class&gt;)Called just after creating a presenter for a given screen. The presenter may be null if none was found. onAfterCreateUi [common]open fun onAfterCreateUi(screen: &lt;Error class: unknown class&gt;, ui: &lt;Error class: unknown class&gt;&lt;out &lt;Error class: unknown class&gt;&gt;?, context: &lt;Error class: unknown class&gt;)Called just after creating a ui for a given screen. The ui may be null if none was found. onBeforeCreatePresenter [common]open fun onBeforeCreatePresenter(screen: &lt;Error class: unknown class&gt;, navigator: &lt;Error class: unknown class&gt;, context: &lt;Error class: unknown class&gt;)Called just before creating a Presenter for a given screen. onBeforeCreateUi [common]open fun onBeforeCreateUi(screen: &lt;Error class: unknown class&gt;, context: &lt;Error class: unknown class&gt;)Called just before creating a Ui for a given screen. onDisposeContent [common]open fun onDisposeContent()Called once after the Ui.Content composition is disposed. onDisposePresent [common]open fun onDisposePresent()Called once after the Presenter.present composition is disposed. onStartContent [common]open fun onStartContent()Called once before the initial Ui.Content call. onStartPresent [common]open fun onStartPresent()Called once before the initial Presenter.present call. onState [common]open fun onState(state: &lt;Error class: unknown class&gt;)Called when there is a new state returned by the Presenter. This is called every time state is recomposed. onUnavailableContent [common]open fun onUnavailableContent(screen: &lt;Error class: unknown class&gt;, presenter: &lt;Error class: unknown class&gt;&lt;out &lt;Error class: unknown class&gt;&gt;?, ui: &lt;Error class: unknown class&gt;&lt;out &lt;Error class: unknown class&gt;&gt;?, context: &lt;Error class: unknown class&gt;)Called when no content was found and one or both of presenter and ui are null. start [common]open fun start()Called once before doing any processing for the requested circuit."},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-event-listener/dispose/","title":"Dispose","text":"<p>//circuit-foundation/com.slack.circuit.foundation/EventListener/dispose</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-event-listener/dispose/#dispose","title":"dispose","text":"<p>[common]\\ open fun dispose()</p> <p>Called once when this EventListener should be disposed and the corresponding circuit is disposed.</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-event-listener/on-after-create-presenter/","title":"On after create presenter","text":"<p>//circuit-foundation/com.slack.circuit.foundation/EventListener/onAfterCreatePresenter</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-event-listener/on-after-create-presenter/#onaftercreatepresenter","title":"onAfterCreatePresenter","text":"<p>[common]\\ open fun onAfterCreatePresenter(screen: &lt;Error class: unknown class&gt;, navigator: &lt;Error class: unknown class&gt;, presenter: &lt;Error class: unknown class&gt;&lt;out &lt;Error class: unknown class&gt;&gt;?, context: &lt;Error class: unknown class&gt;)</p> <p>Called just after creating a presenter for a given screen. The presenter may be null if none was found.</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-event-listener/on-after-create-ui/","title":"On after create ui","text":"<p>//circuit-foundation/com.slack.circuit.foundation/EventListener/onAfterCreateUi</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-event-listener/on-after-create-ui/#onaftercreateui","title":"onAfterCreateUi","text":"<p>[common]\\ open fun onAfterCreateUi(screen: &lt;Error class: unknown class&gt;, ui: &lt;Error class: unknown class&gt;&lt;out &lt;Error class: unknown class&gt;&gt;?, context: &lt;Error class: unknown class&gt;)</p> <p>Called just after creating a ui for a given screen. The ui may be null if none was found.</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-event-listener/on-before-create-presenter/","title":"On before create presenter","text":"<p>//circuit-foundation/com.slack.circuit.foundation/EventListener/onBeforeCreatePresenter</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-event-listener/on-before-create-presenter/#onbeforecreatepresenter","title":"onBeforeCreatePresenter","text":"<p>[common]\\ open fun onBeforeCreatePresenter(screen: &lt;Error class: unknown class&gt;, navigator: &lt;Error class: unknown class&gt;, context: &lt;Error class: unknown class&gt;)</p> <p>Called just before creating a Presenter for a given screen.</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-event-listener/on-before-create-ui/","title":"On before create ui","text":"<p>//circuit-foundation/com.slack.circuit.foundation/EventListener/onBeforeCreateUi</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-event-listener/on-before-create-ui/#onbeforecreateui","title":"onBeforeCreateUi","text":"<p>[common]\\ open fun onBeforeCreateUi(screen: &lt;Error class: unknown class&gt;, context: &lt;Error class: unknown class&gt;)</p> <p>Called just before creating a Ui for a given screen.</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-event-listener/on-dispose-content/","title":"On dispose content","text":"<p>//circuit-foundation/com.slack.circuit.foundation/EventListener/onDisposeContent</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-event-listener/on-dispose-content/#ondisposecontent","title":"onDisposeContent","text":"<p>[common]\\ open fun onDisposeContent()</p> <p>Called once after the Ui.Content composition is disposed.</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-event-listener/on-dispose-present/","title":"On dispose present","text":"<p>//circuit-foundation/com.slack.circuit.foundation/EventListener/onDisposePresent</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-event-listener/on-dispose-present/#ondisposepresent","title":"onDisposePresent","text":"<p>[common]\\ open fun onDisposePresent()</p> <p>Called once after the Presenter.present composition is disposed.</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-event-listener/on-start-content/","title":"On start content","text":"<p>//circuit-foundation/com.slack.circuit.foundation/EventListener/onStartContent</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-event-listener/on-start-content/#onstartcontent","title":"onStartContent","text":"<p>[common]\\ open fun onStartContent()</p> <p>Called once before the initial Ui.Content call.</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-event-listener/on-start-present/","title":"On start present","text":"<p>//circuit-foundation/com.slack.circuit.foundation/EventListener/onStartPresent</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-event-listener/on-start-present/#onstartpresent","title":"onStartPresent","text":"<p>[common]\\ open fun onStartPresent()</p> <p>Called once before the initial Presenter.present call.</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-event-listener/on-state/","title":"On state","text":"<p>//circuit-foundation/com.slack.circuit.foundation/EventListener/onState</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-event-listener/on-state/#onstate","title":"onState","text":"<p>[common]\\ open fun onState(state: &lt;Error class: unknown class&gt;)</p> <p>Called when there is a new state returned by the Presenter. This is called every time state is recomposed.</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-event-listener/on-unavailable-content/","title":"On unavailable content","text":"<p>//circuit-foundation/com.slack.circuit.foundation/EventListener/onUnavailableContent</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-event-listener/on-unavailable-content/#onunavailablecontent","title":"onUnavailableContent","text":"<p>[common]\\ open fun onUnavailableContent(screen: &lt;Error class: unknown class&gt;, presenter: &lt;Error class: unknown class&gt;&lt;out &lt;Error class: unknown class&gt;&gt;?, ui: &lt;Error class: unknown class&gt;&lt;out &lt;Error class: unknown class&gt;&gt;?, context: &lt;Error class: unknown class&gt;)</p> <p>Called when no content was found and one or both of presenter and ui are null.</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-event-listener/start/","title":"Start","text":"<p>//circuit-foundation/com.slack.circuit.foundation/EventListener/start</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-event-listener/start/#start","title":"start","text":"<p>[common]\\ open fun start()</p> <p>Called once before doing any processing for the requested circuit.</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-event-listener/-companion/","title":"Index","text":"<p>//circuit-foundation/com.slack.circuit.foundation/EventListener/Companion</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-event-listener/-companion/#companion","title":"Companion","text":"<p>[common]\\ object Companion</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-event-listener/-companion/#properties","title":"Properties","text":"Name Summary NONE [common]val NONE: EventListener"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-event-listener/-companion/-n-o-n-e/","title":"n o n e","text":"<p>//circuit-foundation/com.slack.circuit.foundation/EventListener/Companion/NONE</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-event-listener/-companion/-n-o-n-e/#none","title":"NONE","text":"<p>[common]\\ val NONE: EventListener</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-event-listener/-factory/","title":"Index","text":"<p>//circuit-foundation/com.slack.circuit.foundation/EventListener/Factory</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-event-listener/-factory/#factory","title":"Factory","text":"<p>[common]\\ fun interface Factory</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-event-listener/-factory/#functions","title":"Functions","text":"Name Summary create [common]abstract fun create(screen: &lt;Error class: unknown class&gt;, context: &lt;Error class: unknown class&gt;): EventListener"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-event-listener/-factory/create/","title":"Create","text":"<p>//circuit-foundation/com.slack.circuit.foundation/EventListener/Factory/create</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-event-listener/-factory/create/#create","title":"create","text":"<p>[common]\\ abstract fun create(screen: &lt;Error class: unknown class&gt;, context: &lt;Error class: unknown class&gt;): EventListener</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-nav-event/","title":"Index","text":"<p>//circuit-foundation/com.slack.circuit.foundation/NavEvent</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-nav-event/#navevent","title":"NavEvent","text":"<p>[common]\\ interface NavEvent</p> <p>A sealed navigation interface intended to be used when making a navigation call back.</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-navigator-defaults/","title":"Index","text":"<p>//circuit-foundation/com.slack.circuit.foundation/NavigatorDefaults</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-navigator-defaults/#navigatordefaults","title":"NavigatorDefaults","text":"<p>[common]\\ object NavigatorDefaults</p> <p>Default values and common alternatives used by navigable composables.</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-navigator-defaults/#types","title":"Types","text":"Name Summary DefaultDecoration [common]object DefaultDecorationThe default NavDecoration used in navigation. EmptyDecoration [common]object EmptyDecorationAn empty NavDecoration that emits the content with no surrounding decoration or logic."},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-navigator-defaults/-default-decoration/","title":"Index","text":"<p>//circuit-foundation/com.slack.circuit.foundation/NavigatorDefaults/DefaultDecoration</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-navigator-defaults/-default-decoration/#defaultdecoration","title":"DefaultDecoration","text":"<p>[common]\\ object DefaultDecoration</p> <p>The default NavDecoration used in navigation.</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-navigator-defaults/-default-decoration/#functions","title":"Functions","text":"Name Summary DecoratedContent [common]@Composableopen fun &lt;T&gt; DecoratedContent(arg: T, backStackDepth: Int, modifier: Modifier, content: @Composable(T) -&gt; Unit)"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-navigator-defaults/-default-decoration/-decorated-content/","title":"decorated content","text":"<p>//circuit-foundation/com.slack.circuit.foundation/NavigatorDefaults/DefaultDecoration/DecoratedContent</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-navigator-defaults/-default-decoration/-decorated-content/#decoratedcontent","title":"DecoratedContent","text":"<p>[common]\\</p> <p>@Composable</p> <p>open fun &lt;T&gt; DecoratedContent(arg: T, backStackDepth: Int, modifier: Modifier, content: @Composable(T) -&gt; Unit)</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-navigator-defaults/-empty-decoration/","title":"Index","text":"<p>//circuit-foundation/com.slack.circuit.foundation/NavigatorDefaults/EmptyDecoration</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-navigator-defaults/-empty-decoration/#emptydecoration","title":"EmptyDecoration","text":"<p>[common]\\ object EmptyDecoration</p> <p>An empty NavDecoration that emits the content with no surrounding decoration or logic.</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-navigator-defaults/-empty-decoration/#functions","title":"Functions","text":"Name Summary DecoratedContent [common]@Composableopen fun &lt;T&gt; DecoratedContent(arg: T, backStackDepth: Int, modifier: Modifier, content: @Composable(T) -&gt; Unit)"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-navigator-defaults/-empty-decoration/-decorated-content/","title":"decorated content","text":"<p>//circuit-foundation/com.slack.circuit.foundation/NavigatorDefaults/EmptyDecoration/DecoratedContent</p>"},{"location":"api/0.x/circuit-foundation/com.slack.circuit.foundation/-navigator-defaults/-empty-decoration/-decorated-content/#decoratedcontent","title":"DecoratedContent","text":"<p>[common]\\</p> <p>@Composable</p> <p>open fun &lt;T&gt; DecoratedContent(arg: T, backStackDepth: Int, modifier: Modifier, content: @Composable(T) -&gt; Unit)</p>"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/","title":"circuit-overlay","text":"<p>//circuit-overlay/com.slack.circuit.overlay</p>"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/#package-level-declarations","title":"Package-level declarations","text":""},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/#types","title":"Types","text":"Name Summary Overlay [common]interface Overlay&lt;Result : Any&gt;An Overlay is composable content that can be shown on top of other content via an OverlayHost . Overlays are typically used for one-off request/result flows and should not usually attempt to do any sort of external navigation or make any assumptions about the state of the app. They should only emit a Result to the given <code>OverlayNavigator</code> when they are done. OverlayHost [common]@Stableinterface OverlayHostAn OverlayHost can be used overlaysOverlay with content on top of other content. This is useful for one-off request/result flows such as: OverlayHostData [common]@Stableinterface OverlayHostData&lt;Result : Any&gt;Data managed by an OverlayHost to track the current overlay state. This should rarely be implemented by consumers! OverlayNavigator [common]@Stablefun interface OverlayNavigator&lt;Result : Any&gt;An OverlayNavigator is a simple API offered to overlays to call finish with a result when they are done."},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/#functions","title":"Functions","text":"Name Summary ContentWithOverlays [android]@Composablefun ContentWithOverlays(modifier: Modifier = Modifier, overlayHost: OverlayHost = rememberOverlayHost(), content: @Composable() -&gt; Unit)Renders the given content with the ability to show overlays on top of it. This works by exposing an OverlayHost via LocalOverlayHost. rememberOverlayHost [common]@Composablefun rememberOverlayHost(): OverlayHostReturns a remembered an OverlayHost that can be used to show overlays."},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/#properties","title":"Properties","text":"Name Summary LocalOverlayHost [common]val LocalOverlayHost: ProvidableCompositionLocal&lt;OverlayHost&gt;A ProvidableCompositionLocal to expose the current OverlayHost in the composition tree."},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-content-with-overlays/","title":"content with overlays","text":"<p>//circuit-overlay/com.slack.circuit.overlay/ContentWithOverlays</p>"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-content-with-overlays/#contentwithoverlays","title":"ContentWithOverlays","text":"<p>[android]\\</p> <p>@Composable</p> <p>fun ContentWithOverlays(modifier: Modifier = Modifier, overlayHost: OverlayHost = rememberOverlayHost(), content: @Composable() -&gt; Unit)</p> <p>Renders the given content with the ability to show overlays on top of it. This works by exposing an OverlayHost via LocalOverlayHost.</p>"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-content-with-overlays/#parameters","title":"Parameters","text":"<p>android</p> modifier The modifier to be applied to the layout. overlayHost the OverlayHost to use for managing overlays. content The regular content to render. Any overlays will be rendered over them."},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-local-overlay-host/","title":"local overlay host","text":"<p>//circuit-overlay/com.slack.circuit.overlay/LocalOverlayHost</p>"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-local-overlay-host/#localoverlayhost","title":"LocalOverlayHost","text":"<p>[common]\\ val LocalOverlayHost: ProvidableCompositionLocal&lt;OverlayHost&gt;</p> <p>A ProvidableCompositionLocal to expose the current OverlayHost in the composition tree.</p>"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/remember-overlay-host/","title":"Remember overlay host","text":"<p>//circuit-overlay/com.slack.circuit.overlay/rememberOverlayHost</p>"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/remember-overlay-host/#rememberoverlayhost","title":"rememberOverlayHost","text":"<p>[common]\\</p> <p>@Composable</p> <p>fun rememberOverlayHost(): OverlayHost</p> <p>Returns a remembered an OverlayHost that can be used to show overlays.</p>"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-overlay/","title":"Index","text":"<p>//circuit-overlay/com.slack.circuit.overlay/Overlay</p>"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-overlay/#overlay","title":"Overlay","text":"<p>[common]\\ interface Overlay&lt;Result : Any&gt;</p> <p>An Overlay is composable content that can be shown on top of other content via an OverlayHost . Overlays are typically used for one-off request/result flows and should not usually attempt to do any sort of external navigation or make any assumptions about the state of the app. They should only emit a Result to the given <code>OverlayNavigator</code> when they are done.</p> <p>For common overlays, it\u2019s useful to create a common <code>Overlay</code> subtype that can be reused. For example: <code>BottomSheetOverlay</code>, <code>ModalOverlay</code>, <code>TooltipOverlay</code>, etc.</p>"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-overlay/#functions","title":"Functions","text":"Name Summary Content [common]@Composableabstract fun Content(navigator: OverlayNavigator&lt;Result&gt;)"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-overlay/-content/","title":"content","text":"<p>//circuit-overlay/com.slack.circuit.overlay/Overlay/Content</p>"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-overlay/-content/#content","title":"Content","text":"<p>[common]\\</p> <p>@Composable</p> <p>abstract fun Content(navigator: OverlayNavigator&lt;Result&gt;)</p>"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-overlay-host/","title":"Index","text":"<p>//circuit-overlay/com.slack.circuit.overlay/OverlayHost</p>"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-overlay-host/#overlayhost","title":"OverlayHost","text":"<p>[common]\\ @Stable</p> <p>interface OverlayHost</p> <p>An OverlayHost can be used overlaysOverlay with content on top of other content. This is useful for one-off request/result flows such as:</p> <ul> <li>Bottom sheets</li> <li>Modals/dialogs</li> <li>Tooltips</li> <li>Full-screen takeover prompts</li> <li>etc.</li> </ul> <p>The suspend show function is generically typed and can be suspended on to await the result of whatever overlay was launched.</p> <p>currentOverlayData is read-only and can be used to observe the current overlay data. This is generally intended to be used wherever the OverlayHost is provided via LocalOverlayHost.</p> <p>In Android, this can be managed via the <code>ContentWithOverlays</code> composable function.</p> <p>To avoid accidentally capturing unnecessary state, it\u2019s recommended to create extension functions on <code>OverlayHost</code> that call show with the appropriate overlay and result type.</p> <pre><code>private suspend fun OverlayHost.confirm(message: String): ConfirmationResult {\nreturn show(ConfirmationOverlay(message))\n}\n</code></pre>"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-overlay-host/#functions","title":"Functions","text":"Name Summary show [common]abstract suspend fun &lt;Result : Any&gt; show(overlay: Overlay&lt;Result&gt;): ResultShows the given overlay and suspends until the overlay is finished with a Result. The overlay should always signal a result (even if it\u2019s just something like <code>Result.Dismissed</code>) so that the OverlayHost can properly clear its currentOverlayData."},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-overlay-host/#properties","title":"Properties","text":"Name Summary currentOverlayData [common]abstract val currentOverlayData: OverlayHostData&lt;Any&gt;?The current OverlayHostData or null if no overlay is currently showing."},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-overlay-host/current-overlay-data/","title":"Current overlay data","text":"<p>//circuit-overlay/com.slack.circuit.overlay/OverlayHost/currentOverlayData</p>"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-overlay-host/current-overlay-data/#currentoverlaydata","title":"currentOverlayData","text":"<p>[common]\\ abstract val currentOverlayData: OverlayHostData&lt;Any&gt;?</p> <p>The current OverlayHostData or null if no overlay is currently showing.</p> <pre><code>val overlayHostData by rememberUpdatedState(overlayHost.currentOverlayData)\nBox(modifier) {\ncontent() // The regular content\nkey(overlayHostData) { overlayHostData?.let { data -&gt; data.overlay.Content(data::finish) } }\n}\n</code></pre>"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-overlay-host/show/","title":"Show","text":"<p>//circuit-overlay/com.slack.circuit.overlay/OverlayHost/show</p>"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-overlay-host/show/#show","title":"show","text":"<p>[common]\\ abstract suspend fun &lt;Result : Any&gt; show(overlay: Overlay&lt;Result&gt;): Result</p> <p>Shows the given overlay and suspends until the overlay is finished with a Result. The overlay should always signal a result (even if it\u2019s just something like <code>Result.Dismissed</code>) so that the OverlayHost can properly clear its currentOverlayData.</p> <p>If no data is needed in a result, use Unit for the result type.</p> <p>This function should only be called from UI contexts and not presenters, as overlays are a UI concern.</p>"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-overlay-host-data/","title":"Index","text":"<p>//circuit-overlay/com.slack.circuit.overlay/OverlayHostData</p>"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-overlay-host-data/#overlayhostdata","title":"OverlayHostData","text":"<p>[common]\\ @Stable</p> <p>interface OverlayHostData&lt;Result : Any&gt;</p> <p>Data managed by an OverlayHost to track the current overlay state. This should rarely be implemented by consumers!</p>"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-overlay-host-data/#functions","title":"Functions","text":"Name Summary finish [common]abstract fun finish(result: Result)Invoked to finish the current overlay with the given result. This should be called by wherever the OverlayHost is being managed."},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-overlay-host-data/#properties","title":"Properties","text":"Name Summary overlay [common]abstract val overlay: Overlay&lt;Result&gt;The Overlay that is currently being shown. Read-only."},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-overlay-host-data/finish/","title":"Finish","text":"<p>//circuit-overlay/com.slack.circuit.overlay/OverlayHostData/finish</p>"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-overlay-host-data/finish/#finish","title":"finish","text":"<p>[common]\\ abstract fun finish(result: Result)</p> <p>Invoked to finish the current overlay with the given result. This should be called by wherever the OverlayHost is being managed.</p>"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-overlay-host-data/overlay/","title":"Overlay","text":"<p>//circuit-overlay/com.slack.circuit.overlay/OverlayHostData/overlay</p>"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-overlay-host-data/overlay/#overlay","title":"overlay","text":"<p>[common]\\ abstract val overlay: Overlay&lt;Result&gt;</p> <p>The Overlay that is currently being shown. Read-only.</p>"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-overlay-navigator/","title":"Index","text":"<p>//circuit-overlay/com.slack.circuit.overlay/OverlayNavigator</p>"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-overlay-navigator/#overlaynavigator","title":"OverlayNavigator","text":"<p>[common]\\ @Stable</p> <p>fun interface OverlayNavigator&lt;Result : Any&gt;</p> <p>An OverlayNavigator is a simple API offered to overlays to call finish with a result when they are done.</p>"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-overlay-navigator/#functions","title":"Functions","text":"Name Summary finish [common]abstract fun finish(result: Result)Called by the Overlay with a result it\u2019s done."},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-overlay-navigator/finish/","title":"Finish","text":"<p>//circuit-overlay/com.slack.circuit.overlay/OverlayNavigator/finish</p>"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-overlay-navigator/finish/#finish","title":"finish","text":"<p>[common]\\ abstract fun finish(result: Result)</p> <p>Called by the Overlay with a result it\u2019s done.</p>"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/","title":"circuit-retained","text":"<p>//circuit-retained/com.slack.circuit.retained</p>"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/#package-level-declarations","title":"Package-level declarations","text":""},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/#types","title":"Types","text":"Name Summary RetainedStateRegistry [common]interface RetainedStateRegistryAllows components to save and restore their state using the <code>onRetainNonConfigurationInstance</code> mechanism."},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/#functions","title":"Functions","text":"Name Summary continuityRetainedStateRegistry [android]@Composablefun continuityRetainedStateRegistry(factory: ViewModelProvider.Factory = Continuity.Factory): RetainedStateRegistryProvides a RetainedStateRegistry. produceRetainedState [common]@Composablefun &lt;T&gt; produceRetainedState(initialValue: T, producer: suspend ProduceStateScope&lt;T&gt;.() -&gt; Unit): State&lt;T&gt;Return an observable snapshotState that produces values over time without a defined data source.[common]@Composablefun &lt;T&gt; produceRetainedState(initialValue: T, key1: Any?, producer: suspend ProduceStateScope&lt;T&gt;.() -&gt; Unit): State&lt;T&gt;Return an observable snapshotState that produces values over time from key1.[common]@Composablefun &lt;T&gt; produceRetainedState(initialValue: T, vararg keys: Any?, producer: suspend ProduceStateScope&lt;T&gt;.() -&gt; Unit): State&lt;T&gt;Return an observable snapshotState that produces values over time from keys.[common]@Composablefun &lt;T&gt; produceRetainedState(initialValue: T, key1: Any?, key2: Any?, producer: suspend ProduceStateScope&lt;T&gt;.() -&gt; Unit): State&lt;T&gt;Return an observable snapshotState that produces values over time from key1 and key2.[common]@Composablefun &lt;T&gt; produceRetainedState(initialValue: T, key1: Any?, key2: Any?, key3: Any?, producer: suspend ProduceStateScope&lt;T&gt;.() -&gt; Unit): State&lt;T&gt;Return an observable snapshotState that produces values over time from key1, key2 and key3. rememberRetained [common]@Composablefun &lt;T : Any&gt; rememberRetained(vararg inputs: Any?, key: String? = null, init: () -&gt; T): TRemember the value produced by init. RetainedStateRegistry [common]fun RetainedStateRegistry(values: Map&lt;String, List&lt;Any?&gt;&gt;?): RetainedStateRegistryCreates RetainedStateRegistry."},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/#properties","title":"Properties","text":"Name Summary LocalRetainedStateRegistry [common]val LocalRetainedStateRegistry: ProvidableCompositionLocal&lt;RetainedStateRegistry&gt;CompositionLocal with a current RetainedStateRegistry instance."},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-local-retained-state-registry/","title":"local retained state registry","text":"<p>//circuit-retained/com.slack.circuit.retained/LocalRetainedStateRegistry</p>"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-local-retained-state-registry/#localretainedstateregistry","title":"LocalRetainedStateRegistry","text":"<p>[common]\\ val LocalRetainedStateRegistry: ProvidableCompositionLocal&lt;RetainedStateRegistry&gt;</p> <p>CompositionLocal with a current RetainedStateRegistry instance.</p>"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/","title":"retained state registry","text":"<p>//circuit-retained/com.slack.circuit.retained/RetainedStateRegistry</p>"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/#retainedstateregistry","title":"RetainedStateRegistry","text":"<p>[common]\\ fun RetainedStateRegistry(values: Map&lt;String, List&lt;Any?&gt;&gt;?): RetainedStateRegistry</p> <p>Creates RetainedStateRegistry.</p>"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/#parameters","title":"Parameters","text":"<p>common</p> values The map of the restored values"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/continuity-retained-state-registry/","title":"Continuity retained state registry","text":"<p>//circuit-retained/com.slack.circuit.retained/continuityRetainedStateRegistry</p>"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/continuity-retained-state-registry/#continuityretainedstateregistry","title":"continuityRetainedStateRegistry","text":"<p>[android]\\</p> <p>@Composable</p> <p>fun continuityRetainedStateRegistry(factory: ViewModelProvider.Factory = Continuity.Factory): RetainedStateRegistry</p> <p>Provides a RetainedStateRegistry.</p>"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/continuity-retained-state-registry/#parameters","title":"Parameters","text":"<p>android</p> factory an optional ViewModelProvider.Factory to use when creating the Continuity instance."},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/produce-retained-state/","title":"Produce retained state","text":"<p>//circuit-retained/com.slack.circuit.retained/produceRetainedState</p>"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/produce-retained-state/#produceretainedstate","title":"produceRetainedState","text":"<p>[common]\\</p> <p>@Composable</p> <p>fun &lt;T&gt; produceRetainedState(initialValue: T, producer: suspend ProduceStateScope&lt;T&gt;.() -&gt; Unit): State&lt;T&gt;</p> <p>Return an observable snapshotState that produces values over time without a defined data source.</p> <p>producer is launched when produceRetainedState enters the composition and is cancelled when produceRetainedState leaves the composition. producer should use ProduceStateScope.value to set new values on the returned State.</p> <p>The returned State conflates values; no change will be observable if ProduceStateScope.value is used to set a value that is equal to its old value, and observers may only see the latest value if several values are set in rapid succession.</p> <p>produceRetainedState may be used to observe either suspending or non-suspending sources of external data, for example:</p> <pre><code>@Composable\nfun FavoritesPresenter(favoritesRepository: FavoritesRepository): State {\nval state by produceRetainedState&lt;UiState&lt;List&lt;Person&gt;&gt;&gt;(UiState.Loading, favoritesRepository) {\nfavoritesRepository.people\n.map { UiState.Data(it) }\n.collect { value = it }\n}\nreturn state\n}\n</code></pre> <p>[common]\\</p> <p>@Composable</p> <p>fun &lt;T&gt; produceRetainedState(initialValue: T, key1: Any?, producer: suspend ProduceStateScope&lt;T&gt;.() -&gt; Unit): State&lt;T&gt;</p> <p>Return an observable snapshotState that produces values over time from key1.</p> <p>producer is launched when produceRetainedState enters the composition and is cancelled when produceRetainedState leaves the composition. If key1 changes, a running producer will be cancelled and re-launched for the new source. producer should use ProduceStateScope.value to set new values on the returned State.</p> <p>The returned State conflates values; no change will be observable if ProduceStateScope.value is used to set a value that is equal to its old value, and observers may only see the latest value if several values are set in rapid succession.</p> <p>produceRetainedState may be used to observe either suspending or non-suspending sources of external data, for example:</p> <pre><code>@Composable\nfun FavoritesPresenter(favoritesRepository: FavoritesRepository): State {\nval state by produceRetainedState&lt;UiState&lt;List&lt;Person&gt;&gt;&gt;(UiState.Loading, favoritesRepository) {\nfavoritesRepository.people\n.map { UiState.Data(it) }\n.collect { value = it }\n}\nreturn state\n}\n</code></pre> <p>[common]\\</p> <p>@Composable</p> <p>fun &lt;T&gt; produceRetainedState(initialValue: T, key1: Any?, key2: Any?, producer: suspend ProduceStateScope&lt;T&gt;.() -&gt; Unit): State&lt;T&gt;</p> <p>Return an observable snapshotState that produces values over time from key1 and key2.</p> <p>producer is launched when produceRetainedState enters the composition and is cancelled when produceRetainedState leaves the composition. If key1 or key2 change, a running producer will be cancelled and re-launched for the new source. producer should use ProduceStateScope.value to set new values on the returned State.</p> <p>The returned State conflates values; no change will be observable if ProduceStateScope.value is used to set a value that is equal to its old value, and observers may only see the latest value if several values are set in rapid succession.</p> <p>produceRetainedState may be used to observe either suspending or non-suspending sources of external data, for example:</p> <pre><code>@Composable\nfun FavoritesPresenter(favoritesRepository: FavoritesRepository): State {\nval state by produceRetainedState&lt;UiState&lt;List&lt;Person&gt;&gt;&gt;(UiState.Loading, favoritesRepository) {\nfavoritesRepository.people\n.map { UiState.Data(it) }\n.collect { value = it }\n}\nreturn state\n}\n</code></pre> <p>[common]\\</p> <p>@Composable</p> <p>fun &lt;T&gt; produceRetainedState(initialValue: T, key1: Any?, key2: Any?, key3: Any?, producer: suspend ProduceStateScope&lt;T&gt;.() -&gt; Unit): State&lt;T&gt;</p> <p>Return an observable snapshotState that produces values over time from key1, key2 and key3.</p> <p>producer is launched when produceRetainedState enters the composition and is cancelled when produceRetainedState leaves the composition. If key1, key2 or key3 change, a running producer will be cancelled and re-launched for the new source. [producer should use ProduceStateScope.value to set new values on the returned State.</p> <p>The returned State conflates values; no change will be observable if ProduceStateScope.value is used to set a value that is equal to its old value, and observers may only see the latest value if several values are set in rapid succession.</p> <p>produceRetainedState may be used to observe either suspending or non-suspending sources of external data, for example:</p> <pre><code>@Composable\nfun FavoritesPresenter(favoritesRepository: FavoritesRepository): State {\nval state by produceRetainedState&lt;UiState&lt;List&lt;Person&gt;&gt;&gt;(UiState.Loading, favoritesRepository) {\nfavoritesRepository.people\n.map { UiState.Data(it) }\n.collect { value = it }\n}\nreturn state\n}\n</code></pre> <p>[common]\\</p> <p>@Composable</p> <p>fun &lt;T&gt; produceRetainedState(initialValue: T, vararg keys: Any?, producer: suspend ProduceStateScope&lt;T&gt;.() -&gt; Unit): State&lt;T&gt;</p> <p>Return an observable snapshotState that produces values over time from keys.</p> <p>producer is launched when produceRetainedState enters the composition and is cancelled when produceRetainedState leaves the composition. If keys change, a running producer will be cancelled and re-launched for the new source. producer should use ProduceStateScope.value to set new values on the returned State.</p> <p>The returned State conflates values; no change will be observable if ProduceStateScope.value is used to set a value that is equal to its old value, and observers may only see the latest value if several values are set in rapid succession.</p> <p>produceRetainedState may be used to observe either suspending or non-suspending sources of external data, for example:</p> <pre><code>@Composable\nfun FavoritesPresenter(favoritesRepository: FavoritesRepository): State {\nval state by produceRetainedState&lt;UiState&lt;List&lt;Person&gt;&gt;&gt;(UiState.Loading, favoritesRepository) {\nfavoritesRepository.people\n.map { UiState.Data(it) }\n.collect { value = it }\n}\nreturn state\n}\n</code></pre>"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/remember-retained/","title":"Remember retained","text":"<p>//circuit-retained/com.slack.circuit.retained/rememberRetained</p>"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/remember-retained/#rememberretained","title":"rememberRetained","text":"<p>[common]\\</p> <p>@Composable</p> <p>fun &lt;T : Any&gt; rememberRetained(vararg inputs: Any?, key: String? = null, init: () -&gt; T): T</p> <p>Remember the value produced by init.</p> <p>It behaves similarly to remember, but the stored value will survive configuration changes, such as a screen rotation.</p> <p>You can use it with a value stored inside androidx.compose.runtime.mutableStateOf.</p> <p>This differs from <code>rememberSaveable</code> by not being tied to Android bundles or parcelable. You should take care to ensure that the state computed by init does not capture anything that is not save to persist across reconfiguration, such as Navigators. The same caveats of <code>rememberSaveable</code> also still apply (i.e. do not retain Android Contexts, Views, etc).</p> <p>However, it does not participate in saved instance state either, so care should be taken to choose the right retention mechanism for your use case. Consider the below two examples.</p> <p>The first case will retain <code>state</code> across configuration changes but will not survive process death.</p> <pre><code>@Composable\noverride fun present(): CounterState {\nvar state by rememberRetained { mutableStateOf(CounterState(0)) }\n\nreturn CounterState(count) { event -&gt;\nwhen (event) {\nis CounterEvent.Increment -&gt; state = state.copy(count = state.count + 1)\nis CounterEvent.Decrement -&gt; state = state.copy(count = state.count - 1)\n}\n}\n}\n</code></pre> <p>This second case will retain <code>count</code> across configuration changes and survive process death. However, it only works with primitives or <code>Parcelable</code> state types.</p> <pre><code>@Composable\noverride fun present(): CounterState {\nvar count by rememberSaveable { mutableStateOf(0) }\n\nreturn CounterState(count) { event -&gt;\nwhen (event) {\nis CounterEvent.Increment -&gt; state = count++\nis CounterEvent.Decrement -&gt; state = count--\n}\n}\n}\n</code></pre>"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/remember-retained/#parameters","title":"Parameters","text":"<p>common</p> inputs A set of inputs such that, when any of them have changed, will cause the state to reset and init to be rerun key An optional key to be used as a key for the saved value. If not provided we use the automatically generated by the Compose runtime which is unique for the every exact code location in the composition tree init A factory function to create the initial value of this state"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/","title":"Index","text":"<p>//circuit-retained/com.slack.circuit.retained/RetainedStateRegistry</p>"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/#retainedstateregistry","title":"RetainedStateRegistry","text":"<p>[common]\\ interface RetainedStateRegistry</p> <p>Allows components to save and restore their state using the <code>onRetainNonConfigurationInstance</code> mechanism.</p>"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/#types","title":"Types","text":"Name Summary Entry [common]interface EntryThe registry entry which you get when you use registerValue."},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/#functions","title":"Functions","text":"Name Summary consumeValue [common]abstract fun consumeValue(key: String): Any?Returns the restored value for the given key. Once being restored the value is cleared, so you can\u2019t restore the same key twice. forgetUnclaimedValues [common]abstract fun forgetUnclaimedValues()Releases all currently unconsumed values. Useful as a GC mechanism for the registry. performSave [common]abstract fun performSave()Executes all the registered value providers and combines these values into a map. We have a list of values for each key as it is allowed to have multiple providers for the same key. registerValue [common]abstract fun registerValue(key: String, valueProvider: () -&gt; Any?): RetainedStateRegistry.EntryRegisters the value provider."},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/consume-value/","title":"Consume value","text":"<p>//circuit-retained/com.slack.circuit.retained/RetainedStateRegistry/consumeValue</p>"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/consume-value/#consumevalue","title":"consumeValue","text":"<p>[common]\\ abstract fun consumeValue(key: String): Any?</p> <p>Returns the restored value for the given key. Once being restored the value is cleared, so you can\u2019t restore the same key twice.</p>"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/consume-value/#parameters","title":"Parameters","text":"<p>common</p> key Key used to save the value"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/forget-unclaimed-values/","title":"Forget unclaimed values","text":"<p>//circuit-retained/com.slack.circuit.retained/RetainedStateRegistry/forgetUnclaimedValues</p>"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/forget-unclaimed-values/#forgetunclaimedvalues","title":"forgetUnclaimedValues","text":"<p>[common]\\ abstract fun forgetUnclaimedValues()</p> <p>Releases all currently unconsumed values. Useful as a GC mechanism for the registry.</p>"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/perform-save/","title":"Perform save","text":"<p>//circuit-retained/com.slack.circuit.retained/RetainedStateRegistry/performSave</p>"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/perform-save/#performsave","title":"performSave","text":"<p>[common]\\ abstract fun performSave()</p> <p>Executes all the registered value providers and combines these values into a map. We have a list of values for each key as it is allowed to have multiple providers for the same key.</p>"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/register-value/","title":"Register value","text":"<p>//circuit-retained/com.slack.circuit.retained/RetainedStateRegistry/registerValue</p>"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/register-value/#registervalue","title":"registerValue","text":"<p>[common]\\ abstract fun registerValue(key: String, valueProvider: () -&gt; Any?): RetainedStateRegistry.Entry</p> <p>Registers the value provider.</p> <p>There are could be multiple providers registered for the same key. In this case the order in which they were registered matters.</p> <p>Say we registered two values for the key. One provides \"1\", second provides \"2\". this case will have listOf(\"1\", \"2) as a value for the key in the underlying map. And later, when the registry will be recreated with the previously saved values, the first execution of consumeValue would consume \"1\" and the second one \"2\".</p>"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/register-value/#return","title":"Return","text":"<p>the registry entry which you can use to unregister the provider</p>"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/register-value/#parameters","title":"Parameters","text":"<p>common</p> key Key to use for storing the value valueProvider The value to provide"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/-entry/","title":"Index","text":"<p>//circuit-retained/com.slack.circuit.retained/RetainedStateRegistry/Entry</p>"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/-entry/#entry","title":"Entry","text":"<p>[common]\\ interface Entry</p> <p>The registry entry which you get when you use registerValue.</p>"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/-entry/#functions","title":"Functions","text":"Name Summary unregister [common]abstract fun unregister()Unregister previously registered entry."},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/-entry/unregister/","title":"Unregister","text":"<p>//circuit-retained/com.slack.circuit.retained/RetainedStateRegistry/Entry/unregister</p>"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/-entry/unregister/#unregister","title":"unregister","text":"<p>[common]\\ abstract fun unregister()</p> <p>Unregister previously registered entry.</p>"},{"location":"api/0.x/circuit-runtime/com.slack.circuit.runtime/","title":"Index","text":"<p>//circuit-runtime/com.slack.circuit.runtime</p>"},{"location":"api/0.x/circuit-runtime/com.slack.circuit.runtime/#package-level-declarations","title":"Package-level declarations","text":""},{"location":"api/0.x/circuit-runtime/com.slack.circuit.runtime/#types","title":"Types","text":"Name Summary CircuitContext [common]class CircuitContextconstructor(val parent: CircuitContext?)A CircuitContext is used in <code>Presenter.Factory</code> and <code>Ui.Factory</code> to inform creation of their respective <code>Presenter</code> and <code>Ui</code> instances. CircuitUiEvent [common]@Immutableinterface CircuitUiEventMarker interface for all UiEvent types. CircuitUiState [common]@Stableinterface CircuitUiStateMarker interface for all UiState types. InternalCircuitApi [common]@Target(allowedTargets = [AnnotationTarget.CLASS, AnnotationTarget.FUNCTION, AnnotationTarget.TYPEALIAS, AnnotationTarget.PROPERTY, AnnotationTarget.CONSTRUCTOR])annotation class InternalCircuitApiMarks declarations that are internal in Circuit API, which means that should not be used outside of <code>com.slack.circuit</code>, because their signatures and semantics will change between future releases without any warnings and without providing any migration aids. Navigator [common]@Stableinterface NavigatorA basic navigation interface for navigating between screens. Screen [common]@Immutableexpect interface ScreenRepresents an individual screen, used as a key for <code>Presenter.Factory</code> and <code>Ui.Factory</code>.[android, jvm][android]@Immutableactual interface Screen : Parcelable[jvm]@Immutableactual interface Screen"},{"location":"api/0.x/circuit-runtime/com.slack.circuit.runtime/#functions","title":"Functions","text":"Name Summary popUntil [common]fun Navigator.popUntil(predicate: (Screen) -&gt; Boolean)Calls Navigator.pop until the given predicate is matched or it pops the root."},{"location":"api/0.x/circuit-runtime/com.slack.circuit.runtime/pop-until/","title":"Pop until","text":"<p>//circuit-runtime/com.slack.circuit.runtime/popUntil</p>"},{"location":"api/0.x/circuit-runtime/com.slack.circuit.runtime/pop-until/#popuntil","title":"popUntil","text":"<p>[common]\\ fun Navigator.popUntil(predicate: (Screen) -&gt; Boolean)</p> <p>Calls Navigator.pop until the given predicate is matched or it pops the root.</p>"},{"location":"api/0.x/circuit-runtime/com.slack.circuit.runtime/-circuit-context/","title":"Index","text":"<p>//circuit-runtime/com.slack.circuit.runtime/CircuitContext</p>"},{"location":"api/0.x/circuit-runtime/com.slack.circuit.runtime/-circuit-context/#circuitcontext","title":"CircuitContext","text":"<p>[common]\\ class CircuitContextconstructor(val parent: CircuitContext?)</p> <p>A CircuitContext is used in <code>Presenter.Factory</code> and <code>Ui.Factory</code> to inform creation of their respective <code>Presenter</code> and <code>Ui</code> instances.</p> <p>Available information includes:</p> <ul> <li>parent \u2013 the parent CircuitContext or null if this is the root context.</li> <li>tag \u2013 a tag API to plumb arbitrary metadata through the CircuitContext.</li> </ul>"},{"location":"api/0.x/circuit-runtime/com.slack.circuit.runtime/-circuit-context/#constructors","title":"Constructors","text":"CircuitContext [common]constructor(parent: CircuitContext?)"},{"location":"api/0.x/circuit-runtime/com.slack.circuit.runtime/-circuit-context/#functions","title":"Functions","text":"Name Summary clearTags [common]fun clearTags()Clears all the current tags. putTag [common]inline fun &lt;T : Any&gt; putTag(tag: T?)Attaches tag to the request using T as a key. Tags can be read from a request using CircuitContext.tag. Use <code>null</code> to remove any existing tag assigned for T.[common]fun &lt;S : Any, T : S&gt; putTag(type: KClass&lt;S&gt;, tag: T?)Attaches tag to the request using type as a key. Tags can be read from a request using CircuitContext.tag. Use <code>null</code> to remove any existing tag assigned for type. tag [common]inline fun &lt;T : Any&gt; tag(): T?Returns the tag attached with T as a key, or null if no tag is attached with that key.[common]fun &lt;T : Any&gt; tag(type: KClass&lt;T&gt;): T?Returns the tag attached with type as a key, or null if no tag is attached with that key."},{"location":"api/0.x/circuit-runtime/com.slack.circuit.runtime/-circuit-context/#properties","title":"Properties","text":"Name Summary parent [common]val parent: CircuitContext?"},{"location":"api/0.x/circuit-runtime/com.slack.circuit.runtime/-circuit-context/-circuit-context/","title":"circuit context","text":"<p>//circuit-runtime/com.slack.circuit.runtime/CircuitContext/CircuitContext</p>"},{"location":"api/0.x/circuit-runtime/com.slack.circuit.runtime/-circuit-context/-circuit-context/#circuitcontext","title":"CircuitContext","text":"<p>[common]\\ constructor(parent: CircuitContext?)</p>"},{"location":"api/0.x/circuit-runtime/com.slack.circuit.runtime/-circuit-context/clear-tags/","title":"Clear tags","text":"<p>//circuit-runtime/com.slack.circuit.runtime/CircuitContext/clearTags</p>"},{"location":"api/0.x/circuit-runtime/com.slack.circuit.runtime/-circuit-context/clear-tags/#cleartags","title":"clearTags","text":"<p>[common]\\ fun clearTags()</p> <p>Clears all the current tags.</p>"},{"location":"api/0.x/circuit-runtime/com.slack.circuit.runtime/-circuit-context/parent/","title":"Parent","text":"<p>//circuit-runtime/com.slack.circuit.runtime/CircuitContext/parent</p>"},{"location":"api/0.x/circuit-runtime/com.slack.circuit.runtime/-circuit-context/parent/#parent","title":"parent","text":"<p>[common]\\ val parent: CircuitContext?</p>"},{"location":"api/0.x/circuit-runtime/com.slack.circuit.runtime/-circuit-context/put-tag/","title":"Put tag","text":"<p>//circuit-runtime/com.slack.circuit.runtime/CircuitContext/putTag</p>"},{"location":"api/0.x/circuit-runtime/com.slack.circuit.runtime/-circuit-context/put-tag/#puttag","title":"putTag","text":"<p>[common]\\ inline fun &lt;T : Any&gt; putTag(tag: T?)</p> <p>Attaches tag to the request using T as a key. Tags can be read from a request using CircuitContext.tag. Use <code>null</code> to remove any existing tag assigned for T.</p> <p>Use this API to attach metadata, debugging, or other application data to a spec so that you may read it in other APIs or callbacks.</p> <p>[common]\\ fun &lt;S : Any, T : S&gt; putTag(type: KClass&lt;S&gt;, tag: T?)</p> <p>Attaches tag to the request using type as a key. Tags can be read from a request using CircuitContext.tag. Use <code>null</code> to remove any existing tag assigned for type.</p> <p>Use this API to attach metadata, debugging, or other application data to a spec so that you may read it in other APIs or callbacks.</p>"},{"location":"api/0.x/circuit-runtime/com.slack.circuit.runtime/-circuit-context/tag/","title":"Tag","text":"<p>//circuit-runtime/com.slack.circuit.runtime/CircuitContext/tag</p>"},{"location":"api/0.x/circuit-runtime/com.slack.circuit.runtime/-circuit-context/tag/#tag","title":"tag","text":"<p>[common]\\ fun &lt;T : Any&gt; tag(type: KClass&lt;T&gt;): T?</p> <p>Returns the tag attached with type as a key, or null if no tag is attached with that key.</p> <p>[common]\\ inline fun &lt;T : Any&gt; tag(): T?</p> <p>Returns the tag attached with T as a key, or null if no tag is attached with that key.</p>"},{"location":"api/0.x/circuit-runtime/com.slack.circuit.runtime/-circuit-ui-event/","title":"Index","text":"<p>//circuit-runtime/com.slack.circuit.runtime/CircuitUiEvent</p>"},{"location":"api/0.x/circuit-runtime/com.slack.circuit.runtime/-circuit-ui-event/#circuituievent","title":"CircuitUiEvent","text":"<p>[common]\\ @Immutable</p> <p>interface CircuitUiEvent</p> <p>Marker interface for all UiEvent types.</p> <p>Events in Circuit should generally reflect user interactions with the UI. They are mediated by a <code>Presenter</code> and may or may not influence the current state.</p> <p>Circuit event types are annotated as @Immutable and should only use immutable properties.</p>"},{"location":"api/0.x/circuit-runtime/com.slack.circuit.runtime/-circuit-ui-state/","title":"Index","text":"<p>//circuit-runtime/com.slack.circuit.runtime/CircuitUiState</p>"},{"location":"api/0.x/circuit-runtime/com.slack.circuit.runtime/-circuit-ui-state/#circuituistate","title":"CircuitUiState","text":"<p>[common]\\ @Stable</p> <p>interface CircuitUiState</p> <p>Marker interface for all UiState types.</p> <p>States in Circuit should be minimal data models that a <code>Ui</code> can render. They are produced by a <code>Presenter</code> that interpret the underlying data layer and mediate input user/nav events.</p> <p><code>Ui</code>s receive state as a parameter and should act as pure functions that render the input state as a UI. They should not have any side effects or directly interact with the underlying data layer.</p> <p>Circuit state types are annotated as @Stable and should only use stable properties.</p>"},{"location":"api/0.x/circuit-runtime/com.slack.circuit.runtime/-internal-circuit-api/","title":"Index","text":"<p>//circuit-runtime/com.slack.circuit.runtime/InternalCircuitApi</p>"},{"location":"api/0.x/circuit-runtime/com.slack.circuit.runtime/-internal-circuit-api/#internalcircuitapi","title":"InternalCircuitApi","text":"<p>[common]\\ @Target(allowedTargets = [AnnotationTarget.CLASS, AnnotationTarget.FUNCTION, AnnotationTarget.TYPEALIAS, AnnotationTarget.PROPERTY, AnnotationTarget.CONSTRUCTOR])</p> <p>annotation class InternalCircuitApi</p> <p>Marks declarations that are internal in Circuit API, which means that should not be used outside of <code>com.slack.circuit</code>, because their signatures and semantics will change between future releases without any warnings and without providing any migration aids.</p>"},{"location":"api/0.x/circuit-runtime/com.slack.circuit.runtime/-navigator/","title":"Index","text":"<p>//circuit-runtime/com.slack.circuit.runtime/Navigator</p>"},{"location":"api/0.x/circuit-runtime/com.slack.circuit.runtime/-navigator/#navigator","title":"Navigator","text":"<p>@Stable</p> <p>interface Navigator</p> <p>A basic navigation interface for navigating between screens.</p>"},{"location":"api/0.x/circuit-runtime/com.slack.circuit.runtime/-navigator/#inheritors","title":"Inheritors","text":"NoOp"},{"location":"api/0.x/circuit-runtime/com.slack.circuit.runtime/-navigator/#types","title":"Types","text":"Name Summary NoOp [common]object NoOp : Navigator"},{"location":"api/0.x/circuit-runtime/com.slack.circuit.runtime/-navigator/#functions","title":"Functions","text":"Name Summary goTo [common]abstract fun goTo(screen: Screen) pop [common]abstract fun pop(): Screen? popUntil [common]fun Navigator.popUntil(predicate: (Screen) -&gt; Boolean)Calls Navigator.pop until the given predicate is matched or it pops the root. resetRoot [common]abstract fun resetRoot(newRoot: Screen): List&lt;Screen&gt;Clear the existing backstack of screens and navigate to newRoot."},{"location":"api/0.x/circuit-runtime/com.slack.circuit.runtime/-navigator/go-to/","title":"Go to","text":"<p>//circuit-runtime/com.slack.circuit.runtime/Navigator/goTo</p>"},{"location":"api/0.x/circuit-runtime/com.slack.circuit.runtime/-navigator/go-to/#goto","title":"goTo","text":"<p>[common]\\ abstract fun goTo(screen: Screen)</p>"},{"location":"api/0.x/circuit-runtime/com.slack.circuit.runtime/-navigator/pop/","title":"Pop","text":"<p>//circuit-runtime/com.slack.circuit.runtime/Navigator/pop</p>"},{"location":"api/0.x/circuit-runtime/com.slack.circuit.runtime/-navigator/pop/#pop","title":"pop","text":"<p>[common]\\ abstract fun pop(): Screen?</p>"},{"location":"api/0.x/circuit-runtime/com.slack.circuit.runtime/-navigator/reset-root/","title":"Reset root","text":"<p>//circuit-runtime/com.slack.circuit.runtime/Navigator/resetRoot</p>"},{"location":"api/0.x/circuit-runtime/com.slack.circuit.runtime/-navigator/reset-root/#resetroot","title":"resetRoot","text":"<p>[common]\\ abstract fun resetRoot(newRoot: Screen): List&lt;Screen&gt;</p> <p>Clear the existing backstack of screens and navigate to newRoot.</p> <p>This is useful in preventing the user from returning to a completed workflow, such as a tutorial, wizard, or authentication flow.</p> <p>Example</p> <pre><code>val navigator = Navigator()\nnavigator.push(LoginScreen1)\nnavigator.push(LoginScreen2)\n\n// Login flow is complete. Wipe backstack and set new root screen\nval loginScreens = navigator.resetRoot(HomeScreen)\n</code></pre>"},{"location":"api/0.x/circuit-runtime/com.slack.circuit.runtime/-navigator/-no-op/","title":"Index","text":"<p>//circuit-runtime/com.slack.circuit.runtime/Navigator/NoOp</p>"},{"location":"api/0.x/circuit-runtime/com.slack.circuit.runtime/-navigator/-no-op/#noop","title":"NoOp","text":"<p>[common]\\ object NoOp : Navigator</p>"},{"location":"api/0.x/circuit-runtime/com.slack.circuit.runtime/-navigator/-no-op/#functions","title":"Functions","text":"Name Summary goTo [common]open override fun goTo(screen: Screen) pop [common]open override fun pop(): Screen? popUntil [common]fun Navigator.popUntil(predicate: (Screen) -&gt; Boolean)Calls Navigator.pop until the given predicate is matched or it pops the root. resetRoot [common]open override fun resetRoot(newRoot: Screen): List&lt;Screen&gt;Clear the existing backstack of screens and navigate to newRoot."},{"location":"api/0.x/circuit-runtime/com.slack.circuit.runtime/-navigator/-no-op/go-to/","title":"Go to","text":"<p>//circuit-runtime/com.slack.circuit.runtime/Navigator/NoOp/goTo</p>"},{"location":"api/0.x/circuit-runtime/com.slack.circuit.runtime/-navigator/-no-op/go-to/#goto","title":"goTo","text":"<p>[common]\\ open override fun goTo(screen: Screen)</p>"},{"location":"api/0.x/circuit-runtime/com.slack.circuit.runtime/-navigator/-no-op/pop/","title":"Pop","text":"<p>//circuit-runtime/com.slack.circuit.runtime/Navigator/NoOp/pop</p>"},{"location":"api/0.x/circuit-runtime/com.slack.circuit.runtime/-navigator/-no-op/pop/#pop","title":"pop","text":"<p>[common]\\ open override fun pop(): Screen?</p>"},{"location":"api/0.x/circuit-runtime/com.slack.circuit.runtime/-navigator/-no-op/reset-root/","title":"Reset root","text":"<p>//circuit-runtime/com.slack.circuit.runtime/Navigator/NoOp/resetRoot</p>"},{"location":"api/0.x/circuit-runtime/com.slack.circuit.runtime/-navigator/-no-op/reset-root/#resetroot","title":"resetRoot","text":"<p>[common]\\ open override fun resetRoot(newRoot: Screen): List&lt;Screen&gt;</p> <p>Clear the existing backstack of screens and navigate to newRoot.</p> <p>This is useful in preventing the user from returning to a completed workflow, such as a tutorial, wizard, or authentication flow.</p> <p>Example</p> <pre><code>val navigator = Navigator()\nnavigator.push(LoginScreen1)\nnavigator.push(LoginScreen2)\n\n// Login flow is complete. Wipe backstack and set new root screen\nval loginScreens = navigator.resetRoot(HomeScreen)\n</code></pre>"},{"location":"api/0.x/circuit-runtime/com.slack.circuit.runtime/-screen/","title":"Index","text":"<p>//circuit-runtime/com.slack.circuit.runtime/Screen</p>"},{"location":"api/0.x/circuit-runtime/com.slack.circuit.runtime/-screen/#screen","title":"Screen","text":"<p>[common]\\ @Immutable</p> <p>expect interface Screen</p> <p>Represents an individual screen, used as a key for <code>Presenter.Factory</code> and <code>Ui.Factory</code>.</p> <p>Screens can be simple sentinel <code>object</code> types or data classes with information to share. Screens with information should contain the minimum amount of data needed for the target presenter to begin presenting state.</p> <pre><code>data class AddFavorites(\nval externalId: UUID,\n) : Screen\n</code></pre> <p>Screens are then passed into a <code>Navigator</code> to navigate to them.</p> <pre><code>fun showAddFavorites() {\nnavigator.goTo(\nAddFavorites(\nexternalId = uuidGenerator.generate()\n)\n)\n}\n</code></pre> <p>[android]\\ @Immutable</p> <p>actual interface Screen : Parcelable</p> <p>[jvm]\\ @Immutable</p> <p>actual interface Screen</p>"},{"location":"api/0.x/circuit-runtime/com.slack.circuit.runtime/-screen/#functions","title":"Functions","text":"Name Summary describeContents [android]abstract fun describeContents(): Int writeToParcel [android]abstract fun writeToParcel(p0: Parcel, p1: Int)"},{"location":"api/0.x/circuit-runtime-presenter/com.slack.circuit.runtime.presenter/","title":"Index","text":"<p>//circuit-runtime-presenter/com.slack.circuit.runtime.presenter</p>"},{"location":"api/0.x/circuit-runtime-presenter/com.slack.circuit.runtime.presenter/#package-level-declarations","title":"Package-level declarations","text":""},{"location":"api/0.x/circuit-runtime-presenter/com.slack.circuit.runtime.presenter/#types","title":"Types","text":"Name Summary Presenter [common]interface Presenter&lt;UiState&gt;Presents a given UiState."},{"location":"api/0.x/circuit-runtime-presenter/com.slack.circuit.runtime.presenter/#functions","title":"Functions","text":"Name Summary presenterOf [common]inline fun &lt;UiState&gt; presenterOf(crossinline body: @Composable() -&gt; UiState): Presenter&lt;UiState&gt;Due to this bug in Studio, we can\u2019t write lambda impls of Presenter directly. This works around it by offering a shim function of the same name. Once it\u2019s fixed, we can remove this and make Presenter a fun interface instead."},{"location":"api/0.x/circuit-runtime-presenter/com.slack.circuit.runtime.presenter/presenter-of/","title":"Presenter of","text":"<p>//circuit-runtime-presenter/com.slack.circuit.runtime.presenter/presenterOf</p>"},{"location":"api/0.x/circuit-runtime-presenter/com.slack.circuit.runtime.presenter/presenter-of/#presenterof","title":"presenterOf","text":"<p>[common]\\ inline fun &lt;UiState&gt; presenterOf(crossinline body: @Composable() -&gt; UiState): Presenter&lt;UiState&gt;</p> <p>Due to this bug in Studio, we can\u2019t write lambda impls of Presenter directly. This works around it by offering a shim function of the same name. Once it\u2019s fixed, we can remove this and make Presenter a fun interface instead.</p> <p>Bug: https://issuetracker.google.com/issues/240292828</p>"},{"location":"api/0.x/circuit-runtime-presenter/com.slack.circuit.runtime.presenter/presenter-of/#see-also","title":"See also","text":"Presenter for main docs."},{"location":"api/0.x/circuit-runtime-presenter/com.slack.circuit.runtime.presenter/-presenter/","title":"Index","text":"<p>//circuit-runtime-presenter/com.slack.circuit.runtime.presenter/Presenter</p>"},{"location":"api/0.x/circuit-runtime-presenter/com.slack.circuit.runtime.presenter/-presenter/#presenter","title":"Presenter","text":"<p>interface Presenter&lt;UiState&gt;</p> <p>Presents a given UiState.</p> <p>Events (if any) should be a part of the UiState itself as an <code>eventSink: (Event) -&gt; Unit</code> property.</p> <p>If a given Presenter only ever emits the same state, you can define a single value-less <code>object</code> type for the state.</p>"},{"location":"api/0.x/circuit-runtime-presenter/com.slack.circuit.runtime.presenter/-presenter/#see-also","title":"See also","text":"Presenter.present for more thorough documentation."},{"location":"api/0.x/circuit-runtime-presenter/com.slack.circuit.runtime.presenter/-presenter/#types","title":"Types","text":"Name Summary Factory [common]fun interface FactoryA factory that produces presenters for a given Screen. <code>CircuitConfig</code> instances use the created presenter and connects it to a given <code>Ui</code> for the same Screen."},{"location":"api/0.x/circuit-runtime-presenter/com.slack.circuit.runtime.presenter/-presenter/#functions","title":"Functions","text":"Name Summary present [common]@Composableabstract fun present(): UiStateThe primary Composable entry point to present a UiState. In production, a Navigator is used to automatically connect this with a corresponding <code>Ui</code> to render the state returned by this function."},{"location":"api/0.x/circuit-runtime-presenter/com.slack.circuit.runtime.presenter/-presenter/present/","title":"Present","text":"<p>//circuit-runtime-presenter/com.slack.circuit.runtime.presenter/Presenter/present</p>"},{"location":"api/0.x/circuit-runtime-presenter/com.slack.circuit.runtime.presenter/-presenter/present/#present","title":"present","text":"<p>[common]\\</p> <p>@Composable</p> <p>abstract fun present(): UiState</p> <p>The primary Composable entry point to present a UiState. In production, a Navigator is used to automatically connect this with a corresponding <code>Ui</code> to render the state returned by this function.</p> <p>When handling events, embed a <code>eventSink: (Event) -&gt; Unit</code> property in the state as needed.</p> <pre><code>data class State(\nval favorites: List&lt;Favorite&gt;,\neventSink: (Event) -&gt; Unit\n) : CircuitUiState\n\nclass FavoritesPresenter(...) : Presenter&lt;State, Event&gt; {\n@Composable override fun present(): State {\n// ...\nreturn State(...) { event -&gt;\n// Handle UI events here\n}\n}\n}\n</code></pre>"},{"location":"api/0.x/circuit-runtime-presenter/com.slack.circuit.runtime.presenter/-presenter/present/#dependency-injection","title":"Dependency Injection","text":"<p>Presenters should use dependency injection, usually assisted injection to accept Navigator or Screen instances as inputs. Their corresponding assisted factories should then be used by hand-written presenter factories.</p> <pre><code>class FavoritesPresenter @AssistedInject constructor(\n@Assisted private val screen: FavoritesScreen,\n@Assisted private val navigator: Navigator,\nprivate val favoritesRepository: FavoritesRepository\n) : Presenter&lt;State&gt; {\n@Composable override fun present(): State {\n// ...\n}\n\n@AssistedFactory\nfun interface Factory {\nfun create(screen: FavoritesScreen, navigator: Navigator): FavoritesPresenter\n}\n}\n</code></pre>"},{"location":"api/0.x/circuit-runtime-presenter/com.slack.circuit.runtime.presenter/-presenter/present/#testing","title":"Testing","text":"<p>When testing, simply drive UI events with a MutableSharedFlow use Molecule+Turbine to drive this function.</p> <pre><code>@Test\nfun `emit initial state and refresh`() = runTest {\nval favorites = listOf(\"Moose\", \"Reeses\", \"Lola\")\nval repository = FakeFavoritesRepository(favorites)\nval presenter = FavoritesPresenter(repository)\n\nmoleculeFlow(Immediate) { presenter.present() }\n.test {\nassertThat(awaitItem()).isEqualTo(State.Loading)\nval successState = awaitItem()\nassertThat(successState).isEqualTo(State.Success(favorites))\nsuccessState.eventSink(Event.Refresh)\nassertThat(awaitItem()).isEqualTo(State.Success(favorites))\n}\n}\n</code></pre> <p>Note that Circuit\u2019s test artifact has a <code>Presenter.test()</code> helper extension function for the above case.</p>"},{"location":"api/0.x/circuit-runtime-presenter/com.slack.circuit.runtime.presenter/-presenter/-factory/","title":"Index","text":"<p>//circuit-runtime-presenter/com.slack.circuit.runtime.presenter/Presenter/Factory</p>"},{"location":"api/0.x/circuit-runtime-presenter/com.slack.circuit.runtime.presenter/-presenter/-factory/#factory","title":"Factory","text":"<p>[common]\\ fun interface Factory</p> <p>A factory that produces presenters for a given Screen. <code>CircuitConfig</code> instances use the created presenter and connects it to a given <code>Ui</code> for the same Screen.</p> <p>Factories should be simple aggregate multiple presenters for a canonical \"whole screen\". That is to say, they should be hand-written and aggregate all the presenters responsible for the UI visible within the surface this presents on.</p>"},{"location":"api/0.x/circuit-runtime-presenter/com.slack.circuit.runtime.presenter/-presenter/-factory/#example","title":"Example","text":"<p>Consider this example of a Profile UI.</p> <pre><code>                              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u250c\u2500\u2500\u2500 \u2502                    \u2502\n\u2502    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u25c4\u2500\u2500\u2510\n\u2502    \u2502 X                  \u2502   \u2502\n\u2502    \u2502                    \u2502 ProfileHeaderPresenter\n\u2502    \u2502 Fred Rogers        \u2502   \u2502\n\u2502    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u25c4\u2500\u2500\u2518\n\u2502    \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2510  \u2502\nProfilePresenterFactory   \u2502 \u2502Message\u2502  \u2502Call\u2502\u25c4\u2500\u253c\u2500\u2500\u2500 ProfileActionsPresenter\n\u2502    \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2502    \u2502                    \u2502\n\u2502    \u2502  - - - - - - - - \u25c4\u2500\u253c\u2500\u2500\u2500\u2500\u2510\n\u2502    \u2502  - - - - - - - -   \u2502    \u2502\n\u2502    \u2502  - - - - - - - -   \u2502  ProfileDetailsPresenter\n\u2502    \u2502  - - - - - - - - \u25c4\u2500\u253c\u2500\u2500\u2500\u2500\u2518\n\u2514\u2500\u2500\u2500 \u2502                    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>This would be represented by the following factory implementation:</p> <pre><code>class ProfilePresenter.Factory @Inject constructor(\nval headerPresenter: ProfilerHeaderPresenter.Factory,\nval actionsPresenter: ProfilerActionsPresenter.Factory,\nval detailsPresenter: ProfilerDetailsPresenter.Factory,\nval callScreenRouter: CallScreenRouter.Factory\n) : Presenter.Factory {\noverride fun create(screen: Screen, navigator: Navigator, context: CircuitContext): Presenter&lt;*, *&gt;? {\nreturn when (screen) {\nis ProfileHeader -&gt; headerPresenter.create(screen)\nis ProfileActions -&gt; actionsPresenter.create(screen, callScreenRouter.create(navigator))\nis ProfileDetails -&gt; detailsPresenter.create(screen)\nelse -&gt; null\n}\n}\n}\n</code></pre>"},{"location":"api/0.x/circuit-runtime-presenter/com.slack.circuit.runtime.presenter/-presenter/-factory/#functions","title":"Functions","text":"Name Summary create [common]abstract fun create(screen: &lt;Error class: unknown class&gt;, navigator: &lt;Error class: unknown class&gt;, context: &lt;Error class: unknown class&gt;): Presenter&lt;*&gt;?Creates a Presenter for the given screen if it can handle it, or returns null if it cannot handle the given screen."},{"location":"api/0.x/circuit-runtime-presenter/com.slack.circuit.runtime.presenter/-presenter/-factory/create/","title":"Create","text":"<p>//circuit-runtime-presenter/com.slack.circuit.runtime.presenter/Presenter/Factory/create</p>"},{"location":"api/0.x/circuit-runtime-presenter/com.slack.circuit.runtime.presenter/-presenter/-factory/create/#create","title":"create","text":"<p>[common]\\ abstract fun create(screen: &lt;Error class: unknown class&gt;, navigator: &lt;Error class: unknown class&gt;, context: &lt;Error class: unknown class&gt;): Presenter&lt;*&gt;?</p> <p>Creates a Presenter for the given screen if it can handle it, or returns null if it cannot handle the given screen.</p>"},{"location":"api/0.x/circuit-runtime-ui/com.slack.circuit.runtime.ui/","title":"Index","text":"<p>//circuit-runtime-ui/com.slack.circuit.runtime.ui</p>"},{"location":"api/0.x/circuit-runtime-ui/com.slack.circuit.runtime.ui/#package-level-declarations","title":"Package-level declarations","text":""},{"location":"api/0.x/circuit-runtime-ui/com.slack.circuit.runtime.ui/#types","title":"Types","text":"Name Summary Ui [common]interface Ui&lt;UiState&gt;Represents a composable UI for the given UiState. Conventionally, this should just be the return type of a ui function and a thin shim over a \"real\" implementation."},{"location":"api/0.x/circuit-runtime-ui/com.slack.circuit.runtime.ui/#functions","title":"Functions","text":"Name Summary ui [common]inline fun &lt;UiState&gt; ui(crossinline body: @Composable(state: UiState, modifier: Modifier) -&gt; Unit): Ui&lt;UiState&gt;Due to this bug in Studio, we can\u2019t write lambda impls of Ui directly. This works around it by offering a shim function of the same name. Once it\u2019s fixed, we can remove this and make Ui a fun interface instead."},{"location":"api/0.x/circuit-runtime-ui/com.slack.circuit.runtime.ui/ui/","title":"Ui","text":"<p>//circuit-runtime-ui/com.slack.circuit.runtime.ui/ui</p>"},{"location":"api/0.x/circuit-runtime-ui/com.slack.circuit.runtime.ui/ui/#ui","title":"ui","text":"<p>[common]\\ inline fun &lt;UiState&gt; ui(crossinline body: @Composable(state: UiState, modifier: Modifier) -&gt; Unit): Ui&lt;UiState&gt;</p> <p>Due to this bug in Studio, we can\u2019t write lambda impls of Ui directly. This works around it by offering a shim function of the same name. Once it\u2019s fixed, we can remove this and make Ui a fun interface instead.</p> <p>Bug: https://issuetracker.google.com/issues/240292828</p>"},{"location":"api/0.x/circuit-runtime-ui/com.slack.circuit.runtime.ui/ui/#see-also","title":"See also","text":"Ui for main docs."},{"location":"api/0.x/circuit-runtime-ui/com.slack.circuit.runtime.ui/-ui/","title":"Index","text":"<p>//circuit-runtime-ui/com.slack.circuit.runtime.ui/Ui</p>"},{"location":"api/0.x/circuit-runtime-ui/com.slack.circuit.runtime.ui/-ui/#ui","title":"Ui","text":"<p>interface Ui&lt;UiState&gt;</p> <p>Represents a composable UI for the given UiState. Conventionally, this should just be the return type of a ui function and a thin shim over a \"real\" implementation.</p> <p>This has two main benefits:</p> <ol> <li>Discouraging properties and general non-composable state that writing a class may invite.</li> <li>Ensuring separation of Ui instance from Screen specific ui composables allows for and     encourages easy UI previews via Compose\u2019s <code>@Preview</code> annotations.</li> </ol> <p>Usage:</p> <pre><code>internal fun tacoUi(): Ui&lt;State&gt; = ui { state, modifier -&gt;\nTacos(state, modifier)\n}\n\n@Composable private fun Tacos(state: State, modifier: Modifier = Modifier) {...}\n\n@Preview\n@Composable\nprivate fun PreviewTacos() = Tacos(...)\n</code></pre> <p>This could be a class, but isn\u2019t necessary unless you\u2019re using dependency injection. Most UIs don\u2019t use dependency injection at all however, unless maybe getting assisted injections of things like image loaders.</p> <p>If a given <code>Presenter</code> only ever emits the same state, you can define a single value-less <code>object</code> type for the state.</p> <p>Note that due to a bug in studio, we can\u2019t make this a <code>fun interface</code>yet. Instead, use ui.</p>"},{"location":"api/0.x/circuit-runtime-ui/com.slack.circuit.runtime.ui/-ui/#see-also","title":"See also","text":"ui"},{"location":"api/0.x/circuit-runtime-ui/com.slack.circuit.runtime.ui/-ui/#types","title":"Types","text":"Name Summary Factory [common]fun interface FactoryA factory that creates Ui\u2019s for a given Screen."},{"location":"api/0.x/circuit-runtime-ui/com.slack.circuit.runtime.ui/-ui/#functions","title":"Functions","text":"Name Summary Content [common]@Composableabstract fun Content(state: UiState, modifier: Modifier)"},{"location":"api/0.x/circuit-runtime-ui/com.slack.circuit.runtime.ui/-ui/-content/","title":"content","text":"<p>//circuit-runtime-ui/com.slack.circuit.runtime.ui/Ui/Content</p>"},{"location":"api/0.x/circuit-runtime-ui/com.slack.circuit.runtime.ui/-ui/-content/#content","title":"Content","text":"<p>[common]\\</p> <p>@Composable</p> <p>abstract fun Content(state: UiState, modifier: Modifier)</p>"},{"location":"api/0.x/circuit-runtime-ui/com.slack.circuit.runtime.ui/-ui/-factory/","title":"Index","text":"<p>//circuit-runtime-ui/com.slack.circuit.runtime.ui/Ui/Factory</p>"},{"location":"api/0.x/circuit-runtime-ui/com.slack.circuit.runtime.ui/-ui/-factory/#factory","title":"Factory","text":"<p>[common]\\ fun interface Factory</p> <p>A factory that creates Ui\u2019s for a given Screen.</p> <p>Note that individual UIs should just be top-level ui function calls that factories simply call into. This allows easily standing up composable preview functions.</p> <pre><code>class FavoritesUiFactory @Inject constructor() : Ui.Factory {\noverride fun create(\nscreen: Screen,\ncontext: CircuitContext\n): Ui&lt;*&gt;? {\nreturn when (screen) {\nis AddFavorites -&gt; addFavoritesUi()\nelse -&gt; null\n}\n}\n}\n\nprivate fun addFavoritesUi() =\nui&lt;AddFavorites.State&gt; { state, modifier -&gt; Favorites(state, modifier) }\n\n@Composable private fun Favorites(state: State, modifier: Modifier = Modifier) {...}\n</code></pre>"},{"location":"api/0.x/circuit-runtime-ui/com.slack.circuit.runtime.ui/-ui/-factory/#functions","title":"Functions","text":"Name Summary create [common]abstract fun create(screen: &lt;Error class: unknown class&gt;, context: &lt;Error class: unknown class&gt;): Ui&lt;*&gt;?"},{"location":"api/0.x/circuit-runtime-ui/com.slack.circuit.runtime.ui/-ui/-factory/create/","title":"Create","text":"<p>//circuit-runtime-ui/com.slack.circuit.runtime.ui/Ui/Factory/create</p>"},{"location":"api/0.x/circuit-runtime-ui/com.slack.circuit.runtime.ui/-ui/-factory/create/#create","title":"create","text":"<p>[common]\\ abstract fun create(screen: &lt;Error class: unknown class&gt;, context: &lt;Error class: unknown class&gt;): Ui&lt;*&gt;?</p>"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/","title":"circuit-test","text":"<p>//circuit-test/com.slack.circuit.test</p>"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/#package-level-declarations","title":"Package-level declarations","text":""},{"location":"api/0.x/circuit-test/com.slack.circuit.test/#types","title":"Types","text":"Name Summary FakeNavigator [common]class FakeNavigatorA fake Navigator that can be used in tests to record and assert navigation events."},{"location":"api/0.x/circuit-test/com.slack.circuit.test/#functions","title":"Functions","text":"Name Summary presenterTestOf [common]suspend fun &lt;UiState&gt; presenterTestOf(presentFunction: @Composable() -&gt; UiState, timeout: Duration? = null, name: String? = null, block: suspend ReceiveTurbine&lt;UiState&gt;.() -&gt; Unit)Presents this presentFunction and invokes a <code>suspend</code>ReceiveTurbine that can be used to assert state emissions from it. test [common]suspend fun &lt;UiState&gt; &lt;Error class: unknown class&gt;&lt;UiState&gt;.test(timeout: Duration? = null, name: String? = null, block: suspend ReceiveTurbine&lt;UiState&gt;.() -&gt; Unit)Presents this Presenter and invokes a <code>suspend</code>ReceiveTurbine that can be used to assert state emissions from this presenter."},{"location":"api/0.x/circuit-test/com.slack.circuit.test/presenter-test-of/","title":"Presenter test of","text":"<p>//circuit-test/com.slack.circuit.test/presenterTestOf</p>"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/presenter-test-of/#presentertestof","title":"presenterTestOf","text":"<p>[common]\\ suspend fun &lt;UiState&gt; presenterTestOf(presentFunction: @Composable() -&gt; UiState, timeout: Duration? = null, name: String? = null, block: suspend ReceiveTurbine&lt;UiState&gt;.() -&gt; Unit)</p> <p>Presents this presentFunction and invokes a <code>suspend</code>ReceiveTurbine that can be used to assert state emissions from it.</p>"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/presenter-test-of/#parameters","title":"Parameters","text":"<p>common</p> presentFunction the Composable present function being tested. timeout an optional timeout for the test. Defaults to 1 second (in Turbine) if undefined. block the block to invoke."},{"location":"api/0.x/circuit-test/com.slack.circuit.test/presenter-test-of/#see-also","title":"See also","text":"moleculeFlow test"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/test/","title":"Test","text":"<p>//circuit-test/com.slack.circuit.test/test</p>"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/test/#test","title":"test","text":"<p>[common]\\ suspend fun &lt;UiState&gt; &lt;Error class: unknown class&gt;&lt;UiState&gt;.test(timeout: Duration? = null, name: String? = null, block: suspend ReceiveTurbine&lt;UiState&gt;.() -&gt; Unit)</p> <p>Presents this Presenter and invokes a <code>suspend</code>ReceiveTurbine that can be used to assert state emissions from this presenter.</p>"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/test/#parameters","title":"Parameters","text":"<p>common</p> timeout an optional timeout for the test. Defaults to 1 second (in Turbine) if undefined. block the block to invoke."},{"location":"api/0.x/circuit-test/com.slack.circuit.test/test/#see-also","title":"See also","text":"moleculeFlow test"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/-fake-navigator/","title":"Index","text":"<p>//circuit-test/com.slack.circuit.test/FakeNavigator</p>"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/-fake-navigator/#fakenavigator","title":"FakeNavigator","text":"<p>[common]\\ class FakeNavigator</p> <p>A fake Navigator that can be used in tests to record and assert navigation events.</p> <p>Example</p> <pre><code>val navigator = FakeNavigator()\nval presenter = FavoritesPresenter(navigator)\n\npresenter.test {\nval state = awaitItem()\nstate.eventSink(AddFavoriteClick)\nassertThat(navigator.awaitNextScreen())\n.isEqualTo(AddFavoriteScreen)\n}\n</code></pre>"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/-fake-navigator/#constructors","title":"Constructors","text":"FakeNavigator [common]constructor()"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/-fake-navigator/#functions","title":"Functions","text":"Name Summary assertIsEmpty [common]fun assertIsEmpty()Asserts that all events so far have been consumed. awaitNextScreen [common]suspend fun awaitNextScreen(): &lt;Error class: unknown class&gt;Awaits the next Screen that was navigated to or throws if no screens were navigated to. awaitPop [common]suspend fun awaitPop()Awaits the next navigation pop event or throws if no pops are performed. awaitResetRoot [common]suspend fun awaitResetRoot(): &lt;Error class: unknown class&gt;Awaits the next navigation resetRoot or throws if no resets were performed. expectNoEvents [common]fun expectNoEvents()Asserts that no events have been emitted. goTo [common]open fun goTo(screen: &lt;Error class: unknown class&gt;) pop [common]open fun pop(): &lt;Error class: unknown class&gt;? resetRoot [common]open fun resetRoot(newRoot: &lt;Error class: unknown class&gt;): List&lt;&lt;Error class: unknown class&gt;&gt; takeNextScreen [common]fun takeNextScreen(): &lt;Error class: unknown class&gt;Returns the next Screen that was navigated to or throws if no screens were navigated to."},{"location":"api/0.x/circuit-test/com.slack.circuit.test/-fake-navigator/-fake-navigator/","title":"fake navigator","text":"<p>//circuit-test/com.slack.circuit.test/FakeNavigator/FakeNavigator</p>"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/-fake-navigator/-fake-navigator/#fakenavigator","title":"FakeNavigator","text":"<p>[common]\\ constructor()</p>"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/-fake-navigator/assert-is-empty/","title":"Assert is empty","text":"<p>//circuit-test/com.slack.circuit.test/FakeNavigator/assertIsEmpty</p>"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/-fake-navigator/assert-is-empty/#assertisempty","title":"assertIsEmpty","text":"<p>[common]\\ fun assertIsEmpty()</p> <p>Asserts that all events so far have been consumed.</p>"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/-fake-navigator/await-next-screen/","title":"Await next screen","text":"<p>//circuit-test/com.slack.circuit.test/FakeNavigator/awaitNextScreen</p>"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/-fake-navigator/await-next-screen/#awaitnextscreen","title":"awaitNextScreen","text":"<p>[common]\\ suspend fun awaitNextScreen(): &lt;Error class: unknown class&gt;</p> <p>Awaits the next Screen that was navigated to or throws if no screens were navigated to.</p>"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/-fake-navigator/await-pop/","title":"Await pop","text":"<p>//circuit-test/com.slack.circuit.test/FakeNavigator/awaitPop</p>"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/-fake-navigator/await-pop/#awaitpop","title":"awaitPop","text":"<p>[common]\\ suspend fun awaitPop()</p> <p>Awaits the next navigation pop event or throws if no pops are performed.</p>"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/-fake-navigator/await-reset-root/","title":"Await reset root","text":"<p>//circuit-test/com.slack.circuit.test/FakeNavigator/awaitResetRoot</p>"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/-fake-navigator/await-reset-root/#awaitresetroot","title":"awaitResetRoot","text":"<p>[common]\\ suspend fun awaitResetRoot(): &lt;Error class: unknown class&gt;</p> <p>Awaits the next navigation resetRoot or throws if no resets were performed.</p>"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/-fake-navigator/expect-no-events/","title":"Expect no events","text":"<p>//circuit-test/com.slack.circuit.test/FakeNavigator/expectNoEvents</p>"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/-fake-navigator/expect-no-events/#expectnoevents","title":"expectNoEvents","text":"<p>[common]\\ fun expectNoEvents()</p> <p>Asserts that no events have been emitted.</p>"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/-fake-navigator/go-to/","title":"Go to","text":"<p>//circuit-test/com.slack.circuit.test/FakeNavigator/goTo</p>"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/-fake-navigator/go-to/#goto","title":"goTo","text":"<p>[common]\\ open fun goTo(screen: &lt;Error class: unknown class&gt;)</p>"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/-fake-navigator/pop/","title":"Pop","text":"<p>//circuit-test/com.slack.circuit.test/FakeNavigator/pop</p>"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/-fake-navigator/pop/#pop","title":"pop","text":"<p>[common]\\ open fun pop(): &lt;Error class: unknown class&gt;?</p>"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/-fake-navigator/reset-root/","title":"Reset root","text":"<p>//circuit-test/com.slack.circuit.test/FakeNavigator/resetRoot</p>"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/-fake-navigator/reset-root/#resetroot","title":"resetRoot","text":"<p>[common]\\ open fun resetRoot(newRoot: &lt;Error class: unknown class&gt;): List&lt;&lt;Error class: unknown class&gt;&gt;</p>"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/-fake-navigator/take-next-screen/","title":"Take next screen","text":"<p>//circuit-test/com.slack.circuit.test/FakeNavigator/takeNextScreen</p>"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/-fake-navigator/take-next-screen/#takenextscreen","title":"takeNextScreen","text":"<p>[common]\\ fun takeNextScreen(): &lt;Error class: unknown class&gt;</p> <p>Returns the next Screen that was navigated to or throws if no screens were navigated to.</p> <p>For non-coroutines users only.</p>"}]}