{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u26a1\ufe0f Circuit \u00b6 \ud83d\udea7 Under construction \ud83d\udea7 This project is very much a work in progress and far from finished! Overview \u00b6 Circuit is a simple, lightweight, and extensible framework for building Kotlin applications that\u2019s Compose from the ground up. Compose Runtime vs. Compose UI Compose itself is essentially two libraries \u2013 Compose Compiler and Compose UI. Most folks usually think of Compose UI, but the compiler (and associated runtime) are actually not specific to UI at all and offer powerful state management APIs. Jake Wharton has an excellent post about this: https://jakewharton.com/a-jetpack-compose-by-any-other-name/ It builds upon core principles we already know like Presenters and UDF, and adds native support in its framework for all the other requirements we set out for above. It\u2019s heavily influenced by Cash App\u2019s Broadway architecture ( talked about at Droidcon NYC , also very derived from our conversations with them). Circuit\u2019s core components are its Presenter and Ui interfaces. A Presenter and a Ui cannot directly access each other. They can only communicate through state and event emissions. UIs are compose-first. Presenters are also compose-first. They do not emit Compose UI, but they do use the Compose runtime to manage and emit state. Both Presenter and Ui each have a single composable function. In most cases, Circuit automatically connects presenters and UIs. Presenter and Ui are both generic types, with generics to define the UiState types they communicate with. They are keyed by Screen s. One runs a new Presenter / Ui pairing by requesting them with a given Screen that they understand. Circuits The pairing of a Presenter and Ui for a given Screen key is what we semantically call a \u201ccircuit\u201d. Your application is composed of \u201ccircuits\u201d. A simple counter Presenter + Ui pairing would be a \u201ccounter circuit\u201d. Nested presenter/UIs would be \u201cnested circuits\u201d or \u201csub circuits\u201d Composite presenter/UIs would be \u201ccomposite circuits\u201d etc etc. Circuit\u2019s repo ( https://github.com/slackhq/circuit ) is being actively developed in the open, which allows us to continue collaborating with external folks too. We have a trivial-but-not-too-trivial sample app that we have been developing in it to serve as a demo for a number of common patterns in Circuit use. Counter Example \u00b6 This is a very simple case of a Counter circuit that displays the count and has buttons to increment and decrement. There\u2019s some glue code missing from this example that\u2019s covered in the Code Gen (TODO link) section later. @Parcelize object CounterScreen : Screen { data class CounterState ( val count : Int , val eventSink : ( CounterEvent ) -> Unit , ) : CircuitUiState sealed interface CounterEvent : CircuitUiEvent { object Increment : CounterEvent object Decrement : CounterEvent } } @CircuitInject ( CounterScreen :: class , AppScope :: class ) @Composable fun CounterPresenter (): CounterState { var count by rememberSaveable { mutableStateOf ( 0 ) } return CounterState ( count ) { event -> when ( event ) { is CounterEvent . Increment -> count ++ is CounterEvent . Decrement -> count -- } } } @CircuitInject ( CounterScreen :: class , AppScope :: class ) @Composable fun Counter ( state : CounterState ) { Box ( Modifier . fillMaxSize ()) { Column ( Modifier . align ( Alignment . Center )) { Text ( modifier = Modifier . align ( CenterHorizontally ), text = \"Count: ${ state . count } \" , style = MaterialTheme . typography . displayLarge ) Spacer ( modifier = Modifier . height ( 16. dp )) val eventSink = state . eventSink Button ( modifier = Modifier . align ( CenterHorizontally ), onClick = { eventSink ( CounterEvent . Increment ) } ) { Icon ( rememberVectorPainter ( Icons . Filled . Add ), \"Increment\" ) } Button ( modifier = Modifier . align ( CenterHorizontally ), onClick = { eventSink ( CounterEvent . Decrement ) } ) { Icon ( rememberVectorPainter ( Icons . Filled . Remove ), \"Decrement\" ) } } } } License \u00b6 Copyright 2022 Slack Technologies, LLC Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Introduction"},{"location":"#circuit","text":"\ud83d\udea7 Under construction \ud83d\udea7 This project is very much a work in progress and far from finished!","title":"\u26a1\ufe0f Circuit"},{"location":"#overview","text":"Circuit is a simple, lightweight, and extensible framework for building Kotlin applications that\u2019s Compose from the ground up. Compose Runtime vs. Compose UI Compose itself is essentially two libraries \u2013 Compose Compiler and Compose UI. Most folks usually think of Compose UI, but the compiler (and associated runtime) are actually not specific to UI at all and offer powerful state management APIs. Jake Wharton has an excellent post about this: https://jakewharton.com/a-jetpack-compose-by-any-other-name/ It builds upon core principles we already know like Presenters and UDF, and adds native support in its framework for all the other requirements we set out for above. It\u2019s heavily influenced by Cash App\u2019s Broadway architecture ( talked about at Droidcon NYC , also very derived from our conversations with them). Circuit\u2019s core components are its Presenter and Ui interfaces. A Presenter and a Ui cannot directly access each other. They can only communicate through state and event emissions. UIs are compose-first. Presenters are also compose-first. They do not emit Compose UI, but they do use the Compose runtime to manage and emit state. Both Presenter and Ui each have a single composable function. In most cases, Circuit automatically connects presenters and UIs. Presenter and Ui are both generic types, with generics to define the UiState types they communicate with. They are keyed by Screen s. One runs a new Presenter / Ui pairing by requesting them with a given Screen that they understand. Circuits The pairing of a Presenter and Ui for a given Screen key is what we semantically call a \u201ccircuit\u201d. Your application is composed of \u201ccircuits\u201d. A simple counter Presenter + Ui pairing would be a \u201ccounter circuit\u201d. Nested presenter/UIs would be \u201cnested circuits\u201d or \u201csub circuits\u201d Composite presenter/UIs would be \u201ccomposite circuits\u201d etc etc. Circuit\u2019s repo ( https://github.com/slackhq/circuit ) is being actively developed in the open, which allows us to continue collaborating with external folks too. We have a trivial-but-not-too-trivial sample app that we have been developing in it to serve as a demo for a number of common patterns in Circuit use.","title":"Overview"},{"location":"#counter-example","text":"This is a very simple case of a Counter circuit that displays the count and has buttons to increment and decrement. There\u2019s some glue code missing from this example that\u2019s covered in the Code Gen (TODO link) section later. @Parcelize object CounterScreen : Screen { data class CounterState ( val count : Int , val eventSink : ( CounterEvent ) -> Unit , ) : CircuitUiState sealed interface CounterEvent : CircuitUiEvent { object Increment : CounterEvent object Decrement : CounterEvent } } @CircuitInject ( CounterScreen :: class , AppScope :: class ) @Composable fun CounterPresenter (): CounterState { var count by rememberSaveable { mutableStateOf ( 0 ) } return CounterState ( count ) { event -> when ( event ) { is CounterEvent . Increment -> count ++ is CounterEvent . Decrement -> count -- } } } @CircuitInject ( CounterScreen :: class , AppScope :: class ) @Composable fun Counter ( state : CounterState ) { Box ( Modifier . fillMaxSize ()) { Column ( Modifier . align ( Alignment . Center )) { Text ( modifier = Modifier . align ( CenterHorizontally ), text = \"Count: ${ state . count } \" , style = MaterialTheme . typography . displayLarge ) Spacer ( modifier = Modifier . height ( 16. dp )) val eventSink = state . eventSink Button ( modifier = Modifier . align ( CenterHorizontally ), onClick = { eventSink ( CounterEvent . Increment ) } ) { Icon ( rememberVectorPainter ( Icons . Filled . Add ), \"Increment\" ) } Button ( modifier = Modifier . align ( CenterHorizontally ), onClick = { eventSink ( CounterEvent . Decrement ) } ) { Icon ( rememberVectorPainter ( Icons . Filled . Remove ), \"Decrement\" ) } } } }","title":"Counter Example"},{"location":"#license","text":"Copyright 2022 Slack Technologies, LLC Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"changelog/","text":"Changelog \u00b6 0.3.1 \u00b6 2022-11-07 Enhancement : Add back the onRootPop() parameter in rememberCircuitNavigator() but use LocalOnBackPressedDispatcherOwner for backpress handling by default. 0.3.0 \u00b6 2022-11-01 New : The Overlay API is now extracted to a separate, optional circuit-overlay artifact. New : The circuit-core artifact now packages in baseline profiles. Enhancement : Simplify backstack root pop handling. There is no more onRootPop() option in rememberCircuitNavigator() , instead you should install your own BackHandler() prior to rendering your circuit content to customize back behavior when the circuit Navigator is at root. Fix : circuit-codegen-annotations is now a multiplatform project and doesn\u2019t accidentally impose the compose-desktop dependency. We\u2019ve also updated a number of docs around code gen, overlays, and interop (including a new interop sample). 0.2.2 \u00b6 2022-10-27 Enhancement : Code gen now supports non-assisted constructor-injected types. Enhancement : Code gen checks that functions and classes are visible to generated factories. 0.2.1 \u00b6 2022-10-27 Fix : Code gen didn\u2019t properly handle instantiating simple class types. 0.2.0 \u00b6 2022-10-26 New : Code gen artifact. This targets specifically using Dagger + Anvil and will generate Presenter and Ui.Factory implementations for you. See CircuitInject for more details. ksp ( \"com.slack.circuit:circuit-codegen:x.y.z\" ) implementation ( \"com.slack.circuit:circuit-codegen-annotations:x.y.z\" ) New : There is now an EventListener API for instrumenting state changes for a given Screen . See its docs for more details. Fix : Rework rememberRetained implementation and support for multiple variables. Previously it only worked with one variable. Fix : Clean up some unnecessary transitive dependencies in misc artifacts. Dependency updates androidx.activity 1.6.1 androidx.compose 1.3.0 Molecule 0.5.0 0.1.2 \u00b6 2022-10-12 Update to compose-jb 1.2.0 . Update to Turbine 0.12.0 . Fix : Accidentally running molecule twice in Presenter.test() . 0.1.1 \u00b6 2022-10-10 Fix : Accidentally bundling more Compose UI dependencies than necessary. 0.1.0 \u00b6 2022-10-10 Initial release, see the docs: https://slackhq.github.io/circuit/ . Note that this library is still under active development and not recommended for production use. We\u2019ll do a more formal announcement when that time comes!","title":"Change Log"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#031","text":"2022-11-07 Enhancement : Add back the onRootPop() parameter in rememberCircuitNavigator() but use LocalOnBackPressedDispatcherOwner for backpress handling by default.","title":"0.3.1"},{"location":"changelog/#030","text":"2022-11-01 New : The Overlay API is now extracted to a separate, optional circuit-overlay artifact. New : The circuit-core artifact now packages in baseline profiles. Enhancement : Simplify backstack root pop handling. There is no more onRootPop() option in rememberCircuitNavigator() , instead you should install your own BackHandler() prior to rendering your circuit content to customize back behavior when the circuit Navigator is at root. Fix : circuit-codegen-annotations is now a multiplatform project and doesn\u2019t accidentally impose the compose-desktop dependency. We\u2019ve also updated a number of docs around code gen, overlays, and interop (including a new interop sample).","title":"0.3.0"},{"location":"changelog/#022","text":"2022-10-27 Enhancement : Code gen now supports non-assisted constructor-injected types. Enhancement : Code gen checks that functions and classes are visible to generated factories.","title":"0.2.2"},{"location":"changelog/#021","text":"2022-10-27 Fix : Code gen didn\u2019t properly handle instantiating simple class types.","title":"0.2.1"},{"location":"changelog/#020","text":"2022-10-26 New : Code gen artifact. This targets specifically using Dagger + Anvil and will generate Presenter and Ui.Factory implementations for you. See CircuitInject for more details. ksp ( \"com.slack.circuit:circuit-codegen:x.y.z\" ) implementation ( \"com.slack.circuit:circuit-codegen-annotations:x.y.z\" ) New : There is now an EventListener API for instrumenting state changes for a given Screen . See its docs for more details. Fix : Rework rememberRetained implementation and support for multiple variables. Previously it only worked with one variable. Fix : Clean up some unnecessary transitive dependencies in misc artifacts. Dependency updates androidx.activity 1.6.1 androidx.compose 1.3.0 Molecule 0.5.0","title":"0.2.0"},{"location":"changelog/#012","text":"2022-10-12 Update to compose-jb 1.2.0 . Update to Turbine 0.12.0 . Fix : Accidentally running molecule twice in Presenter.test() .","title":"0.1.2"},{"location":"changelog/#011","text":"2022-10-10 Fix : Accidentally bundling more Compose UI dependencies than necessary.","title":"0.1.1"},{"location":"changelog/#010","text":"2022-10-10 Initial release, see the docs: https://slackhq.github.io/circuit/ . Note that this library is still under active development and not recommended for production use. We\u2019ll do a more formal announcement when that time comes!","title":"0.1.0"},{"location":"circuit-content/","text":"CircuitContent \u00b6 The simplest entry point of a circuit is the composable CircuitContent function. This function accepts a Screen and automatically finds and pairs corresponding Presenter and Ui instances to render in it. setContent { CircuitContent ( HomeScreen ) }","title":"CircuitContent"},{"location":"circuit-content/#circuitcontent","text":"The simplest entry point of a circuit is the composable CircuitContent function. This function accepts a Screen and automatically finds and pairs corresponding Presenter and Ui instances to render in it. setContent { CircuitContent ( HomeScreen ) }","title":"CircuitContent"},{"location":"code-gen/","text":"Code Generation \u00b6 If using Dagger and Anvil, Circuit offers a KSP-based code gen solution to ease boilerplate around generating factories. Installation \u00b6 plugins { id ( \"com.google.devtools.ksp\" ) } dependencies { api ( \"com.slack.circuit:circuit-codegen-annotations:<version>\" ) ksp ( \"com.slack.circuit:circuit-codegen:<version>\" ) } Usage \u00b6 The primary entry point is the CircuitInject annotation. This annotation is used to mark a UI or presenter class or function for code generation. When annotated, the type\u2019s corresponding factory will be generated and keyed with the defined screen . The generated factories are then contributed to Anvil via ContributesMultibinding and scoped with the provided scope key. Classes \u00b6 Presenter and Ui classes can be annotated and have their corresponding Presenter.Factory or Ui.Factory classes generated for them. Presenter @CircuitInject ( HomeScreen :: class , AppScope :: class ) class HomePresenter @Inject constructor (...) : Presenter < HomeState > { ... } // Generates @ContributesMultibinding ( AppScope :: class ) class HomePresenterFactory @Inject constructor () : Presenter . Factory { ... } UI @CircuitInject ( HomeScreen :: class , AppScope :: class ) class HomeUi @Inject constructor (...) : Ui < HomeState > { ... } // Generates @ContributesMultibinding ( AppScope :: class ) class HomeUiFactory @Inject constructor () : Ui . Factory { ... } Functions \u00b6 Simple functions can be annotated and have a corresponding Presenter.Factory generated. This is primarily useful for simple cases where a class is just technical tedium. Requirements - Presenter function names must end in Presenter , otherwise they will be treated as UI functions. - Presenter functions must return a CircuitUiState type. - UI functions can optionally accept a CircuitUiState type as a parameter, but it is not required. - UI functions must return Unit . - Both presenter and UI functions must be Composable . Presenter @CircuitInject ( HomeScreen :: class , AppScope :: class ) @Composable fun HomePresenter (): HomeState { ... } // Generates @ContributesMultibinding ( AppScope :: class ) class HomePresenterFactory @Inject constructor () : Presenter . Factory { ... } UI @CircuitInject ( HomeScreen :: class , AppScope :: class ) @Composable fun Home ( state : HomeState ) { ... } * // Generates @ContributesMultibinding ( AppScope :: class ) class HomeUiFactory @Inject constructor () : Ui . Factory { ... } Assisted injection \u00b6 Any type that is offered in Presenter.Factory and Ui.Factory can be offered as an assisted injection to types using Dagger AssistedInject . For these cases, the AssistedFactory -annotated interface should be annotated with CircuitInject instead of the enclosing class. Types available for assisted injection are: - Screen \u2013 the screen key used to create the Presenter or Ui . - Navigator \u2013 (presenters only) - CircuitConfig Each should only be defined at-most once. Examples // Function example @CircuitInject ( HomeScreen :: class , AppScope :: class ) @Composable fun HomePresenter ( screen : Screen , navigator : Navigator ): HomeState { ... } // Class example class HomePresenter @AssistedInject constructor ( @Assisted screen : Screen , @Assisted navigator : Navigator , ... ) : Presenter < HomeState > { // ... @CircuitInject ( HomeScreen :: class , AppScope :: class ) @AssistedFactory fun interface Factory { fun create ( screen : Screen , navigator : Navigator ): HomePresenter } }","title":"Code Generation"},{"location":"code-gen/#code-generation","text":"If using Dagger and Anvil, Circuit offers a KSP-based code gen solution to ease boilerplate around generating factories.","title":"Code Generation"},{"location":"code-gen/#installation","text":"plugins { id ( \"com.google.devtools.ksp\" ) } dependencies { api ( \"com.slack.circuit:circuit-codegen-annotations:<version>\" ) ksp ( \"com.slack.circuit:circuit-codegen:<version>\" ) }","title":"Installation"},{"location":"code-gen/#usage","text":"The primary entry point is the CircuitInject annotation. This annotation is used to mark a UI or presenter class or function for code generation. When annotated, the type\u2019s corresponding factory will be generated and keyed with the defined screen . The generated factories are then contributed to Anvil via ContributesMultibinding and scoped with the provided scope key.","title":"Usage"},{"location":"code-gen/#classes","text":"Presenter and Ui classes can be annotated and have their corresponding Presenter.Factory or Ui.Factory classes generated for them. Presenter @CircuitInject ( HomeScreen :: class , AppScope :: class ) class HomePresenter @Inject constructor (...) : Presenter < HomeState > { ... } // Generates @ContributesMultibinding ( AppScope :: class ) class HomePresenterFactory @Inject constructor () : Presenter . Factory { ... } UI @CircuitInject ( HomeScreen :: class , AppScope :: class ) class HomeUi @Inject constructor (...) : Ui < HomeState > { ... } // Generates @ContributesMultibinding ( AppScope :: class ) class HomeUiFactory @Inject constructor () : Ui . Factory { ... }","title":"Classes"},{"location":"code-gen/#functions","text":"Simple functions can be annotated and have a corresponding Presenter.Factory generated. This is primarily useful for simple cases where a class is just technical tedium. Requirements - Presenter function names must end in Presenter , otherwise they will be treated as UI functions. - Presenter functions must return a CircuitUiState type. - UI functions can optionally accept a CircuitUiState type as a parameter, but it is not required. - UI functions must return Unit . - Both presenter and UI functions must be Composable . Presenter @CircuitInject ( HomeScreen :: class , AppScope :: class ) @Composable fun HomePresenter (): HomeState { ... } // Generates @ContributesMultibinding ( AppScope :: class ) class HomePresenterFactory @Inject constructor () : Presenter . Factory { ... } UI @CircuitInject ( HomeScreen :: class , AppScope :: class ) @Composable fun Home ( state : HomeState ) { ... } * // Generates @ContributesMultibinding ( AppScope :: class ) class HomeUiFactory @Inject constructor () : Ui . Factory { ... }","title":"Functions"},{"location":"code-gen/#assisted-injection","text":"Any type that is offered in Presenter.Factory and Ui.Factory can be offered as an assisted injection to types using Dagger AssistedInject . For these cases, the AssistedFactory -annotated interface should be annotated with CircuitInject instead of the enclosing class. Types available for assisted injection are: - Screen \u2013 the screen key used to create the Presenter or Ui . - Navigator \u2013 (presenters only) - CircuitConfig Each should only be defined at-most once. Examples // Function example @CircuitInject ( HomeScreen :: class , AppScope :: class ) @Composable fun HomePresenter ( screen : Screen , navigator : Navigator ): HomeState { ... } // Class example class HomePresenter @AssistedInject constructor ( @Assisted screen : Screen , @Assisted navigator : Navigator , ... ) : Presenter < HomeState > { // ... @CircuitInject ( HomeScreen :: class , AppScope :: class ) @AssistedFactory fun interface Factory { fun create ( screen : Screen , navigator : Navigator ): HomePresenter } }","title":"Assisted injection"},{"location":"code-of-conduct/","text":"Code of Conduct \u00b6 Introduction \u00b6 Diversity and inclusion make our community strong. We encourage participation from the most varied and diverse backgrounds possible and want to be very clear about where we stand. Our goal is to maintain a safe, helpful and friendly community for everyone, regardless of experience, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, nationality, or other defining characteristic. This code and related procedures also apply to unacceptable behavior occurring outside the scope of community activities, in all community venues (online and in-person) as well as in all one-on-one communications, and anywhere such behavior has the potential to adversely affect the safety and well-being of community members. For more information on our code of conduct, please visit https://slackhq.github.io/code-of-conduct","title":"CoC"},{"location":"code-of-conduct/#code-of-conduct","text":"","title":"Code of Conduct"},{"location":"code-of-conduct/#introduction","text":"Diversity and inclusion make our community strong. We encourage participation from the most varied and diverse backgrounds possible and want to be very clear about where we stand. Our goal is to maintain a safe, helpful and friendly community for everyone, regardless of experience, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, nationality, or other defining characteristic. This code and related procedures also apply to unacceptable behavior occurring outside the scope of community activities, in all community venues (online and in-person) as well as in all one-on-one communications, and anywhere such behavior has the potential to adversely affect the safety and well-being of community members. For more information on our code of conduct, please visit https://slackhq.github.io/code-of-conduct","title":"Introduction"},{"location":"contributing/","text":"Contributors Guide \u00b6 Note that this project is considered READ-ONLY. You are welcome to discuss or ask questions in the discussions section of the repo, but we do not normally accept external contributions without prior discussion. Development \u00b6 Check out this repo with Android Studio. It\u2019s a standard gradle project and conventional to checkout. The primary project is circuit . The primary sample is samples/star . This project is written in Kotlin and should only use Kotlin. Code formatting is checked via Spotless . To run the formatter, use the spotlessApply command. ./gradlew spotlessApply","title":"Contributing"},{"location":"contributing/#contributors-guide","text":"Note that this project is considered READ-ONLY. You are welcome to discuss or ask questions in the discussions section of the repo, but we do not normally accept external contributions without prior discussion.","title":"Contributors Guide"},{"location":"contributing/#development","text":"Check out this repo with Android Studio. It\u2019s a standard gradle project and conventional to checkout. The primary project is circuit . The primary sample is samples/star . This project is written in Kotlin and should only use Kotlin. Code formatting is checked via Spotless . To run the formatter, use the spotlessApply command. ./gradlew spotlessApply","title":"Development"},{"location":"factories/","text":"Factories \u00b6 At its core, Circuit works on the Factory pattern. Every Presenter and Ui is contributed to a CircuitConfig instance by a corresponding factory that creates them for given Screen s. These are intended to be aggregated in the DI layer and added to a CircuitConfig instance during construction. val circuitConfig = CircuitConfig . Builder () . addUiFactory ( FavoritesUiFactory ()) . addPresenterFactory ( FavoritesPresenterFactory ()) . build () Look familiar? If you\u2019ve used Moshi or Retrofit, these should feel fairly familiar! Presenter factories can be generated or hand-written, depending on if they aggregate an entire screen or are simple one-offs. Presenters are also given access to the current Navigator in this level. class FavoritesScreenPresenterFactory @Inject constructor ( private val favoritesPresenterFactory : FavoritesPresenter . Factory , ) : Presenter . Factory { override fun create ( screen : Screen , navigator : Navigator ): Presenter <*>? { return when ( screen ) { is FavoritesScreen -> favoritesPresenterFactory . create ( screen , navigator ) else -> null } } } UI factories are similar, but generally should not aggregate other UIs unless there\u2019s a DI-specific reason to do so (which there usually isn\u2019t!). class FavoritesScreenUiFactory : @Inject constructor () : Ui . Factory { override fun create ( screen : Screen ): ScreenUi? { return when ( screen ) { is FavoritesScreen -> ScreenUi ( favoritesUi ()) else null -> } } } private fun favoritesUi () = ui < State > { state -> Favorites ( state ) } Info Note how these return a ScreenUi class that holds the Ui instance. We are using this indirection as a toe-hold for possible other future UI metadata, such as Modifier instances. We canonically write these out as a separate function ( favoritesUi() ) that returns a Ui , which in turn calls through to the real (basic) Compose UI function ( Favorites() ). This ensures our basic compose functions are top-level and accessible by tests, and also discourages storing anything in class members rather than idiomatic composable state vars.","title":"Factories"},{"location":"factories/#factories","text":"At its core, Circuit works on the Factory pattern. Every Presenter and Ui is contributed to a CircuitConfig instance by a corresponding factory that creates them for given Screen s. These are intended to be aggregated in the DI layer and added to a CircuitConfig instance during construction. val circuitConfig = CircuitConfig . Builder () . addUiFactory ( FavoritesUiFactory ()) . addPresenterFactory ( FavoritesPresenterFactory ()) . build () Look familiar? If you\u2019ve used Moshi or Retrofit, these should feel fairly familiar! Presenter factories can be generated or hand-written, depending on if they aggregate an entire screen or are simple one-offs. Presenters are also given access to the current Navigator in this level. class FavoritesScreenPresenterFactory @Inject constructor ( private val favoritesPresenterFactory : FavoritesPresenter . Factory , ) : Presenter . Factory { override fun create ( screen : Screen , navigator : Navigator ): Presenter <*>? { return when ( screen ) { is FavoritesScreen -> favoritesPresenterFactory . create ( screen , navigator ) else -> null } } } UI factories are similar, but generally should not aggregate other UIs unless there\u2019s a DI-specific reason to do so (which there usually isn\u2019t!). class FavoritesScreenUiFactory : @Inject constructor () : Ui . Factory { override fun create ( screen : Screen ): ScreenUi? { return when ( screen ) { is FavoritesScreen -> ScreenUi ( favoritesUi ()) else null -> } } } private fun favoritesUi () = ui < State > { state -> Favorites ( state ) } Info Note how these return a ScreenUi class that holds the Ui instance. We are using this indirection as a toe-hold for possible other future UI metadata, such as Modifier instances. We canonically write these out as a separate function ( favoritesUi() ) that returns a Ui , which in turn calls through to the real (basic) Compose UI function ( Favorites() ). This ensures our basic compose functions are top-level and accessible by tests, and also discourages storing anything in class members rather than idiomatic composable state vars.","title":"Factories"},{"location":"interop/","text":"Interop \u00b6 Circuit can interop anywhere that Compose can interop. This includes common cases like Android Views , RxJava, Kotlin Flow , and more. Presenter \u00b6 Lean on first-party interop-APIs where possible! See examples of interop with different libraries in the :samples:interop project. UI \u00b6 Ui -> View \u00b6 Just embed the Circuit in a ComposeView like any other Compose UI. View -> Ui \u00b6 You can wrap your view in an AndroidView in a custom Ui implementation. class ExistingCustomViewUi : Ui < State > { @Composable fun Content ( state : State ) { AndroidView ( modifier = ... factory = { context -> ExistingCustomView ( context ) }, update = { view -> view . setState ( state ) view . setOnClickListener { state . eventSink ( Event . Click ) } } } }","title":"Interop"},{"location":"interop/#interop","text":"Circuit can interop anywhere that Compose can interop. This includes common cases like Android Views , RxJava, Kotlin Flow , and more.","title":"Interop"},{"location":"interop/#presenter","text":"Lean on first-party interop-APIs where possible! See examples of interop with different libraries in the :samples:interop project.","title":"Presenter"},{"location":"interop/#ui","text":"","title":"UI"},{"location":"interop/#ui-view","text":"Just embed the Circuit in a ComposeView like any other Compose UI.","title":"Ui -&gt; View"},{"location":"interop/#view-ui","text":"You can wrap your view in an AndroidView in a custom Ui implementation. class ExistingCustomViewUi : Ui < State > { @Composable fun Content ( state : State ) { AndroidView ( modifier = ... factory = { context -> ExistingCustomView ( context ) }, update = { view -> view . setState ( state ) view . setOnClickListener { state . eventSink ( Event . Click ) } } } }","title":"View -&gt; Ui"},{"location":"navigation/","text":"Navigation \u00b6 For navigable contents, we have a custom compose-based backstack implementation that the androidx folks shared with us. Navigation becomes two parts: A BackStack , where we use a SaveableBackStack implementation that saves a stack of Screen s and the ProvidedValues for each record on that stack (allowing us to save and restore on configuration changes automatically). A Navigator , which is a simple interface that we can point at a BackStack and offers simple goTo(<screen>) / pop() semantics. These are offered to presenters to perform navigation as needed to other screens. A new navigable content surface is handled via the NavigableCircuitContent functions. setContent { val backstack = rememberSaveableBackStack { push ( HomeScreen ) } val navigator = rememberCircuitNavigator ( backstack ) NavigableCircuitContent ( navigator , backstack ) } Warning SaveableBackStack must have a size of 1 or more after initialization. It\u2019s an error to have a backstack with zero items. Presenters are then given access to these navigator instances via Presenter.Factory (described in Factories ), which they can save if needed to perform navigation. fun showAddFavorites () { navigator . goTo ( AddFavorites ( externalId = uuidGenerator . generate () ) ) } If you want to have custom behavior for when back is pressed on the root screen (i.e. backstack.size == 1 ), you should implement your own BackHandler and use it before creating the backstack. setContent { val backstack = rememberSaveableBackStack { push ( HomeScreen ) } BackHandler ( onBack = { /* do something on root */ }) // The Navigator's internal BackHandler will take precedence until it is at the root screen. val navigator = rememberCircuitNavigator ( backstack ) NavigableCircuitContent ( navigator , backstack ) } Nested Navigation \u00b6 Navigation carries special semantic value in CircuitContent as well, where it\u2019s common for UIs to want to curry navigation events emitted by nested UIs. For this case, there\u2019s a CircuitContent overload that accepts an optional onNavEvent callback that you must then forward to a Navigator instance. @Composable fun ParentUi ( state : ParentState ) { CircuitContent ( NestedScreen , onNavEvent = { navEvent -> state . eventSink ( NestedNav ( navEvent )) }) } @Composable fun ParentPresenter ( navigator : Navigator ): ParentState { return ParentState (...) { event -> when ( event ) { is NestedNav -> navigator . onNavEvent ( event . navEvent ) } } } @Composable fun NestedPresenter ( navigator : Navigator ): NestedState { // These are forwarded up! navigator . goTo ( AnotherScreen ) // ... }","title":"Navigation"},{"location":"navigation/#navigation","text":"For navigable contents, we have a custom compose-based backstack implementation that the androidx folks shared with us. Navigation becomes two parts: A BackStack , where we use a SaveableBackStack implementation that saves a stack of Screen s and the ProvidedValues for each record on that stack (allowing us to save and restore on configuration changes automatically). A Navigator , which is a simple interface that we can point at a BackStack and offers simple goTo(<screen>) / pop() semantics. These are offered to presenters to perform navigation as needed to other screens. A new navigable content surface is handled via the NavigableCircuitContent functions. setContent { val backstack = rememberSaveableBackStack { push ( HomeScreen ) } val navigator = rememberCircuitNavigator ( backstack ) NavigableCircuitContent ( navigator , backstack ) } Warning SaveableBackStack must have a size of 1 or more after initialization. It\u2019s an error to have a backstack with zero items. Presenters are then given access to these navigator instances via Presenter.Factory (described in Factories ), which they can save if needed to perform navigation. fun showAddFavorites () { navigator . goTo ( AddFavorites ( externalId = uuidGenerator . generate () ) ) } If you want to have custom behavior for when back is pressed on the root screen (i.e. backstack.size == 1 ), you should implement your own BackHandler and use it before creating the backstack. setContent { val backstack = rememberSaveableBackStack { push ( HomeScreen ) } BackHandler ( onBack = { /* do something on root */ }) // The Navigator's internal BackHandler will take precedence until it is at the root screen. val navigator = rememberCircuitNavigator ( backstack ) NavigableCircuitContent ( navigator , backstack ) }","title":"Navigation"},{"location":"navigation/#nested-navigation","text":"Navigation carries special semantic value in CircuitContent as well, where it\u2019s common for UIs to want to curry navigation events emitted by nested UIs. For this case, there\u2019s a CircuitContent overload that accepts an optional onNavEvent callback that you must then forward to a Navigator instance. @Composable fun ParentUi ( state : ParentState ) { CircuitContent ( NestedScreen , onNavEvent = { navEvent -> state . eventSink ( NestedNav ( navEvent )) }) } @Composable fun ParentPresenter ( navigator : Navigator ): ParentState { return ParentState (...) { event -> when ( event ) { is NestedNav -> navigator . onNavEvent ( event . navEvent ) } } } @Composable fun NestedPresenter ( navigator : Navigator ): NestedState { // These are forwarded up! navigator . goTo ( AnotherScreen ) // ... }","title":"Nested Navigation"},{"location":"overlays/","text":"Overlays \u00b6 The circuit-overlay artifact contains an optional API for presenting overlays on top of the current UI. Usage \u00b6 The core APIs are the Overlay and OverlayHost interfaces. Overlay \u00b6 An Overlay is composable content that can be shown on top of other content via an OverlayHost . Overlays are typically used for one-off request/result flows and should not usually attempt to do any sort of external navigation or make any assumptions about the state of the app. They should only emit a Result to the given OverlayNavigator parameter when they are done. interface Overlay < Result : Any > { @Composable fun Content ( navigator : OverlayNavigator < Result > ) } For common overlays, it\u2019s useful to create a common Overlay subtype that can be reused. For example: BottomSheetOverlay , ModalOverlay , TooltipOverlay , etc. OverlayHost \u00b6 An OverlayHost is provided via composition local and exposes a suspend show() function to show an overlay and resume with a typed Result . val result = LocalOverlayHost . current . show ( BottomSheetOverlay (...)) Where BottomSheetOverlay is a custom bottom sheet implementation of an Overlay . Installation \u00b6 Add the dependency. implementation ( \"com.slack.circuit:circuit-overlay: $ circuit_version \" ) The simplest starting point for adding overlay support is the ContentWithOverlays composable function. ContentWithOverlays { // Your content here } This will expose a LocalOverlayHost composition local that can be used by UIs to show overlays.","title":"Overlays"},{"location":"overlays/#overlays","text":"The circuit-overlay artifact contains an optional API for presenting overlays on top of the current UI.","title":"Overlays"},{"location":"overlays/#usage","text":"The core APIs are the Overlay and OverlayHost interfaces.","title":"Usage"},{"location":"overlays/#overlay","text":"An Overlay is composable content that can be shown on top of other content via an OverlayHost . Overlays are typically used for one-off request/result flows and should not usually attempt to do any sort of external navigation or make any assumptions about the state of the app. They should only emit a Result to the given OverlayNavigator parameter when they are done. interface Overlay < Result : Any > { @Composable fun Content ( navigator : OverlayNavigator < Result > ) } For common overlays, it\u2019s useful to create a common Overlay subtype that can be reused. For example: BottomSheetOverlay , ModalOverlay , TooltipOverlay , etc.","title":"Overlay"},{"location":"overlays/#overlayhost","text":"An OverlayHost is provided via composition local and exposes a suspend show() function to show an overlay and resume with a typed Result . val result = LocalOverlayHost . current . show ( BottomSheetOverlay (...)) Where BottomSheetOverlay is a custom bottom sheet implementation of an Overlay .","title":"OverlayHost"},{"location":"overlays/#installation","text":"Add the dependency. implementation ( \"com.slack.circuit:circuit-overlay: $ circuit_version \" ) The simplest starting point for adding overlay support is the ContentWithOverlays composable function. ContentWithOverlays { // Your content here } This will expose a LocalOverlayHost composition local that can be used by UIs to show overlays.","title":"Installation"},{"location":"presenter/","text":"Presenter \u00b6 The core Presenter interface is this: interface Presenter < UiState : CircuitUiState > { @Composable fun present (): UiState } Presenters are solely intended to be business logic for your UI and a translation layer in front of your data layers. They are generally Dagger-injected types as the data layers they interpret are usually coming from the DI graph. In simple cases, they can be typed as a simple @Composable presenter function and Circuit code gen (TODO link) can generate the corresponding interface and (TODO link) factory for you. A very simple presenter can look like this: class FavoritesPresenter (...) : Presenter < State > { @Composable override fun present (): State { var favorites by remember { mutableStateOf ( < initial > ) } return State ( favorites ) { event -> ... } } } In this example, the present() function simply computes a state and returns it. If it has UI events to handle, an eventSink: (Event) -> Unit property should be exposed in the State type it returns. With DI, the above example becomes something more like this: class FavoritesPresenter @AssistedInject constructor ( @Assisted private val screen : FavoritesScreen , @Assisted private val navigator : Navigator , private val favoritesRepository : FavoritesRepository ) : Presenter < State > { @Composable override fun present (): State { // ... } @AssistedFactory fun interface Factory { fun create ( screen : FavoritesScreen , navigator : Navigator ): FavoritesPresenter } } Assisted injection allows passing on the screen and navigator from the relevant Presenter.Factory to this presenter for further reference. When dealing with nested presenters, a presenter could bypass implementing a class entirely by simply being written as a function that other presenters can use. // From cashapp/molecule's README examples @Composable fun ProfilePresenter ( userFlow : Flow < User > , balanceFlow : Flow < Long > , ): ProfileModel { val user by userFlow . collectAsState ( null ) val balance by balanceFlow . collectAsState ( 0L ) return if ( user == null ) { Loading } else { Data ( user . name , balance ) } } Presenters can present other presenters by injecting their assisted factories/providers, but note that this makes them a composite presenter that is now assuming responsibility for managing state of multiple nested presenters. We have an example of this in the Circuit repo . Retention \u00b6 There are three types of composable retention functions used in Circuit. remember \u2013 from Compose, remembers a value across recompositions. Can be any type. rememberRetained \u2013 custom, remembers a value across recompositions and configuration changes. Can be any type, but should not retain leak-able things like Navigator instances or Context instances. Backed by a hidden ViewModel on Android. rememberSaveable \u2013 from Compose, remembers a value across recompositions, configuration changes, and process death. Must be Parcelable or implement a custom Saver , should not retain leakable things like Navigator instances or Context instances. Backed by the framework saved instance state system. Developers should use the right tool accordingly depending on their use case. Consider these three examples. The first one will preserve the count value across recompositions, but not configuration changes or process death. @Composable fun CounterPresenter (): CounterState { var count by remember { mutableStateOf ( 0 ) } return CounterState ( count ) { event -> when ( event ) { is CounterEvent . Increment -> count ++ is CounterEvent . Decrement -> count -- } } } The second one will preserve the state across recompositions and configuration changes, but not process death. @Composable fun CounterPresenter (): CounterState { var count by rememberRetained { mutableStateOf ( 0 ) } return CounterState ( count ) { event -> when ( event ) { is CounterEvent . Increment -> count ++ is CounterEvent . Decrement -> count -- } } } The third case will preserve the count state across recompositions, configuration changes, and process death. However, it only works with primitives or Parcelable state types. @Composable fun CounterPresenter (): CounterState { var count by rememberSaveable { mutableStateOf ( 0 ) } return CounterState ( count ) { event -> when ( event ) { is CounterEvent . Increment -> count ++ is CounterEvent . Decrement -> count -- } } }","title":"Presenter"},{"location":"presenter/#presenter","text":"The core Presenter interface is this: interface Presenter < UiState : CircuitUiState > { @Composable fun present (): UiState } Presenters are solely intended to be business logic for your UI and a translation layer in front of your data layers. They are generally Dagger-injected types as the data layers they interpret are usually coming from the DI graph. In simple cases, they can be typed as a simple @Composable presenter function and Circuit code gen (TODO link) can generate the corresponding interface and (TODO link) factory for you. A very simple presenter can look like this: class FavoritesPresenter (...) : Presenter < State > { @Composable override fun present (): State { var favorites by remember { mutableStateOf ( < initial > ) } return State ( favorites ) { event -> ... } } } In this example, the present() function simply computes a state and returns it. If it has UI events to handle, an eventSink: (Event) -> Unit property should be exposed in the State type it returns. With DI, the above example becomes something more like this: class FavoritesPresenter @AssistedInject constructor ( @Assisted private val screen : FavoritesScreen , @Assisted private val navigator : Navigator , private val favoritesRepository : FavoritesRepository ) : Presenter < State > { @Composable override fun present (): State { // ... } @AssistedFactory fun interface Factory { fun create ( screen : FavoritesScreen , navigator : Navigator ): FavoritesPresenter } } Assisted injection allows passing on the screen and navigator from the relevant Presenter.Factory to this presenter for further reference. When dealing with nested presenters, a presenter could bypass implementing a class entirely by simply being written as a function that other presenters can use. // From cashapp/molecule's README examples @Composable fun ProfilePresenter ( userFlow : Flow < User > , balanceFlow : Flow < Long > , ): ProfileModel { val user by userFlow . collectAsState ( null ) val balance by balanceFlow . collectAsState ( 0L ) return if ( user == null ) { Loading } else { Data ( user . name , balance ) } } Presenters can present other presenters by injecting their assisted factories/providers, but note that this makes them a composite presenter that is now assuming responsibility for managing state of multiple nested presenters. We have an example of this in the Circuit repo .","title":"Presenter"},{"location":"presenter/#retention","text":"There are three types of composable retention functions used in Circuit. remember \u2013 from Compose, remembers a value across recompositions. Can be any type. rememberRetained \u2013 custom, remembers a value across recompositions and configuration changes. Can be any type, but should not retain leak-able things like Navigator instances or Context instances. Backed by a hidden ViewModel on Android. rememberSaveable \u2013 from Compose, remembers a value across recompositions, configuration changes, and process death. Must be Parcelable or implement a custom Saver , should not retain leakable things like Navigator instances or Context instances. Backed by the framework saved instance state system. Developers should use the right tool accordingly depending on their use case. Consider these three examples. The first one will preserve the count value across recompositions, but not configuration changes or process death. @Composable fun CounterPresenter (): CounterState { var count by remember { mutableStateOf ( 0 ) } return CounterState ( count ) { event -> when ( event ) { is CounterEvent . Increment -> count ++ is CounterEvent . Decrement -> count -- } } } The second one will preserve the state across recompositions and configuration changes, but not process death. @Composable fun CounterPresenter (): CounterState { var count by rememberRetained { mutableStateOf ( 0 ) } return CounterState ( count ) { event -> when ( event ) { is CounterEvent . Increment -> count ++ is CounterEvent . Decrement -> count -- } } } The third case will preserve the count state across recompositions, configuration changes, and process death. However, it only works with primitives or Parcelable state types. @Composable fun CounterPresenter (): CounterState { var count by rememberSaveable { mutableStateOf ( 0 ) } return CounterState ( count ) { event -> when ( event ) { is CounterEvent . Increment -> count ++ is CounterEvent . Decrement -> count -- } } }","title":"Retention"},{"location":"screen/","text":"Screen \u00b6 Screens are keys for Presenter and UI pairings. Semantically, the pairing of a Presenter and UI for a given Screen key is called a circuit. The core Screen interface is this: interface Screen : Parcelable These types are Parcelable for saveability in our backstack and easy deeplinking. A Screen can be a simple marker object type or a data object with information to pass on. @Parcelize data class AddFavoritesScreen ( val externalId : UUID ) : Screen These are used by Navigator s (when called from presenters) or CircuitContent (when called from UIs) to start a new sub-circuit or nested circuit. // In a presenter class fun showAddFavorites () { navigator . goTo ( AddFavoritesScreen ( externalId = uuidGenerator . generate () ) ) } The information passed into a screen can also be used to interact with the data layer. In the example here, we are getting the externalId from the screen in order to get information back from our repository. // In a presenter class class AddFavoritesPresenter @AssistedInject constructor ( @Assisted private val screen : AddFavoritesScreen , private val favoritesRepository : FavoritesRepository , ) : Presenter < AddFavoritesScreen . State > { @Composable override fun present () : AddFavoritesScreen . State { val favorite = favoritesRepository . getFavorite ( screen . externalId ) // ... } }","title":"Screen"},{"location":"screen/#screen","text":"Screens are keys for Presenter and UI pairings. Semantically, the pairing of a Presenter and UI for a given Screen key is called a circuit. The core Screen interface is this: interface Screen : Parcelable These types are Parcelable for saveability in our backstack and easy deeplinking. A Screen can be a simple marker object type or a data object with information to pass on. @Parcelize data class AddFavoritesScreen ( val externalId : UUID ) : Screen These are used by Navigator s (when called from presenters) or CircuitContent (when called from UIs) to start a new sub-circuit or nested circuit. // In a presenter class fun showAddFavorites () { navigator . goTo ( AddFavoritesScreen ( externalId = uuidGenerator . generate () ) ) } The information passed into a screen can also be used to interact with the data layer. In the example here, we are getting the externalId from the screen in order to get information back from our repository. // In a presenter class class AddFavoritesPresenter @AssistedInject constructor ( @Assisted private val screen : AddFavoritesScreen , private val favoritesRepository : FavoritesRepository , ) : Presenter < AddFavoritesScreen . State > { @Composable override fun present () : AddFavoritesScreen . State { val favorite = favoritesRepository . getFavorite ( screen . externalId ) // ... } }","title":"Screen"},{"location":"setup/","text":"Setting up Circuit \u00b6 Setting up Circuit is a breeze! Just add the following to your build: Installation \u00b6 dependencies { implementation ( \"com.slack.circuit:circuit-core:<version>\" ) } Setup \u00b6 Android \u00b6 Circuit requires two headless ViewModel s to be available in your application: BackStackRecordLocalProviderViewModel and Continuity . These would usually be wired up in a DI framework like Dagger, but a simple ViewModelProvider.Factory can be used as well. val circuitViewModelProviderFactory = object : ViewModelProvider . Factory { override fun < T : ViewModel > create ( modelClass : Class < T > ): T { return when ( modelClass ) { BackStackRecordLocalProviderViewModel :: class . java -> BackStackRecordLocalProviderViewModel () Continuity :: class . java -> Continuity () else -> ... } as T } } JVM \u00b6 No extra configuration needed! Platform Support \u00b6 Circuit is a multiplatform library, but not all features are available on all platforms. The following table shows which features are available on which platforms: \u2705 Available \u274c Not available \u2013 Not applicable Feature Android JVM Backstack \u2705 \u2705 CircuitContent \u2705 \u2705 ContentWithOverlays \u2705 \u2705 NavigableCircuitContent \u2705 \u274c Navigator \u2705 \u2705 SaveableBackstack \u2705 \u2013 rememberCircuitNavigator \u2705 \u274c rememberRetained \u2705 \u2705","title":"Setting up Circuit"},{"location":"setup/#setting-up-circuit","text":"Setting up Circuit is a breeze! Just add the following to your build:","title":"Setting up Circuit"},{"location":"setup/#installation","text":"dependencies { implementation ( \"com.slack.circuit:circuit-core:<version>\" ) }","title":"Installation"},{"location":"setup/#setup","text":"","title":"Setup"},{"location":"setup/#android","text":"Circuit requires two headless ViewModel s to be available in your application: BackStackRecordLocalProviderViewModel and Continuity . These would usually be wired up in a DI framework like Dagger, but a simple ViewModelProvider.Factory can be used as well. val circuitViewModelProviderFactory = object : ViewModelProvider . Factory { override fun < T : ViewModel > create ( modelClass : Class < T > ): T { return when ( modelClass ) { BackStackRecordLocalProviderViewModel :: class . java -> BackStackRecordLocalProviderViewModel () Continuity :: class . java -> Continuity () else -> ... } as T } }","title":"Android"},{"location":"setup/#jvm","text":"No extra configuration needed!","title":"JVM"},{"location":"setup/#platform-support","text":"Circuit is a multiplatform library, but not all features are available on all platforms. The following table shows which features are available on which platforms: \u2705 Available \u274c Not available \u2013 Not applicable Feature Android JVM Backstack \u2705 \u2705 CircuitContent \u2705 \u2705 ContentWithOverlays \u2705 \u2705 NavigableCircuitContent \u2705 \u274c Navigator \u2705 \u2705 SaveableBackstack \u2705 \u2013 rememberCircuitNavigator \u2705 \u274c rememberRetained \u2705 \u2705","title":"Platform Support"},{"location":"states-and-events/","text":"States and Events \u00b6 The core state and event interfaces in Circuit are CircuitUiState and CircuitUiEvent . All state and event types should implement/extend these marker interfaces. Presenters are simple functions that determine and return composable states. UIs are simple functions that render states. Uis can emit events via eventSink properties in state classes, which presenters then handle. These are the core building blocks! States and events should be immutable value types. Wait, event callbacks in state types? Yep! This may feel like a departure from how you\u2019ve written UDF patterns in the past, but we really like it. We tried different patterns before with event Flow s and having Circuit internals manage these for you, but we found they came with tradeoffs and friction points that we could avoid by just treating event emissions as another aspect of state. The end result is a tidier structure of state + event flows. Simpler cognitive overheads due to not always using Flow for events, which comes with caveats in compose (wrapping operators in remember calls, pipelining nested event flows, etc) Simple event-less UIs \u2013 state just doesn\u2019t have an event sink. Simpler testing \u2013 no manual event flow needed. You end up writing more realistic tests where you tick along your presenter by emitting with its returned states directly. Different state types can have different event handling (e.g. Click may not make sense for Loading states). No internal ceremony around setting up a Channel and multicasting event streams. No risk of dropping events (unlike Flow ). Warning Due to this issue , you need to extract the eventSink into local variables first. Note Currently, while functions are treated as implicitly Stable by the compose compiler, they not skippable when they\u2019re non-composable Unit-returning lambdas with equal-but-unstable captures. This may change though, and would be another free benefit for this case. A longer-form writeup can be found in this PR .","title":"States and Events"},{"location":"states-and-events/#states-and-events","text":"The core state and event interfaces in Circuit are CircuitUiState and CircuitUiEvent . All state and event types should implement/extend these marker interfaces. Presenters are simple functions that determine and return composable states. UIs are simple functions that render states. Uis can emit events via eventSink properties in state classes, which presenters then handle. These are the core building blocks! States and events should be immutable value types. Wait, event callbacks in state types? Yep! This may feel like a departure from how you\u2019ve written UDF patterns in the past, but we really like it. We tried different patterns before with event Flow s and having Circuit internals manage these for you, but we found they came with tradeoffs and friction points that we could avoid by just treating event emissions as another aspect of state. The end result is a tidier structure of state + event flows. Simpler cognitive overheads due to not always using Flow for events, which comes with caveats in compose (wrapping operators in remember calls, pipelining nested event flows, etc) Simple event-less UIs \u2013 state just doesn\u2019t have an event sink. Simpler testing \u2013 no manual event flow needed. You end up writing more realistic tests where you tick along your presenter by emitting with its returned states directly. Different state types can have different event handling (e.g. Click may not make sense for Loading states). No internal ceremony around setting up a Channel and multicasting event streams. No risk of dropping events (unlike Flow ). Warning Due to this issue , you need to extract the eventSink into local variables first. Note Currently, while functions are treated as implicitly Stable by the compose compiler, they not skippable when they\u2019re non-composable Unit-returning lambdas with equal-but-unstable captures. This may change though, and would be another free benefit for this case. A longer-form writeup can be found in this PR .","title":"States and Events"},{"location":"testing/","text":"Testing \u00b6 Circuit is designed to make testing as easy as possible. Its core components are not mockable nor do they need to be mocked. Fakes are provided where needed, everything else can be used directly. Circuit will have a test artifact containing APIs to aid testing both presenters and composable UIs: Presenter.test() - an extension function that bridges the Compose and coroutines world. Use of this function is recommended for testing presenter state emissions and incoming UI events. Under the hood it leverages Molecule and Turbine . FakeNavigator - a test fake implementing the Circuit/Navigator interface. Use of this object is recommended when testing screen navigation (ie. goTo, pop/back). Installation \u00b6 Test helpers are available via the circuit-test artifact. testImplementation ( \"com.slack.circuit:circuit-test:<version>\" ) For Gradle JVM projects, you can use Gradle test fixtures syntax on the core circuit artifact. testImplementation ( testFixtures ( \"com.slack.circuit:circuit:<version>\" )) Example \u00b6 Testing a Circuit Presenter and UI is a breeze! Consider the following example: data class Favorite ( id : Long , ...) @Parcelable object FavoritesScreen : Screen { sealed interface State : CircuitUiState { object Loading : State object NoFavorites : State data class Results ( val list : List < Favorite > , val eventSink : ( Event ) -> Unit ) : State } sealed interface Event : CircuitUiEvent { data class ClickFavorite ( id : Long ): Event } } class FavoritesPresenter @Inject constructor ( navigator : Navigator , repo : FavoritesRepository ) : Presenter < State > { @Composable override fun present (): State { val favorites by produceState < List < Favorites >?> ( null ) { value = repo . getFavorites () } return when { favorites == null -> Loading favorites . isEmpty () -> NoFavorites else -> Results ( favorites ) { event -> when ( event ) { is ClickFavorite -> navigator . goTo ( FavoriteScreen ( event . id )) } } } } } @Composable fun FavoritesList ( state : FavoritesScreen . State ) { when ( state ) { Loading -> Text ( text = stringResource ( R . string . loading_favorites )) NoFavorites -> Text ( modifier = Modifier . testTag ( \"no favorites\" ), text = stringResource ( R . string . no_favorites ) ) is Results -> { Text ( text = \"Your Favorites\" ) LazyColumn { items ( state . list ) { Favorite ( it , state . eventSink ) } } } } } @Composable private fun Favorite ( favorite : Favorite , eventSink : ( FavoritesScreen . Event ) -> Unit ) { Row ( modifier = Modifier . testTag ( \"favorite\" ), onClick = { eventSink ( ClickFavorite ( favorite . id )) } ) { Image ( drawable = favorite . drawable , contentDescription = stringResource ( R . string . favorite_image_desc ) ) Text ( text = favorite . name ) Text ( text = favorite . date ) } } Presenter Unit Tests \u00b6 Here\u2019s a test to verify presenter emissions using the Presenter.test() helper. This function acts as a shorthand over Molecule + Turbine to give you a ReceiveTurbine.() -> Unit lambda. @Test fun `present - emit loading state then list of favorites` () = runTest { val favorites = listOf ( Favorite ( 1L , ...)) val repo = TestFavoritesRepository ( favorites ) val presenter = PetListPresenter ( navigator , repo ) presenter . test { assertThat ( awaitItem ()). isEqualTo ( PetListScreen . State . Loading ) val resultsItem = awaitItem () as Results assertThat ( resultsItem . favorites ). isEqualTo ( favorites ) } } The same helper can be used when testing how the presenter responds to incoming events : @Test fun `present - navigate to favorite screen` () = runTest { val repo = TestFavoritesRepository ( Favorite ( 123L )) val presenter = PetListPresenter ( navigator , repo ) presenter . test { assertThat ( awaitItem ()). isEqualTo ( PetListScreen . State . Loading ) val resultsItem = awaitItem () as Results assertThat ( resultsItem . favorites ). isEqualTo ( favorites ) val clickFavorite = FavoriteScreen . Event . ClickFavorite ( 123L ) // simulate user tapping favorite in UI resultsItem . eventSink ( clickFavorite ) assertThat ( navigator . awaitNextScreen ()). isEqualTo ( FavoriteScreen ( clickFavorite . id )) } } Android UI Instrumentation Tests \u00b6 UI tests can be driven directly through ComposeTestRule and use its Espresso-esque API for assertions: @Test fun favoritesList_show_favorites_for_result_state () = runTest { val favorites = listOf ( Favorite ( 1L , ...) composeTestRule . run { setContent { // bootstrap the UI in the desired state FavoritesList ( state = FavoriteScreen . State . Results ( favorites ) { /* event callback */ } ) } onNodeWithTag ( \"no favorites\" ). assertDoesNotExist () onNodeWithText ( \"Your Favorites\" ). assertIsDisplayed () onAllNodesWithTag ( \"favorite\" ). assertCountEquals ( 1 ) } } Future: Android UI Unit Tests via Paparazzi \u00b6 We\u2019ve started exploring use of Paparazzi , which allows us to render Android UI without a physical device or emulator. More to come soon, but in short it would work similar to the above but be for purely non-functional 1:1 state \u2194 UI tests. @Test fun previewFavorite () { paparazzi . snapshot { PreviewFavorite () } } These are easy to maintain and review in GitHub. Another neat idea is we think this will make it easy to stand up compose preview functions for IDE use and reuse them. // In your main source @Preview @Composable internal fun PreviewFavorite () { Favorite () } // In your unit test @Test fun previewFavorite () { paparazzi . snapshot { PreviewFavorite () } }","title":"Testing"},{"location":"testing/#testing","text":"Circuit is designed to make testing as easy as possible. Its core components are not mockable nor do they need to be mocked. Fakes are provided where needed, everything else can be used directly. Circuit will have a test artifact containing APIs to aid testing both presenters and composable UIs: Presenter.test() - an extension function that bridges the Compose and coroutines world. Use of this function is recommended for testing presenter state emissions and incoming UI events. Under the hood it leverages Molecule and Turbine . FakeNavigator - a test fake implementing the Circuit/Navigator interface. Use of this object is recommended when testing screen navigation (ie. goTo, pop/back).","title":"Testing"},{"location":"testing/#installation","text":"Test helpers are available via the circuit-test artifact. testImplementation ( \"com.slack.circuit:circuit-test:<version>\" ) For Gradle JVM projects, you can use Gradle test fixtures syntax on the core circuit artifact. testImplementation ( testFixtures ( \"com.slack.circuit:circuit:<version>\" ))","title":"Installation"},{"location":"testing/#example","text":"Testing a Circuit Presenter and UI is a breeze! Consider the following example: data class Favorite ( id : Long , ...) @Parcelable object FavoritesScreen : Screen { sealed interface State : CircuitUiState { object Loading : State object NoFavorites : State data class Results ( val list : List < Favorite > , val eventSink : ( Event ) -> Unit ) : State } sealed interface Event : CircuitUiEvent { data class ClickFavorite ( id : Long ): Event } } class FavoritesPresenter @Inject constructor ( navigator : Navigator , repo : FavoritesRepository ) : Presenter < State > { @Composable override fun present (): State { val favorites by produceState < List < Favorites >?> ( null ) { value = repo . getFavorites () } return when { favorites == null -> Loading favorites . isEmpty () -> NoFavorites else -> Results ( favorites ) { event -> when ( event ) { is ClickFavorite -> navigator . goTo ( FavoriteScreen ( event . id )) } } } } } @Composable fun FavoritesList ( state : FavoritesScreen . State ) { when ( state ) { Loading -> Text ( text = stringResource ( R . string . loading_favorites )) NoFavorites -> Text ( modifier = Modifier . testTag ( \"no favorites\" ), text = stringResource ( R . string . no_favorites ) ) is Results -> { Text ( text = \"Your Favorites\" ) LazyColumn { items ( state . list ) { Favorite ( it , state . eventSink ) } } } } } @Composable private fun Favorite ( favorite : Favorite , eventSink : ( FavoritesScreen . Event ) -> Unit ) { Row ( modifier = Modifier . testTag ( \"favorite\" ), onClick = { eventSink ( ClickFavorite ( favorite . id )) } ) { Image ( drawable = favorite . drawable , contentDescription = stringResource ( R . string . favorite_image_desc ) ) Text ( text = favorite . name ) Text ( text = favorite . date ) } }","title":"Example"},{"location":"testing/#presenter-unit-tests","text":"Here\u2019s a test to verify presenter emissions using the Presenter.test() helper. This function acts as a shorthand over Molecule + Turbine to give you a ReceiveTurbine.() -> Unit lambda. @Test fun `present - emit loading state then list of favorites` () = runTest { val favorites = listOf ( Favorite ( 1L , ...)) val repo = TestFavoritesRepository ( favorites ) val presenter = PetListPresenter ( navigator , repo ) presenter . test { assertThat ( awaitItem ()). isEqualTo ( PetListScreen . State . Loading ) val resultsItem = awaitItem () as Results assertThat ( resultsItem . favorites ). isEqualTo ( favorites ) } } The same helper can be used when testing how the presenter responds to incoming events : @Test fun `present - navigate to favorite screen` () = runTest { val repo = TestFavoritesRepository ( Favorite ( 123L )) val presenter = PetListPresenter ( navigator , repo ) presenter . test { assertThat ( awaitItem ()). isEqualTo ( PetListScreen . State . Loading ) val resultsItem = awaitItem () as Results assertThat ( resultsItem . favorites ). isEqualTo ( favorites ) val clickFavorite = FavoriteScreen . Event . ClickFavorite ( 123L ) // simulate user tapping favorite in UI resultsItem . eventSink ( clickFavorite ) assertThat ( navigator . awaitNextScreen ()). isEqualTo ( FavoriteScreen ( clickFavorite . id )) } }","title":"Presenter Unit Tests"},{"location":"testing/#android-ui-instrumentation-tests","text":"UI tests can be driven directly through ComposeTestRule and use its Espresso-esque API for assertions: @Test fun favoritesList_show_favorites_for_result_state () = runTest { val favorites = listOf ( Favorite ( 1L , ...) composeTestRule . run { setContent { // bootstrap the UI in the desired state FavoritesList ( state = FavoriteScreen . State . Results ( favorites ) { /* event callback */ } ) } onNodeWithTag ( \"no favorites\" ). assertDoesNotExist () onNodeWithText ( \"Your Favorites\" ). assertIsDisplayed () onAllNodesWithTag ( \"favorite\" ). assertCountEquals ( 1 ) } }","title":"Android UI Instrumentation Tests"},{"location":"testing/#future-android-ui-unit-tests-via-paparazzi","text":"We\u2019ve started exploring use of Paparazzi , which allows us to render Android UI without a physical device or emulator. More to come soon, but in short it would work similar to the above but be for purely non-functional 1:1 state \u2194 UI tests. @Test fun previewFavorite () { paparazzi . snapshot { PreviewFavorite () } } These are easy to maintain and review in GitHub. Another neat idea is we think this will make it easy to stand up compose preview functions for IDE use and reuse them. // In your main source @Preview @Composable internal fun PreviewFavorite () { Favorite () } // In your unit test @Test fun previewFavorite () { paparazzi . snapshot { PreviewFavorite () } }","title":"Future: Android UI Unit Tests via Paparazzi"},{"location":"ui/","text":"UI \u00b6 The core Ui interface is simply this: interface Ui < UiState : CircuitUiState > { @Composable fun Content ( state : UiState ) } Like presenters, simple UIs can also skip the class all together for use in other UIs. Core unit of granularity is just the @Composable function. In fact, when implementing these in practice they rarely use dependency injection at all and can normally just be written as top-level composable functions annotated with @CircuitInject . @CircuitInject < FavoritesScreen > // Relevant DI wiring is generated @Composable private fun Favorites ( state : FavoritesState ) { // ... } Writing UIs like this has a number of benefits. Functions-only nudges developers toward writing idiomatic compose code and not keeping un-scoped/un-observable state elsewhere (such as class properties). These functions are extremely easy to stand up in tests. These functions are extremely easy to stand up in Compose preview functions. Let\u2019s look a little more closely at the last bullet point about preview functions. With the above example, we can easily stand up previews for all of our different states! @Preview @Composable private fun PreviewFavorites () = Favorites ( FavoritesState ( listOf ( \"Reeses\" , \"Lola\" )) @Preview @Composable private fun PreviewEmptyFavorites () = Favorites ( FavoritesState ( listOf ()) TODO image sample of IDE preview","title":"Ui"},{"location":"ui/#ui","text":"The core Ui interface is simply this: interface Ui < UiState : CircuitUiState > { @Composable fun Content ( state : UiState ) } Like presenters, simple UIs can also skip the class all together for use in other UIs. Core unit of granularity is just the @Composable function. In fact, when implementing these in practice they rarely use dependency injection at all and can normally just be written as top-level composable functions annotated with @CircuitInject . @CircuitInject < FavoritesScreen > // Relevant DI wiring is generated @Composable private fun Favorites ( state : FavoritesState ) { // ... } Writing UIs like this has a number of benefits. Functions-only nudges developers toward writing idiomatic compose code and not keeping un-scoped/un-observable state elsewhere (such as class properties). These functions are extremely easy to stand up in tests. These functions are extremely easy to stand up in Compose preview functions. Let\u2019s look a little more closely at the last bullet point about preview functions. With the above example, we can easily stand up previews for all of our different states! @Preview @Composable private fun PreviewFavorites () = Favorites ( FavoritesState ( listOf ( \"Reeses\" , \"Lola\" )) @Preview @Composable private fun PreviewEmptyFavorites () = Favorites ( FavoritesState ( listOf ()) TODO image sample of IDE preview","title":"UI"},{"location":"api/0.x/","text":"// circuit-test circuit-test \u00b6 Packages \u00b6 Name com.slack.circuit.test","title":"Index"},{"location":"api/0.x/#circuit-test","text":"","title":"circuit-test"},{"location":"api/0.x/#packages","text":"Name com.slack.circuit.test","title":"Packages"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/","text":"// backstack / com.slack.circuit.backstack Package-level declarations \u00b6 Types \u00b6 Name Summary BackStack [common] @ Stable interface BackStack < R : BackStack.Record > : Iterable < R > A caller-supplied stack of Record s for presentation with the Navigator composable. Iteration order is top-first (first element is the top of the stack). BackStackRecordLocalProvider [common] fun interface BackStackRecordLocalProvider <in R : BackStack.Record > BackStackRecordLocalProviderViewModel [android] class BackStackRecordLocalProviderViewModel : ViewModel NavDecoration [android] @ Stable interface NavDecoration Presentation logic for currently visible routes of a navigable UI. ProvidedValues [common] fun interface ProvidedValues SaveableBackStack [android] class SaveableBackStack : BackStack< SaveableBackStack.Record > A BackStack that supports saving its state via rememberSaveable . See rememberSaveableBackStack . SaveableStateRegistryBackStackRecordLocalProvider [android] object SaveableStateRegistryBackStackRecordLocalProvider : BackStackRecordLocalProvider<BackStack.Record> A BackStackRecordLocalProvider that provides a SaveableStateRegistry for each record. Functions \u00b6 Name Summary popUntil [android] inline fun SaveableBackStack . popUntil (predicate: ( SaveableBackStack.Record ) -> Boolean ) providedValuesForBackStack [common] @ Composable fun < R : BackStack.Record > providedValuesForBackStack (backStack: BackStack < R >, stackLocalProviders: List < BackStackRecordLocalProvider < R >> = emptyList(), includeDefaults: Boolean = true): Map < R , ProvidedValues > push [android] fun SaveableBackStack . push (route: String , args: Map < String , Any ?> = emptyMap()) rememberSaveableBackStack [android] @ Composable fun rememberSaveableBackStack (init: SaveableBackStack .() -> Unit ): SaveableBackStack Properties \u00b6 Name Summary isAtRoot [common] val BackStack <*>. isAtRoot : Boolean true if the BackStack contains exactly one record. isEmpty [common] val BackStack <*>. isEmpty : Boolean true if the BackStack contains no records. BackStack.firstOrNull will return null .","title":"backstack"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/#package-level-declarations","text":"","title":"Package-level declarations"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/#types","text":"Name Summary BackStack [common] @ Stable interface BackStack < R : BackStack.Record > : Iterable < R > A caller-supplied stack of Record s for presentation with the Navigator composable. Iteration order is top-first (first element is the top of the stack). BackStackRecordLocalProvider [common] fun interface BackStackRecordLocalProvider <in R : BackStack.Record > BackStackRecordLocalProviderViewModel [android] class BackStackRecordLocalProviderViewModel : ViewModel NavDecoration [android] @ Stable interface NavDecoration Presentation logic for currently visible routes of a navigable UI. ProvidedValues [common] fun interface ProvidedValues SaveableBackStack [android] class SaveableBackStack : BackStack< SaveableBackStack.Record > A BackStack that supports saving its state via rememberSaveable . See rememberSaveableBackStack . SaveableStateRegistryBackStackRecordLocalProvider [android] object SaveableStateRegistryBackStackRecordLocalProvider : BackStackRecordLocalProvider<BackStack.Record> A BackStackRecordLocalProvider that provides a SaveableStateRegistry for each record.","title":"Types"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/#functions","text":"Name Summary popUntil [android] inline fun SaveableBackStack . popUntil (predicate: ( SaveableBackStack.Record ) -> Boolean ) providedValuesForBackStack [common] @ Composable fun < R : BackStack.Record > providedValuesForBackStack (backStack: BackStack < R >, stackLocalProviders: List < BackStackRecordLocalProvider < R >> = emptyList(), includeDefaults: Boolean = true): Map < R , ProvidedValues > push [android] fun SaveableBackStack . push (route: String , args: Map < String , Any ?> = emptyMap()) rememberSaveableBackStack [android] @ Composable fun rememberSaveableBackStack (init: SaveableBackStack .() -> Unit ): SaveableBackStack","title":"Functions"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/#properties","text":"Name Summary isAtRoot [common] val BackStack <*>. isAtRoot : Boolean true if the BackStack contains exactly one record. isEmpty [common] val BackStack <*>. isEmpty : Boolean true if the BackStack contains no records. BackStack.firstOrNull will return null .","title":"Properties"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/is-at-root/","text":"// backstack / com.slack.circuit.backstack / isAtRoot isAtRoot \u00b6 [common]\\ val BackStack <*>. isAtRoot : Boolean true if the BackStack contains exactly one record.","title":"Is at root"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/is-at-root/#isatroot","text":"[common]\\ val BackStack <*>. isAtRoot : Boolean true if the BackStack contains exactly one record.","title":"isAtRoot"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/is-empty/","text":"// backstack / com.slack.circuit.backstack / isEmpty isEmpty \u00b6 [common]\\ val BackStack <*>. isEmpty : Boolean true if the BackStack contains no records. BackStack.firstOrNull will return null .","title":"Is empty"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/is-empty/#isempty","text":"[common]\\ val BackStack <*>. isEmpty : Boolean true if the BackStack contains no records. BackStack.firstOrNull will return null .","title":"isEmpty"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/pop-until/","text":"// backstack / com.slack.circuit.backstack / popUntil popUntil \u00b6 [android]\\ inline fun SaveableBackStack . popUntil (predicate: ( SaveableBackStack.Record ) -> Boolean )","title":"Pop until"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/pop-until/#popuntil","text":"[android]\\ inline fun SaveableBackStack . popUntil (predicate: ( SaveableBackStack.Record ) -> Boolean )","title":"popUntil"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/provided-values-for-back-stack/","text":"// backstack / com.slack.circuit.backstack / providedValuesForBackStack providedValuesForBackStack \u00b6 [common]\\ @ Composable fun < R : BackStack.Record > providedValuesForBackStack (backStack: BackStack < R >, stackLocalProviders: List < BackStackRecordLocalProvider < R >> = emptyList(), includeDefaults: Boolean = true): Map < R , ProvidedValues >","title":"Provided values for back stack"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/provided-values-for-back-stack/#providedvaluesforbackstack","text":"[common]\\ @ Composable fun < R : BackStack.Record > providedValuesForBackStack (backStack: BackStack < R >, stackLocalProviders: List < BackStackRecordLocalProvider < R >> = emptyList(), includeDefaults: Boolean = true): Map < R , ProvidedValues >","title":"providedValuesForBackStack"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/push/","text":"// backstack / com.slack.circuit.backstack / push push \u00b6 [android]\\ fun SaveableBackStack . push (route: String , args: Map < String , Any ?> = emptyMap())","title":"Push"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/push/#push","text":"[android]\\ fun SaveableBackStack . push (route: String , args: Map < String , Any ?> = emptyMap())","title":"push"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/remember-saveable-back-stack/","text":"// backstack / com.slack.circuit.backstack / rememberSaveableBackStack rememberSaveableBackStack \u00b6 [android]\\ @ Composable fun rememberSaveableBackStack (init: SaveableBackStack .() -> Unit ): SaveableBackStack","title":"Remember saveable back stack"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/remember-saveable-back-stack/#remembersaveablebackstack","text":"[android]\\ @ Composable fun rememberSaveableBackStack (init: SaveableBackStack .() -> Unit ): SaveableBackStack","title":"rememberSaveableBackStack"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/","text":"// backstack / com.slack.circuit.backstack / BackStack BackStack \u00b6 [common]\\ @ Stable interface BackStack < R : BackStack.Record > : Iterable < R > A caller-supplied stack of Record s for presentation with the Navigator composable. Iteration order is top-first (first element is the top of the stack). Types \u00b6 Name Summary Record [common] interface Record Functions \u00b6 Name Summary iterator [common] abstract operator fun iterator (): Iterator < R > pop [common] abstract fun pop (): R ? Attempt to pop the top item off of the back stack, returning the popped Record if popping was successful or null if no entry was popped. Properties \u00b6 Name Summary size [common] abstract val size : Int The number of records contained in this BackStack that will be seen by an iterator. Inheritors \u00b6 Name SaveableBackStack Extensions \u00b6 Name Summary isAtRoot [common] val BackStack <*>. isAtRoot : Boolean true if the BackStack contains exactly one record. isEmpty [common] val BackStack <*>. isEmpty : Boolean true if the BackStack contains no records. BackStack.firstOrNull will return null .","title":"Index"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/#backstack","text":"[common]\\ @ Stable interface BackStack < R : BackStack.Record > : Iterable < R > A caller-supplied stack of Record s for presentation with the Navigator composable. Iteration order is top-first (first element is the top of the stack).","title":"BackStack"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/#types","text":"Name Summary Record [common] interface Record","title":"Types"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/#functions","text":"Name Summary iterator [common] abstract operator fun iterator (): Iterator < R > pop [common] abstract fun pop (): R ? Attempt to pop the top item off of the back stack, returning the popped Record if popping was successful or null if no entry was popped.","title":"Functions"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/#properties","text":"Name Summary size [common] abstract val size : Int The number of records contained in this BackStack that will be seen by an iterator.","title":"Properties"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/#inheritors","text":"Name SaveableBackStack","title":"Inheritors"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/#extensions","text":"Name Summary isAtRoot [common] val BackStack <*>. isAtRoot : Boolean true if the BackStack contains exactly one record. isEmpty [common] val BackStack <*>. isEmpty : Boolean true if the BackStack contains no records. BackStack.firstOrNull will return null .","title":"Extensions"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/pop/","text":"// backstack / com.slack.circuit.backstack / BackStack / pop pop \u00b6 [common]\\ abstract fun pop (): R ? Attempt to pop the top item off of the back stack, returning the popped Record if popping was successful or null if no entry was popped.","title":"Pop"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/pop/#pop","text":"[common]\\ abstract fun pop (): R ? Attempt to pop the top item off of the back stack, returning the popped Record if popping was successful or null if no entry was popped.","title":"pop"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/size/","text":"// backstack / com.slack.circuit.backstack / BackStack / size size \u00b6 [common]\\ abstract val size : Int The number of records contained in this BackStack that will be seen by an iterator.","title":"Size"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/size/#size","text":"[common]\\ abstract val size : Int The number of records contained in this BackStack that will be seen by an iterator.","title":"size"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/-record/","text":"// backstack / com.slack.circuit.backstack / BackStack / Record Record \u00b6 [common]\\ interface Record Properties \u00b6 Name Summary key [common] abstract val key : String A value that identifies this record uniquely, even if it shares the same route with another record. This key may be used by BackStackRecordLocalProvider s to associate presentation data with a record across composition recreation. route [common] abstract val route : String The name of the route that should present this record. Inheritors \u00b6 Name Record","title":"Index"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/-record/#record","text":"[common]\\ interface Record","title":"Record"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/-record/#properties","text":"Name Summary key [common] abstract val key : String A value that identifies this record uniquely, even if it shares the same route with another record. This key may be used by BackStackRecordLocalProvider s to associate presentation data with a record across composition recreation. route [common] abstract val route : String The name of the route that should present this record.","title":"Properties"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/-record/#inheritors","text":"Name Record","title":"Inheritors"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/-record/key/","text":"// backstack / com.slack.circuit.backstack / BackStack / Record / key key \u00b6 [common]\\ abstract val key : String A value that identifies this record uniquely, even if it shares the same route with another record. This key may be used by BackStackRecordLocalProvider s to associate presentation data with a record across composition recreation. key MUST NOT change for the life of the record.","title":"Key"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/-record/key/#key","text":"[common]\\ abstract val key : String A value that identifies this record uniquely, even if it shares the same route with another record. This key may be used by BackStackRecordLocalProvider s to associate presentation data with a record across composition recreation. key MUST NOT change for the life of the record.","title":"key"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/-record/route/","text":"// backstack / com.slack.circuit.backstack / BackStack / Record / route route \u00b6 [common]\\ abstract val route : String The name of the route that should present this record.","title":"Route"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack/-record/route/#route","text":"[common]\\ abstract val route : String The name of the route that should present this record.","title":"route"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack-record-local-provider/","text":"// backstack / com.slack.circuit.backstack / BackStackRecordLocalProvider BackStackRecordLocalProvider \u00b6 [common]\\ fun interface BackStackRecordLocalProvider <in R : BackStack.Record > Functions \u00b6 Name Summary providedValuesFor [common] @ Composable abstract fun providedValuesFor (record: R ): ProvidedValues Inheritors \u00b6 Name SaveableStateRegistryBackStackRecordLocalProvider","title":"Index"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack-record-local-provider/#backstackrecordlocalprovider","text":"[common]\\ fun interface BackStackRecordLocalProvider <in R : BackStack.Record >","title":"BackStackRecordLocalProvider"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack-record-local-provider/#functions","text":"Name Summary providedValuesFor [common] @ Composable abstract fun providedValuesFor (record: R ): ProvidedValues","title":"Functions"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack-record-local-provider/#inheritors","text":"Name SaveableStateRegistryBackStackRecordLocalProvider","title":"Inheritors"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack-record-local-provider/provided-values-for/","text":"// backstack / com.slack.circuit.backstack / BackStackRecordLocalProvider / providedValuesFor providedValuesFor \u00b6 [common]\\ @ Composable abstract fun providedValuesFor (record: R ): ProvidedValues","title":"Provided values for"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack-record-local-provider/provided-values-for/#providedvaluesfor","text":"[common]\\ @ Composable abstract fun providedValuesFor (record: R ): ProvidedValues","title":"providedValuesFor"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack-record-local-provider-view-model/","text":"// backstack / com.slack.circuit.backstack / BackStackRecordLocalProviderViewModel BackStackRecordLocalProviderViewModel \u00b6 [android]\\ class BackStackRecordLocalProviderViewModel : ViewModel Constructors \u00b6 BackStackRecordLocalProviderViewModel [android] fun BackStackRecordLocalProviderViewModel () Functions \u00b6 Name Summary addCloseable [android] open fun addCloseable (@ NonNull p0: Closeable )","title":"Index"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack-record-local-provider-view-model/#backstackrecordlocalproviderviewmodel","text":"[android]\\ class BackStackRecordLocalProviderViewModel : ViewModel","title":"BackStackRecordLocalProviderViewModel"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack-record-local-provider-view-model/#constructors","text":"BackStackRecordLocalProviderViewModel [android] fun BackStackRecordLocalProviderViewModel ()","title":"Constructors"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack-record-local-provider-view-model/#functions","text":"Name Summary addCloseable [android] open fun addCloseable (@ NonNull p0: Closeable )","title":"Functions"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack-record-local-provider-view-model/-back-stack-record-local-provider-view-model/","text":"// backstack / com.slack.circuit.backstack / BackStackRecordLocalProviderViewModel / BackStackRecordLocalProviderViewModel BackStackRecordLocalProviderViewModel \u00b6 [android]\\ fun BackStackRecordLocalProviderViewModel ()","title":" back stack record local provider view model"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-back-stack-record-local-provider-view-model/-back-stack-record-local-provider-view-model/#backstackrecordlocalproviderviewmodel","text":"[android]\\ fun BackStackRecordLocalProviderViewModel ()","title":"BackStackRecordLocalProviderViewModel"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-nav-decoration/","text":"// backstack / com.slack.circuit.backstack / NavDecoration NavDecoration \u00b6 [android]\\ @ Stable interface NavDecoration Presentation logic for currently visible routes of a navigable UI. Functions \u00b6 Name Summary DecoratedContent [android] @ Composable abstract fun < T > DecoratedContent (arg: T , backStackDepth: Int , modifier: Modifier , content: @ Composable ( T ) -> Unit )","title":"Index"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-nav-decoration/#navdecoration","text":"[android]\\ @ Stable interface NavDecoration Presentation logic for currently visible routes of a navigable UI.","title":"NavDecoration"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-nav-decoration/#functions","text":"Name Summary DecoratedContent [android] @ Composable abstract fun < T > DecoratedContent (arg: T , backStackDepth: Int , modifier: Modifier , content: @ Composable ( T ) -> Unit )","title":"Functions"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-nav-decoration/-decorated-content/","text":"// backstack / com.slack.circuit.backstack / NavDecoration / DecoratedContent DecoratedContent \u00b6 [android]\\ @ Composable abstract fun < T > DecoratedContent (arg: T , backStackDepth: Int , modifier: Modifier , content: @ Composable ( T ) -> Unit )","title":" decorated content"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-nav-decoration/-decorated-content/#decoratedcontent","text":"[android]\\ @ Composable abstract fun < T > DecoratedContent (arg: T , backStackDepth: Int , modifier: Modifier , content: @ Composable ( T ) -> Unit )","title":"DecoratedContent"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-provided-values/","text":"// backstack / com.slack.circuit.backstack / ProvidedValues ProvidedValues \u00b6 [common]\\ fun interface ProvidedValues Functions \u00b6 Name Summary provideValues [common] @ Composable abstract fun provideValues (): List < ProvidedValue <*>>","title":"Index"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-provided-values/#providedvalues","text":"[common]\\ fun interface ProvidedValues","title":"ProvidedValues"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-provided-values/#functions","text":"Name Summary provideValues [common] @ Composable abstract fun provideValues (): List < ProvidedValue <*>>","title":"Functions"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-provided-values/provide-values/","text":"// backstack / com.slack.circuit.backstack / ProvidedValues / provideValues provideValues \u00b6 [common]\\ @ Composable abstract fun provideValues (): List < ProvidedValue <*>>","title":"Provide values"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-provided-values/provide-values/#providevalues","text":"[common]\\ @ Composable abstract fun provideValues (): List < ProvidedValue <*>>","title":"provideValues"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/","text":"// backstack / com.slack.circuit.backstack / SaveableBackStack SaveableBackStack \u00b6 [android]\\ class SaveableBackStack : BackStack< SaveableBackStack.Record > A BackStack that supports saving its state via rememberSaveable . See rememberSaveableBackStack . Constructors \u00b6 SaveableBackStack [android] fun SaveableBackStack () Types \u00b6 Name Summary Record [android] data class Record (val route: String , val args: Map < String , Any ?> = emptyMap(), val key: String = UUID.randomUUID().toString()) : BackStack.Record Functions \u00b6 Name Summary forEach [android] open fun forEach (p0: Consumer <in SaveableBackStack.Record >) iterator [android] open operator override fun iterator (): Iterator < SaveableBackStack.Record > pop [android] open override fun pop (): SaveableBackStack.Record ? Attempt to pop the top item off of the back stack, returning the popped Record if popping was successful or null if no entry was popped. push [android] fun push (record: SaveableBackStack.Record ) spliterator [android] open fun spliterator (): Spliterator < SaveableBackStack.Record > Properties \u00b6 Name Summary size [android] open override val size : Int The number of records contained in this BackStack that will be seen by an iterator. topRecord [android] val topRecord : SaveableBackStack.Record ? Extensions \u00b6 Name Summary isAtRoot [common] val BackStack <*>. isAtRoot : Boolean true if the BackStack contains exactly one record. isEmpty [common] val BackStack <*>. isEmpty : Boolean true if the BackStack contains no records. BackStack.firstOrNull will return null . popUntil [android] inline fun SaveableBackStack . popUntil (predicate: ( SaveableBackStack.Record ) -> Boolean ) push [android] fun SaveableBackStack . push (route: String , args: Map < String , Any ?> = emptyMap())","title":"Index"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/#saveablebackstack","text":"[android]\\ class SaveableBackStack : BackStack< SaveableBackStack.Record > A BackStack that supports saving its state via rememberSaveable . See rememberSaveableBackStack .","title":"SaveableBackStack"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/#constructors","text":"SaveableBackStack [android] fun SaveableBackStack ()","title":"Constructors"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/#types","text":"Name Summary Record [android] data class Record (val route: String , val args: Map < String , Any ?> = emptyMap(), val key: String = UUID.randomUUID().toString()) : BackStack.Record","title":"Types"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/#functions","text":"Name Summary forEach [android] open fun forEach (p0: Consumer <in SaveableBackStack.Record >) iterator [android] open operator override fun iterator (): Iterator < SaveableBackStack.Record > pop [android] open override fun pop (): SaveableBackStack.Record ? Attempt to pop the top item off of the back stack, returning the popped Record if popping was successful or null if no entry was popped. push [android] fun push (record: SaveableBackStack.Record ) spliterator [android] open fun spliterator (): Spliterator < SaveableBackStack.Record >","title":"Functions"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/#properties","text":"Name Summary size [android] open override val size : Int The number of records contained in this BackStack that will be seen by an iterator. topRecord [android] val topRecord : SaveableBackStack.Record ?","title":"Properties"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/#extensions","text":"Name Summary isAtRoot [common] val BackStack <*>. isAtRoot : Boolean true if the BackStack contains exactly one record. isEmpty [common] val BackStack <*>. isEmpty : Boolean true if the BackStack contains no records. BackStack.firstOrNull will return null . popUntil [android] inline fun SaveableBackStack . popUntil (predicate: ( SaveableBackStack.Record ) -> Boolean ) push [android] fun SaveableBackStack . push (route: String , args: Map < String , Any ?> = emptyMap())","title":"Extensions"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/-saveable-back-stack/","text":"// backstack / com.slack.circuit.backstack / SaveableBackStack / SaveableBackStack SaveableBackStack \u00b6 [android]\\ fun SaveableBackStack ()","title":" saveable back stack"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/-saveable-back-stack/#saveablebackstack","text":"[android]\\ fun SaveableBackStack ()","title":"SaveableBackStack"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/iterator/","text":"// backstack / com.slack.circuit.backstack / SaveableBackStack / iterator iterator \u00b6 [android]\\ open operator override fun iterator (): Iterator < SaveableBackStack.Record >","title":"Iterator"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/iterator/#iterator","text":"[android]\\ open operator override fun iterator (): Iterator < SaveableBackStack.Record >","title":"iterator"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/pop/","text":"// backstack / com.slack.circuit.backstack / SaveableBackStack / pop pop \u00b6 [android]\\ open override fun pop (): SaveableBackStack.Record ? Attempt to pop the top item off of the back stack, returning the popped Record if popping was successful or null if no entry was popped.","title":"Pop"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/pop/#pop","text":"[android]\\ open override fun pop (): SaveableBackStack.Record ? Attempt to pop the top item off of the back stack, returning the popped Record if popping was successful or null if no entry was popped.","title":"pop"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/push/","text":"// backstack / com.slack.circuit.backstack / SaveableBackStack / push push \u00b6 [android]\\ fun push (record: SaveableBackStack.Record )","title":"Push"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/push/#push","text":"[android]\\ fun push (record: SaveableBackStack.Record )","title":"push"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/size/","text":"// backstack / com.slack.circuit.backstack / SaveableBackStack / size size \u00b6 [android]\\ open override val size : Int The number of records contained in this BackStack that will be seen by an iterator.","title":"Size"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/size/#size","text":"[android]\\ open override val size : Int The number of records contained in this BackStack that will be seen by an iterator.","title":"size"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/top-record/","text":"// backstack / com.slack.circuit.backstack / SaveableBackStack / topRecord topRecord \u00b6 [android]\\ val topRecord : SaveableBackStack.Record ?","title":"Top record"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/top-record/#toprecord","text":"[android]\\ val topRecord : SaveableBackStack.Record ?","title":"topRecord"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/-record/","text":"// backstack / com.slack.circuit.backstack / SaveableBackStack / Record Record \u00b6 [android]\\ data class Record (val route: String , val args: Map < String , Any ?> = emptyMap(), val key: String = UUID.randomUUID().toString()) : BackStack.Record Constructors \u00b6 Record [android] fun Record (route: String , args: Map < String , Any ?> = emptyMap(), key: String = UUID.randomUUID().toString()) Properties \u00b6 Name Summary args [android] val args : Map < String , Any ?> key [android] open override val key : String A value that identifies this record uniquely, even if it shares the same route with another record. This key may be used by BackStackRecordLocalProviders to associate presentation data with a record across composition recreation. route [android] open override val route : String The name of the route that should present this record.","title":"Index"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/-record/#record","text":"[android]\\ data class Record (val route: String , val args: Map < String , Any ?> = emptyMap(), val key: String = UUID.randomUUID().toString()) : BackStack.Record","title":"Record"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/-record/#constructors","text":"Record [android] fun Record (route: String , args: Map < String , Any ?> = emptyMap(), key: String = UUID.randomUUID().toString())","title":"Constructors"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/-record/#properties","text":"Name Summary args [android] val args : Map < String , Any ?> key [android] open override val key : String A value that identifies this record uniquely, even if it shares the same route with another record. This key may be used by BackStackRecordLocalProviders to associate presentation data with a record across composition recreation. route [android] open override val route : String The name of the route that should present this record.","title":"Properties"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/-record/-record/","text":"// backstack / com.slack.circuit.backstack / SaveableBackStack / Record / Record Record \u00b6 [android]\\ fun Record (route: String , args: Map < String , Any ?> = emptyMap(), key: String = UUID.randomUUID().toString())","title":" record"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/-record/-record/#record","text":"[android]\\ fun Record (route: String , args: Map < String , Any ?> = emptyMap(), key: String = UUID.randomUUID().toString())","title":"Record"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/-record/args/","text":"// backstack / com.slack.circuit.backstack / SaveableBackStack / Record / args args \u00b6 [android]\\ val args : Map < String , Any ?>","title":"Args"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/-record/args/#args","text":"[android]\\ val args : Map < String , Any ?>","title":"args"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/-record/key/","text":"// backstack / com.slack.circuit.backstack / SaveableBackStack / Record / key key \u00b6 [android]\\ open override val key : String A value that identifies this record uniquely, even if it shares the same route with another record. This key may be used by BackStackRecordLocalProviders to associate presentation data with a record across composition recreation. key MUST NOT change for the life of the record.","title":"Key"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/-record/key/#key","text":"[android]\\ open override val key : String A value that identifies this record uniquely, even if it shares the same route with another record. This key may be used by BackStackRecordLocalProviders to associate presentation data with a record across composition recreation. key MUST NOT change for the life of the record.","title":"key"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/-record/route/","text":"// backstack / com.slack.circuit.backstack / SaveableBackStack / Record / route route \u00b6 [android]\\ open override val route : String The name of the route that should present this record.","title":"Route"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-back-stack/-record/route/#route","text":"[android]\\ open override val route : String The name of the route that should present this record.","title":"route"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-state-registry-back-stack-record-local-provider/","text":"// backstack / com.slack.circuit.backstack / SaveableStateRegistryBackStackRecordLocalProvider SaveableStateRegistryBackStackRecordLocalProvider \u00b6 [android]\\ object SaveableStateRegistryBackStackRecordLocalProvider : BackStackRecordLocalProvider<BackStack.Record> A BackStackRecordLocalProvider that provides a SaveableStateRegistry for each record. Functions \u00b6 Name Summary providedValuesFor [android] @ Composable open override fun providedValuesFor (record: BackStack.Record): ProvidedValues","title":"Index"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-state-registry-back-stack-record-local-provider/#saveablestateregistrybackstackrecordlocalprovider","text":"[android]\\ object SaveableStateRegistryBackStackRecordLocalProvider : BackStackRecordLocalProvider<BackStack.Record> A BackStackRecordLocalProvider that provides a SaveableStateRegistry for each record.","title":"SaveableStateRegistryBackStackRecordLocalProvider"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-state-registry-back-stack-record-local-provider/#functions","text":"Name Summary providedValuesFor [android] @ Composable open override fun providedValuesFor (record: BackStack.Record): ProvidedValues","title":"Functions"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-state-registry-back-stack-record-local-provider/provided-values-for/","text":"// backstack / com.slack.circuit.backstack / SaveableStateRegistryBackStackRecordLocalProvider / providedValuesFor providedValuesFor \u00b6 [android]\\ @ Composable open override fun providedValuesFor (record: BackStack.Record): ProvidedValues","title":"Provided values for"},{"location":"api/0.x/backstack/com.slack.circuit.backstack/-saveable-state-registry-back-stack-record-local-provider/provided-values-for/#providedvaluesfor","text":"[android]\\ @ Composable open override fun providedValuesFor (record: BackStack.Record): ProvidedValues","title":"providedValuesFor"},{"location":"api/0.x/circuit/com.slack.circuit/","text":"// circuit / com.slack.circuit Package-level declarations \u00b6 Types \u00b6 Name Summary CircuitConfig [common] @ Immutable class CircuitConfig CircuitConfig adapts presenter factories to their corresponding renderable ui factories using screens . Create instances using the Builder and create new CircuitContent with it to run presenter/UI pairings. CircuitUiEvent [common] @ Immutable interface CircuitUiEvent Marker interface for all UiEvent types. CircuitUiState [common] @ Immutable interface CircuitUiState Marker interface for all UiState types. EventListener [common] interface EventListener A listener for tracking the state changes of a given Screen . This can be used for instrumentation and other telemetry. LocalCircuitOwner [common] object LocalCircuitOwner NavEvent [common] interface NavEvent : CircuitUiEvent A sealed navigation interface intended to be used when making a navigation call back. Navigator [common] @ Stable interface Navigator A basic navigation interface for navigating between screens . NavigatorDefaults [android] object NavigatorDefaults Default values and common alternatives used by navigable composables. Presenter [common] interface Presenter < UiState : CircuitUiState > Presents a given UiState . Screen [common] expect interface Screen Represents an individual screen, used as a key for Presenter.Factory and Ui.Factory . [android, jvm] [android] actual interface Screen : Parcelable [jvm] actual interface Screen ScreenUi [common] data class ScreenUi (val ui: Ui <*>) Ui [common] interface Ui < UiState : CircuitUiState > Represents a composable UI for the given UiState . Conventionally, this should just be the return type of a ui function and a thin shim over a \"real\" implementation. Functions \u00b6 Name Summary BasicNavigableCircuitContent [android] @ Composable fun BasicNavigableCircuitContent (navigator: Navigator, backstack: SaveableBackStack, providedValues: Map <out BackStack.Record, ProvidedValues>, modifier: Modifier = Modifier, circuitConfig: CircuitConfig = LocalCircuitOwner.current, decoration: NavDecoration = NavigatorDefaults.EmptyDecoration, unavailableRoute: @ Composable ( String ) -> Unit = NavigatorDefaults.UnavailableRoute) CircuitCompositionLocals [common] @ Composable fun CircuitCompositionLocals (circuitConfig: CircuitConfig , content: @ Composable () -> Unit ) Provides the given circuitConfig as a CompositionLocal to all composables within content . Also adds any other composition locals that Circuit needs. CircuitContent [common] @ Composable fun CircuitContent (screen: Screen , circuitConfig: CircuitConfig = LocalCircuitOwner.current, unavailableContent: @ Composable (screen: Screen ) -> Unit ? = circuitConfig.onUnavailableContent) @ Composable fun CircuitContent (screen: Screen , onNavEvent: (event: NavEvent ) -> Unit , circuitConfig: CircuitConfig = LocalCircuitOwner.current, unavailableContent: @ Composable (screen: Screen ) -> Unit ? = circuitConfig.onUnavailableContent) NavigableCircuitContent [android] @ Composable fun NavigableCircuitContent (navigator: Navigator, backstack: SaveableBackStack, modifier: Modifier = Modifier, circuitConfig: CircuitConfig = LocalCircuitOwner.current, enableBackHandler: Boolean = true, providedValues: Map <out BackStack.Record, ProvidedValues> = providedValuesForBackStack(backstack), decoration: NavDecoration = NavigatorDefaults.DefaultDecoration, unavailableRoute: @ Composable ( String ) -> Unit = NavigatorDefaults.UnavailableRoute) onNavEvent [common] fun Navigator . onNavEvent (event: NavEvent ) A Circuit call back to help navigate to different screens. Intended to be used when forwarding NavEvent s from nested Presenter s. popUntil [common] fun Navigator . popUntil (predicate: ( Screen ) -> Boolean ) Calls Navigator.pop until the given predicate is matched or it pops the root. presenterOf [common] inline fun < UiState : CircuitUiState > presenterOf (crossinline body: @ Composable () -> UiState ): Presenter < UiState > Due to this bug in Studio, we can\u2019t write lambda impls of Presenter directly. This works around it by offering a shim function of the same name. Once it\u2019s fixed, we can remove this and make Presenter a fun interface instead. push [android] fun SaveableBackStack. push (screen: Screen ) rememberCircuitNavigator [android] @ Composable fun rememberCircuitNavigator (backstack: SaveableBackStack, onRootPop: () -> Unit = backDispatcherRootPop()): Navigator Returns a new Navigator for navigating within CircuitContents. ui [common] inline fun < UiState : CircuitUiState > ui (crossinline body: @ Composable (state: UiState ) -> Unit ): Ui < UiState > Due to this bug in Studio, we can\u2019t write lambda impls of Ui directly. This works around it by offering a shim function of the same name. Once it\u2019s fixed, we can remove this and make Ui a fun interface instead. Properties \u00b6 Name Summary screen [android] val SaveableBackStack.Record. screen : Screen","title":"circuit"},{"location":"api/0.x/circuit/com.slack.circuit/#package-level-declarations","text":"","title":"Package-level declarations"},{"location":"api/0.x/circuit/com.slack.circuit/#types","text":"Name Summary CircuitConfig [common] @ Immutable class CircuitConfig CircuitConfig adapts presenter factories to their corresponding renderable ui factories using screens . Create instances using the Builder and create new CircuitContent with it to run presenter/UI pairings. CircuitUiEvent [common] @ Immutable interface CircuitUiEvent Marker interface for all UiEvent types. CircuitUiState [common] @ Immutable interface CircuitUiState Marker interface for all UiState types. EventListener [common] interface EventListener A listener for tracking the state changes of a given Screen . This can be used for instrumentation and other telemetry. LocalCircuitOwner [common] object LocalCircuitOwner NavEvent [common] interface NavEvent : CircuitUiEvent A sealed navigation interface intended to be used when making a navigation call back. Navigator [common] @ Stable interface Navigator A basic navigation interface for navigating between screens . NavigatorDefaults [android] object NavigatorDefaults Default values and common alternatives used by navigable composables. Presenter [common] interface Presenter < UiState : CircuitUiState > Presents a given UiState . Screen [common] expect interface Screen Represents an individual screen, used as a key for Presenter.Factory and Ui.Factory . [android, jvm] [android] actual interface Screen : Parcelable [jvm] actual interface Screen ScreenUi [common] data class ScreenUi (val ui: Ui <*>) Ui [common] interface Ui < UiState : CircuitUiState > Represents a composable UI for the given UiState . Conventionally, this should just be the return type of a ui function and a thin shim over a \"real\" implementation.","title":"Types"},{"location":"api/0.x/circuit/com.slack.circuit/#functions","text":"Name Summary BasicNavigableCircuitContent [android] @ Composable fun BasicNavigableCircuitContent (navigator: Navigator, backstack: SaveableBackStack, providedValues: Map <out BackStack.Record, ProvidedValues>, modifier: Modifier = Modifier, circuitConfig: CircuitConfig = LocalCircuitOwner.current, decoration: NavDecoration = NavigatorDefaults.EmptyDecoration, unavailableRoute: @ Composable ( String ) -> Unit = NavigatorDefaults.UnavailableRoute) CircuitCompositionLocals [common] @ Composable fun CircuitCompositionLocals (circuitConfig: CircuitConfig , content: @ Composable () -> Unit ) Provides the given circuitConfig as a CompositionLocal to all composables within content . Also adds any other composition locals that Circuit needs. CircuitContent [common] @ Composable fun CircuitContent (screen: Screen , circuitConfig: CircuitConfig = LocalCircuitOwner.current, unavailableContent: @ Composable (screen: Screen ) -> Unit ? = circuitConfig.onUnavailableContent) @ Composable fun CircuitContent (screen: Screen , onNavEvent: (event: NavEvent ) -> Unit , circuitConfig: CircuitConfig = LocalCircuitOwner.current, unavailableContent: @ Composable (screen: Screen ) -> Unit ? = circuitConfig.onUnavailableContent) NavigableCircuitContent [android] @ Composable fun NavigableCircuitContent (navigator: Navigator, backstack: SaveableBackStack, modifier: Modifier = Modifier, circuitConfig: CircuitConfig = LocalCircuitOwner.current, enableBackHandler: Boolean = true, providedValues: Map <out BackStack.Record, ProvidedValues> = providedValuesForBackStack(backstack), decoration: NavDecoration = NavigatorDefaults.DefaultDecoration, unavailableRoute: @ Composable ( String ) -> Unit = NavigatorDefaults.UnavailableRoute) onNavEvent [common] fun Navigator . onNavEvent (event: NavEvent ) A Circuit call back to help navigate to different screens. Intended to be used when forwarding NavEvent s from nested Presenter s. popUntil [common] fun Navigator . popUntil (predicate: ( Screen ) -> Boolean ) Calls Navigator.pop until the given predicate is matched or it pops the root. presenterOf [common] inline fun < UiState : CircuitUiState > presenterOf (crossinline body: @ Composable () -> UiState ): Presenter < UiState > Due to this bug in Studio, we can\u2019t write lambda impls of Presenter directly. This works around it by offering a shim function of the same name. Once it\u2019s fixed, we can remove this and make Presenter a fun interface instead. push [android] fun SaveableBackStack. push (screen: Screen ) rememberCircuitNavigator [android] @ Composable fun rememberCircuitNavigator (backstack: SaveableBackStack, onRootPop: () -> Unit = backDispatcherRootPop()): Navigator Returns a new Navigator for navigating within CircuitContents. ui [common] inline fun < UiState : CircuitUiState > ui (crossinline body: @ Composable (state: UiState ) -> Unit ): Ui < UiState > Due to this bug in Studio, we can\u2019t write lambda impls of Ui directly. This works around it by offering a shim function of the same name. Once it\u2019s fixed, we can remove this and make Ui a fun interface instead.","title":"Functions"},{"location":"api/0.x/circuit/com.slack.circuit/#properties","text":"Name Summary screen [android] val SaveableBackStack.Record. screen : Screen","title":"Properties"},{"location":"api/0.x/circuit/com.slack.circuit/-basic-navigable-circuit-content/","text":"// circuit / com.slack.circuit / BasicNavigableCircuitContent BasicNavigableCircuitContent \u00b6 [android]\\ @ Composable fun BasicNavigableCircuitContent (navigator: Navigator, backstack: SaveableBackStack, providedValues: Map <out BackStack.Record, ProvidedValues>, modifier: Modifier = Modifier, circuitConfig: CircuitConfig = LocalCircuitOwner.current, decoration: NavDecoration = NavigatorDefaults.EmptyDecoration, unavailableRoute: @ Composable ( String ) -> Unit = NavigatorDefaults.UnavailableRoute)","title":" basic navigable circuit content"},{"location":"api/0.x/circuit/com.slack.circuit/-basic-navigable-circuit-content/#basicnavigablecircuitcontent","text":"[android]\\ @ Composable fun BasicNavigableCircuitContent (navigator: Navigator, backstack: SaveableBackStack, providedValues: Map <out BackStack.Record, ProvidedValues>, modifier: Modifier = Modifier, circuitConfig: CircuitConfig = LocalCircuitOwner.current, decoration: NavDecoration = NavigatorDefaults.EmptyDecoration, unavailableRoute: @ Composable ( String ) -> Unit = NavigatorDefaults.UnavailableRoute)","title":"BasicNavigableCircuitContent"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-composition-locals/","text":"// circuit / com.slack.circuit / CircuitCompositionLocals CircuitCompositionLocals \u00b6 [common]\\ @ Composable fun CircuitCompositionLocals (circuitConfig: CircuitConfig , content: @ Composable () -> Unit ) Provides the given circuitConfig as a CompositionLocal to all composables within content . Also adds any other composition locals that Circuit needs.","title":" circuit composition locals"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-composition-locals/#circuitcompositionlocals","text":"[common]\\ @ Composable fun CircuitCompositionLocals (circuitConfig: CircuitConfig , content: @ Composable () -> Unit ) Provides the given circuitConfig as a CompositionLocal to all composables within content . Also adds any other composition locals that Circuit needs.","title":"CircuitCompositionLocals"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-content/","text":"// circuit / com.slack.circuit / CircuitContent CircuitContent \u00b6 [common]\\ @ Composable fun CircuitContent (screen: Screen , circuitConfig: CircuitConfig = LocalCircuitOwner.current, unavailableContent: @ Composable (screen: Screen ) -> Unit ? = circuitConfig.onUnavailableContent) @ Composable fun CircuitContent (screen: Screen , onNavEvent: (event: NavEvent ) -> Unit , circuitConfig: CircuitConfig = LocalCircuitOwner.current, unavailableContent: @ Composable (screen: Screen ) -> Unit ? = circuitConfig.onUnavailableContent)","title":" circuit content"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-content/#circuitcontent","text":"[common]\\ @ Composable fun CircuitContent (screen: Screen , circuitConfig: CircuitConfig = LocalCircuitOwner.current, unavailableContent: @ Composable (screen: Screen ) -> Unit ? = circuitConfig.onUnavailableContent) @ Composable fun CircuitContent (screen: Screen , onNavEvent: (event: NavEvent ) -> Unit , circuitConfig: CircuitConfig = LocalCircuitOwner.current, unavailableContent: @ Composable (screen: Screen ) -> Unit ? = circuitConfig.onUnavailableContent)","title":"CircuitContent"},{"location":"api/0.x/circuit/com.slack.circuit/-navigable-circuit-content/","text":"// circuit / com.slack.circuit / NavigableCircuitContent NavigableCircuitContent \u00b6 [android]\\ @ Composable fun NavigableCircuitContent (navigator: Navigator, backstack: SaveableBackStack, modifier: Modifier = Modifier, circuitConfig: CircuitConfig = LocalCircuitOwner.current, enableBackHandler: Boolean = true, providedValues: Map <out BackStack.Record, ProvidedValues> = providedValuesForBackStack(backstack), decoration: NavDecoration = NavigatorDefaults.DefaultDecoration, unavailableRoute: @ Composable ( String ) -> Unit = NavigatorDefaults.UnavailableRoute)","title":" navigable circuit content"},{"location":"api/0.x/circuit/com.slack.circuit/-navigable-circuit-content/#navigablecircuitcontent","text":"[android]\\ @ Composable fun NavigableCircuitContent (navigator: Navigator, backstack: SaveableBackStack, modifier: Modifier = Modifier, circuitConfig: CircuitConfig = LocalCircuitOwner.current, enableBackHandler: Boolean = true, providedValues: Map <out BackStack.Record, ProvidedValues> = providedValuesForBackStack(backstack), decoration: NavDecoration = NavigatorDefaults.DefaultDecoration, unavailableRoute: @ Composable ( String ) -> Unit = NavigatorDefaults.UnavailableRoute)","title":"NavigableCircuitContent"},{"location":"api/0.x/circuit/com.slack.circuit/on-nav-event/","text":"// circuit / com.slack.circuit / onNavEvent onNavEvent \u00b6 [common]\\ fun Navigator . onNavEvent (event: NavEvent ) A Circuit call back to help navigate to different screens. Intended to be used when forwarding NavEvent s from nested Presenter s.","title":"On nav event"},{"location":"api/0.x/circuit/com.slack.circuit/on-nav-event/#onnavevent","text":"[common]\\ fun Navigator . onNavEvent (event: NavEvent ) A Circuit call back to help navigate to different screens. Intended to be used when forwarding NavEvent s from nested Presenter s.","title":"onNavEvent"},{"location":"api/0.x/circuit/com.slack.circuit/pop-until/","text":"// circuit / com.slack.circuit / popUntil popUntil \u00b6 [common]\\ fun Navigator . popUntil (predicate: ( Screen ) -> Boolean ) Calls Navigator.pop until the given predicate is matched or it pops the root.","title":"Pop until"},{"location":"api/0.x/circuit/com.slack.circuit/pop-until/#popuntil","text":"[common]\\ fun Navigator . popUntil (predicate: ( Screen ) -> Boolean ) Calls Navigator.pop until the given predicate is matched or it pops the root.","title":"popUntil"},{"location":"api/0.x/circuit/com.slack.circuit/presenter-of/","text":"// circuit / com.slack.circuit / presenterOf presenterOf \u00b6 [common]\\ inline fun < UiState : CircuitUiState > presenterOf (crossinline body: @ Composable () -> UiState ): Presenter < UiState > Due to this bug in Studio, we can\u2019t write lambda impls of Presenter directly. This works around it by offering a shim function of the same name. Once it\u2019s fixed, we can remove this and make Presenter a fun interface instead. Bug: https://issuetracker.google.com/issues/240292828 See also \u00b6 common Presenter for main docs.","title":"Presenter of"},{"location":"api/0.x/circuit/com.slack.circuit/presenter-of/#presenterof","text":"[common]\\ inline fun < UiState : CircuitUiState > presenterOf (crossinline body: @ Composable () -> UiState ): Presenter < UiState > Due to this bug in Studio, we can\u2019t write lambda impls of Presenter directly. This works around it by offering a shim function of the same name. Once it\u2019s fixed, we can remove this and make Presenter a fun interface instead. Bug: https://issuetracker.google.com/issues/240292828","title":"presenterOf"},{"location":"api/0.x/circuit/com.slack.circuit/presenter-of/#see-also","text":"common Presenter for main docs.","title":"See also"},{"location":"api/0.x/circuit/com.slack.circuit/push/","text":"// circuit / com.slack.circuit / push push \u00b6 [android]\\ fun SaveableBackStack. push (screen: Screen )","title":"Push"},{"location":"api/0.x/circuit/com.slack.circuit/push/#push","text":"[android]\\ fun SaveableBackStack. push (screen: Screen )","title":"push"},{"location":"api/0.x/circuit/com.slack.circuit/remember-circuit-navigator/","text":"// circuit / com.slack.circuit / rememberCircuitNavigator rememberCircuitNavigator \u00b6 [android]\\ @ Composable fun rememberCircuitNavigator (backstack: SaveableBackStack, onRootPop: () -> Unit = backDispatcherRootPop()): Navigator Returns a new Navigator for navigating within CircuitContents. See also \u00b6 android NavigableCircuitContent Parameters \u00b6 android backstack The backing SaveableBackStack to navigate. onRootPop Invoked when the backstack is at root (size 1) and the user presses the back button. Defaults to delegating to the LocalOnBackPressedDispatcherOwner .","title":"Remember circuit navigator"},{"location":"api/0.x/circuit/com.slack.circuit/remember-circuit-navigator/#remembercircuitnavigator","text":"[android]\\ @ Composable fun rememberCircuitNavigator (backstack: SaveableBackStack, onRootPop: () -> Unit = backDispatcherRootPop()): Navigator Returns a new Navigator for navigating within CircuitContents.","title":"rememberCircuitNavigator"},{"location":"api/0.x/circuit/com.slack.circuit/remember-circuit-navigator/#see-also","text":"android NavigableCircuitContent","title":"See also"},{"location":"api/0.x/circuit/com.slack.circuit/remember-circuit-navigator/#parameters","text":"android backstack The backing SaveableBackStack to navigate. onRootPop Invoked when the backstack is at root (size 1) and the user presses the back button. Defaults to delegating to the LocalOnBackPressedDispatcherOwner .","title":"Parameters"},{"location":"api/0.x/circuit/com.slack.circuit/screen/","text":"// circuit / com.slack.circuit / screen screen \u00b6 [android]\\ val SaveableBackStack.Record. screen : Screen","title":"Screen"},{"location":"api/0.x/circuit/com.slack.circuit/screen/#screen","text":"[android]\\ val SaveableBackStack.Record. screen : Screen","title":"screen"},{"location":"api/0.x/circuit/com.slack.circuit/ui/","text":"// circuit / com.slack.circuit / ui ui \u00b6 [common]\\ inline fun < UiState : CircuitUiState > ui (crossinline body: @ Composable (state: UiState ) -> Unit ): Ui < UiState > Due to this bug in Studio, we can\u2019t write lambda impls of Ui directly. This works around it by offering a shim function of the same name. Once it\u2019s fixed, we can remove this and make Ui a fun interface instead. Bug: https://issuetracker.google.com/issues/240292828 See also \u00b6 common Ui for main docs.","title":"Ui"},{"location":"api/0.x/circuit/com.slack.circuit/ui/#ui","text":"[common]\\ inline fun < UiState : CircuitUiState > ui (crossinline body: @ Composable (state: UiState ) -> Unit ): Ui < UiState > Due to this bug in Studio, we can\u2019t write lambda impls of Ui directly. This works around it by offering a shim function of the same name. Once it\u2019s fixed, we can remove this and make Ui a fun interface instead. Bug: https://issuetracker.google.com/issues/240292828","title":"ui"},{"location":"api/0.x/circuit/com.slack.circuit/ui/#see-also","text":"common Ui for main docs.","title":"See also"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/","text":"// circuit / com.slack.circuit / CircuitConfig CircuitConfig \u00b6 [common]\\ @ Immutable class CircuitConfig CircuitConfig adapts presenter factories to their corresponding renderable ui factories using screens . Create instances using the Builder and create new CircuitContent with it to run presenter/UI pairings. Construction \u00b6 Construction of CircuitConfig instances is done using the Builder . val circuitConfig = CircuitConfig . Builder () . addUiFactory ( AddFavoritesUiFactory () . addPresenterFactory ( AddFavoritesPresenterFactory () . build () Usage \u00b6 These instances can then be used with the composable CircuitContent functions to run presenter/UI pairings for individual screens . Circuit instances are consumed within these composable functions via the CircuitCompositionLocals CompositionLocalProvider. CircuitCompositionLocals ( circuitConfig ) { CircuitContent ( AddFavoritesScreen ()) } If using navigation, use NavigableCircuitContent instead. val backstack = rememberSaveableBackStack { push ( AddFavoritesScreen ()) } val navigator = rememberCircuitNavigator ( backstack , :: onBackPressed ) CircuitCompositionLocals ( circuitConfig ) { NavigableCircuitContent ( navigator , backstack ) } See also \u00b6 common rememberCircuitNavigator CircuitContent NavigableCircuitContent Types \u00b6 Name Summary Builder [common] class Builder Functions \u00b6 Name Summary newBuilder [common] fun newBuilder (): CircuitConfig.Builder nextPresenter [common] fun nextPresenter (skipPast: Presenter.Factory ?, screen: Screen , navigator: Navigator ): Presenter <*>? nextUi [common] fun nextUi (skipPast: Ui.Factory ?, screen: Screen ): ScreenUi ? presenter [common] fun presenter (screen: Screen , navigator: Navigator ): Presenter <*>? ui [common] fun ui (screen: Screen ): ScreenUi ? Properties \u00b6 Name Summary onUnavailableContent [common] val onUnavailableContent : @ Composable (screen: Screen ) -> Unit ?","title":"Index"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/#circuitconfig","text":"[common]\\ @ Immutable class CircuitConfig CircuitConfig adapts presenter factories to their corresponding renderable ui factories using screens . Create instances using the Builder and create new CircuitContent with it to run presenter/UI pairings.","title":"CircuitConfig"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/#construction","text":"Construction of CircuitConfig instances is done using the Builder . val circuitConfig = CircuitConfig . Builder () . addUiFactory ( AddFavoritesUiFactory () . addPresenterFactory ( AddFavoritesPresenterFactory () . build ()","title":"Construction"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/#usage","text":"These instances can then be used with the composable CircuitContent functions to run presenter/UI pairings for individual screens . Circuit instances are consumed within these composable functions via the CircuitCompositionLocals CompositionLocalProvider. CircuitCompositionLocals ( circuitConfig ) { CircuitContent ( AddFavoritesScreen ()) } If using navigation, use NavigableCircuitContent instead. val backstack = rememberSaveableBackStack { push ( AddFavoritesScreen ()) } val navigator = rememberCircuitNavigator ( backstack , :: onBackPressed ) CircuitCompositionLocals ( circuitConfig ) { NavigableCircuitContent ( navigator , backstack ) }","title":"Usage"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/#see-also","text":"common rememberCircuitNavigator CircuitContent NavigableCircuitContent","title":"See also"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/#types","text":"Name Summary Builder [common] class Builder","title":"Types"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/#functions","text":"Name Summary newBuilder [common] fun newBuilder (): CircuitConfig.Builder nextPresenter [common] fun nextPresenter (skipPast: Presenter.Factory ?, screen: Screen , navigator: Navigator ): Presenter <*>? nextUi [common] fun nextUi (skipPast: Ui.Factory ?, screen: Screen ): ScreenUi ? presenter [common] fun presenter (screen: Screen , navigator: Navigator ): Presenter <*>? ui [common] fun ui (screen: Screen ): ScreenUi ?","title":"Functions"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/#properties","text":"Name Summary onUnavailableContent [common] val onUnavailableContent : @ Composable (screen: Screen ) -> Unit ?","title":"Properties"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/new-builder/","text":"// circuit / com.slack.circuit / CircuitConfig / newBuilder newBuilder \u00b6 [common]\\ fun newBuilder (): CircuitConfig.Builder","title":"New builder"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/new-builder/#newbuilder","text":"[common]\\ fun newBuilder (): CircuitConfig.Builder","title":"newBuilder"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/next-presenter/","text":"// circuit / com.slack.circuit / CircuitConfig / nextPresenter nextPresenter \u00b6 [common]\\ fun nextPresenter (skipPast: Presenter.Factory ?, screen: Screen , navigator: Navigator ): Presenter <*>?","title":"Next presenter"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/next-presenter/#nextpresenter","text":"[common]\\ fun nextPresenter (skipPast: Presenter.Factory ?, screen: Screen , navigator: Navigator ): Presenter <*>?","title":"nextPresenter"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/next-ui/","text":"// circuit / com.slack.circuit / CircuitConfig / nextUi nextUi \u00b6 [common]\\ fun nextUi (skipPast: Ui.Factory ?, screen: Screen ): ScreenUi ?","title":"Next ui"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/next-ui/#nextui","text":"[common]\\ fun nextUi (skipPast: Ui.Factory ?, screen: Screen ): ScreenUi ?","title":"nextUi"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/on-unavailable-content/","text":"// circuit / com.slack.circuit / CircuitConfig / onUnavailableContent onUnavailableContent \u00b6 [common]\\ val onUnavailableContent : @ Composable (screen: Screen ) -> Unit ?","title":"On unavailable content"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/on-unavailable-content/#onunavailablecontent","text":"[common]\\ val onUnavailableContent : @ Composable (screen: Screen ) -> Unit ?","title":"onUnavailableContent"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/presenter/","text":"// circuit / com.slack.circuit / CircuitConfig / presenter presenter \u00b6 [common]\\ fun presenter (screen: Screen , navigator: Navigator ): Presenter <*>?","title":"Presenter"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/presenter/#presenter","text":"[common]\\ fun presenter (screen: Screen , navigator: Navigator ): Presenter <*>?","title":"presenter"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/ui/","text":"// circuit / com.slack.circuit / CircuitConfig / ui ui \u00b6 [common]\\ fun ui (screen: Screen ): ScreenUi ?","title":"Ui"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/ui/#ui","text":"[common]\\ fun ui (screen: Screen ): ScreenUi ?","title":"ui"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/-builder/","text":"// circuit / com.slack.circuit / CircuitConfig / Builder Builder \u00b6 [common]\\ class Builder Constructors \u00b6 Builder [common] fun Builder () Functions \u00b6 Name Summary addPresenterFactories [common] fun addPresenterFactories (factories: Iterable < Presenter.Factory >): CircuitConfig.Builder addPresenterFactory [common] fun addPresenterFactory (factory: Presenter.Factory ): CircuitConfig.Builder fun addPresenterFactory (vararg factory: Presenter.Factory ): CircuitConfig.Builder addUiFactories [common] fun addUiFactories (factories: Iterable < Ui.Factory >): CircuitConfig.Builder addUiFactory [common] fun addUiFactory (factory: Ui.Factory ): CircuitConfig.Builder fun addUiFactory (vararg factory: Ui.Factory ): CircuitConfig.Builder build [common] fun build (): CircuitConfig eventListenerFactory [common] fun eventListenerFactory (factory: EventListener.Factory ): CircuitConfig.Builder setOnUnavailableContent [common] fun setOnUnavailableContent (content: @ Composable (screen: Screen ) -> Unit ): CircuitConfig.Builder Properties \u00b6 Name Summary eventListenerFactory [common] var eventListenerFactory : EventListener.Factory ? = null onUnavailableContent [common] var onUnavailableContent : @ Composable (screen: Screen ) -> Unit ? = null presenterFactories [common] val presenterFactories : MutableList < Presenter.Factory > uiFactories [common] val uiFactories : MutableList < Ui.Factory >","title":"Index"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/-builder/#builder","text":"[common]\\ class Builder","title":"Builder"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/-builder/#constructors","text":"Builder [common] fun Builder ()","title":"Constructors"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/-builder/#functions","text":"Name Summary addPresenterFactories [common] fun addPresenterFactories (factories: Iterable < Presenter.Factory >): CircuitConfig.Builder addPresenterFactory [common] fun addPresenterFactory (factory: Presenter.Factory ): CircuitConfig.Builder fun addPresenterFactory (vararg factory: Presenter.Factory ): CircuitConfig.Builder addUiFactories [common] fun addUiFactories (factories: Iterable < Ui.Factory >): CircuitConfig.Builder addUiFactory [common] fun addUiFactory (factory: Ui.Factory ): CircuitConfig.Builder fun addUiFactory (vararg factory: Ui.Factory ): CircuitConfig.Builder build [common] fun build (): CircuitConfig eventListenerFactory [common] fun eventListenerFactory (factory: EventListener.Factory ): CircuitConfig.Builder setOnUnavailableContent [common] fun setOnUnavailableContent (content: @ Composable (screen: Screen ) -> Unit ): CircuitConfig.Builder","title":"Functions"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/-builder/#properties","text":"Name Summary eventListenerFactory [common] var eventListenerFactory : EventListener.Factory ? = null onUnavailableContent [common] var onUnavailableContent : @ Composable (screen: Screen ) -> Unit ? = null presenterFactories [common] val presenterFactories : MutableList < Presenter.Factory > uiFactories [common] val uiFactories : MutableList < Ui.Factory >","title":"Properties"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/-builder/-builder/","text":"// circuit / com.slack.circuit / CircuitConfig / Builder / Builder Builder \u00b6 [common]\\ fun Builder ()","title":" builder"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/-builder/-builder/#builder","text":"[common]\\ fun Builder ()","title":"Builder"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/-builder/add-presenter-factories/","text":"// circuit / com.slack.circuit / CircuitConfig / Builder / addPresenterFactories addPresenterFactories \u00b6 [common]\\ fun addPresenterFactories (factories: Iterable < Presenter.Factory >): CircuitConfig.Builder","title":"Add presenter factories"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/-builder/add-presenter-factories/#addpresenterfactories","text":"[common]\\ fun addPresenterFactories (factories: Iterable < Presenter.Factory >): CircuitConfig.Builder","title":"addPresenterFactories"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/-builder/add-presenter-factory/","text":"// circuit / com.slack.circuit / CircuitConfig / Builder / addPresenterFactory addPresenterFactory \u00b6 [common]\\ fun addPresenterFactory (factory: Presenter.Factory ): CircuitConfig.Builder fun addPresenterFactory (vararg factory: Presenter.Factory ): CircuitConfig.Builder","title":"Add presenter factory"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/-builder/add-presenter-factory/#addpresenterfactory","text":"[common]\\ fun addPresenterFactory (factory: Presenter.Factory ): CircuitConfig.Builder fun addPresenterFactory (vararg factory: Presenter.Factory ): CircuitConfig.Builder","title":"addPresenterFactory"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/-builder/add-ui-factories/","text":"// circuit / com.slack.circuit / CircuitConfig / Builder / addUiFactories addUiFactories \u00b6 [common]\\ fun addUiFactories (factories: Iterable < Ui.Factory >): CircuitConfig.Builder","title":"Add ui factories"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/-builder/add-ui-factories/#adduifactories","text":"[common]\\ fun addUiFactories (factories: Iterable < Ui.Factory >): CircuitConfig.Builder","title":"addUiFactories"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/-builder/add-ui-factory/","text":"// circuit / com.slack.circuit / CircuitConfig / Builder / addUiFactory addUiFactory \u00b6 [common]\\ fun addUiFactory (factory: Ui.Factory ): CircuitConfig.Builder fun addUiFactory (vararg factory: Ui.Factory ): CircuitConfig.Builder","title":"Add ui factory"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/-builder/add-ui-factory/#adduifactory","text":"[common]\\ fun addUiFactory (factory: Ui.Factory ): CircuitConfig.Builder fun addUiFactory (vararg factory: Ui.Factory ): CircuitConfig.Builder","title":"addUiFactory"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/-builder/build/","text":"// circuit / com.slack.circuit / CircuitConfig / Builder / build build \u00b6 [common]\\ fun build (): CircuitConfig","title":"Build"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/-builder/build/#build","text":"[common]\\ fun build (): CircuitConfig","title":"build"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/-builder/event-listener-factory/","text":"// circuit / com.slack.circuit / CircuitConfig / Builder / eventListenerFactory eventListenerFactory \u00b6 [common]\\ fun eventListenerFactory (factory: EventListener.Factory ): CircuitConfig.Builder var eventListenerFactory : EventListener.Factory ? = null","title":"Event listener factory"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/-builder/event-listener-factory/#eventlistenerfactory","text":"[common]\\ fun eventListenerFactory (factory: EventListener.Factory ): CircuitConfig.Builder var eventListenerFactory : EventListener.Factory ? = null","title":"eventListenerFactory"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/-builder/on-unavailable-content/","text":"// circuit / com.slack.circuit / CircuitConfig / Builder / onUnavailableContent onUnavailableContent \u00b6 [common]\\ var onUnavailableContent : @ Composable (screen: Screen ) -> Unit ? = null","title":"On unavailable content"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/-builder/on-unavailable-content/#onunavailablecontent","text":"[common]\\ var onUnavailableContent : @ Composable (screen: Screen ) -> Unit ? = null","title":"onUnavailableContent"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/-builder/presenter-factories/","text":"// circuit / com.slack.circuit / CircuitConfig / Builder / presenterFactories presenterFactories \u00b6 [common]\\ val presenterFactories : MutableList < Presenter.Factory >","title":"Presenter factories"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/-builder/presenter-factories/#presenterfactories","text":"[common]\\ val presenterFactories : MutableList < Presenter.Factory >","title":"presenterFactories"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/-builder/set-on-unavailable-content/","text":"// circuit / com.slack.circuit / CircuitConfig / Builder / setOnUnavailableContent setOnUnavailableContent \u00b6 [common]\\ fun setOnUnavailableContent (content: @ Composable (screen: Screen ) -> Unit ): CircuitConfig.Builder","title":"Set on unavailable content"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/-builder/set-on-unavailable-content/#setonunavailablecontent","text":"[common]\\ fun setOnUnavailableContent (content: @ Composable (screen: Screen ) -> Unit ): CircuitConfig.Builder","title":"setOnUnavailableContent"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/-builder/ui-factories/","text":"// circuit / com.slack.circuit / CircuitConfig / Builder / uiFactories uiFactories \u00b6 [common]\\ val uiFactories : MutableList < Ui.Factory >","title":"Ui factories"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-config/-builder/ui-factories/#uifactories","text":"[common]\\ val uiFactories : MutableList < Ui.Factory >","title":"uiFactories"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-ui-event/","text":"// circuit / com.slack.circuit / CircuitUiEvent CircuitUiEvent \u00b6 [common]\\ @ Immutable interface CircuitUiEvent Marker interface for all UiEvent types. Events in Circuit should generally reflect user interactions with the UI. They are mediated by presenters and may or may not influence the current state . Circuit event types should be truly immutable types. Inheritors \u00b6 Name NavEvent","title":"Index"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-ui-event/#circuituievent","text":"[common]\\ @ Immutable interface CircuitUiEvent Marker interface for all UiEvent types. Events in Circuit should generally reflect user interactions with the UI. They are mediated by presenters and may or may not influence the current state . Circuit event types should be truly immutable types.","title":"CircuitUiEvent"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-ui-event/#inheritors","text":"Name NavEvent","title":"Inheritors"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-ui-state/","text":"// circuit / com.slack.circuit / CircuitUiState CircuitUiState \u00b6 [common]\\ @ Immutable interface CircuitUiState Marker interface for all UiState types. States in Circuit should be minimal data models that UIs can render. They are produced by presenters that interpret the underlying data layer and mediate input user/nav events . UIs take states as parameters and should act as pure functions that render the input state as a UI. They should not have any side effects or directly interact with the underlying data layer. Circuit state types should be truly immutable types.","title":"Index"},{"location":"api/0.x/circuit/com.slack.circuit/-circuit-ui-state/#circuituistate","text":"[common]\\ @ Immutable interface CircuitUiState Marker interface for all UiState types. States in Circuit should be minimal data models that UIs can render. They are produced by presenters that interpret the underlying data layer and mediate input user/nav events . UIs take states as parameters and should act as pure functions that render the input state as a UI. They should not have any side effects or directly interact with the underlying data layer. Circuit state types should be truly immutable types.","title":"CircuitUiState"},{"location":"api/0.x/circuit/com.slack.circuit/-event-listener/","text":"// circuit / com.slack.circuit / EventListener EventListener \u00b6 [common]\\ interface EventListener A listener for tracking the state changes of a given Screen . This can be used for instrumentation and other telemetry. Types \u00b6 Name Summary Companion [common] object Companion Factory [common] fun interface Factory Functions \u00b6 Name Summary onState [common] open fun onState (state: Any ) Called when there is a new state returned by the Presenter .","title":"Index"},{"location":"api/0.x/circuit/com.slack.circuit/-event-listener/#eventlistener","text":"[common]\\ interface EventListener A listener for tracking the state changes of a given Screen . This can be used for instrumentation and other telemetry.","title":"EventListener"},{"location":"api/0.x/circuit/com.slack.circuit/-event-listener/#types","text":"Name Summary Companion [common] object Companion Factory [common] fun interface Factory","title":"Types"},{"location":"api/0.x/circuit/com.slack.circuit/-event-listener/#functions","text":"Name Summary onState [common] open fun onState (state: Any ) Called when there is a new state returned by the Presenter .","title":"Functions"},{"location":"api/0.x/circuit/com.slack.circuit/-event-listener/on-state/","text":"// circuit / com.slack.circuit / EventListener / onState onState \u00b6 [common]\\ open fun onState (state: Any ) Called when there is a new state returned by the Presenter .","title":"On state"},{"location":"api/0.x/circuit/com.slack.circuit/-event-listener/on-state/#onstate","text":"[common]\\ open fun onState (state: Any ) Called when there is a new state returned by the Presenter .","title":"onState"},{"location":"api/0.x/circuit/com.slack.circuit/-event-listener/-companion/","text":"// circuit / com.slack.circuit / EventListener / Companion Companion \u00b6 [common]\\ object Companion Properties \u00b6 Name Summary NONE [common] val NONE : EventListener","title":"Index"},{"location":"api/0.x/circuit/com.slack.circuit/-event-listener/-companion/#companion","text":"[common]\\ object Companion","title":"Companion"},{"location":"api/0.x/circuit/com.slack.circuit/-event-listener/-companion/#properties","text":"Name Summary NONE [common] val NONE : EventListener","title":"Properties"},{"location":"api/0.x/circuit/com.slack.circuit/-event-listener/-companion/-n-o-n-e/","text":"// circuit / com.slack.circuit / EventListener / Companion / NONE NONE \u00b6 [common]\\ val NONE : EventListener","title":" n o n e"},{"location":"api/0.x/circuit/com.slack.circuit/-event-listener/-companion/-n-o-n-e/#none","text":"[common]\\ val NONE : EventListener","title":"NONE"},{"location":"api/0.x/circuit/com.slack.circuit/-event-listener/-factory/","text":"// circuit / com.slack.circuit / EventListener / Factory Factory \u00b6 [common]\\ fun interface Factory Functions \u00b6 Name Summary create [common] abstract fun create (screen: Screen ): EventListener","title":"Index"},{"location":"api/0.x/circuit/com.slack.circuit/-event-listener/-factory/#factory","text":"[common]\\ fun interface Factory","title":"Factory"},{"location":"api/0.x/circuit/com.slack.circuit/-event-listener/-factory/#functions","text":"Name Summary create [common] abstract fun create (screen: Screen ): EventListener","title":"Functions"},{"location":"api/0.x/circuit/com.slack.circuit/-event-listener/-factory/create/","text":"// circuit / com.slack.circuit / EventListener / Factory / create create \u00b6 [common]\\ abstract fun create (screen: Screen ): EventListener","title":"Create"},{"location":"api/0.x/circuit/com.slack.circuit/-event-listener/-factory/create/#create","text":"[common]\\ abstract fun create (screen: Screen ): EventListener","title":"create"},{"location":"api/0.x/circuit/com.slack.circuit/-local-circuit-owner/","text":"// circuit / com.slack.circuit / LocalCircuitOwner LocalCircuitOwner \u00b6 [common]\\ object LocalCircuitOwner Functions \u00b6 Name Summary provides [common] infix fun provides (circuitConfig: CircuitConfig ): ProvidedValue < CircuitConfig ?> Associates a LocalCircuitConfig key to a value in a call to CompositionLocalProvider . Properties \u00b6 Name Summary current [common] @get: Composable val current : CircuitConfig Returns current composition local value for the owner or errors if one has not been provided.","title":"Index"},{"location":"api/0.x/circuit/com.slack.circuit/-local-circuit-owner/#localcircuitowner","text":"[common]\\ object LocalCircuitOwner","title":"LocalCircuitOwner"},{"location":"api/0.x/circuit/com.slack.circuit/-local-circuit-owner/#functions","text":"Name Summary provides [common] infix fun provides (circuitConfig: CircuitConfig ): ProvidedValue < CircuitConfig ?> Associates a LocalCircuitConfig key to a value in a call to CompositionLocalProvider .","title":"Functions"},{"location":"api/0.x/circuit/com.slack.circuit/-local-circuit-owner/#properties","text":"Name Summary current [common] @get: Composable val current : CircuitConfig Returns current composition local value for the owner or errors if one has not been provided.","title":"Properties"},{"location":"api/0.x/circuit/com.slack.circuit/-local-circuit-owner/current/","text":"// circuit / com.slack.circuit / LocalCircuitOwner / current current \u00b6 [common]\\ @get: Composable val current : CircuitConfig Returns current composition local value for the owner or errors if one has not been provided.","title":"Current"},{"location":"api/0.x/circuit/com.slack.circuit/-local-circuit-owner/current/#current","text":"[common]\\ @get: Composable val current : CircuitConfig Returns current composition local value for the owner or errors if one has not been provided.","title":"current"},{"location":"api/0.x/circuit/com.slack.circuit/-local-circuit-owner/provides/","text":"// circuit / com.slack.circuit / LocalCircuitOwner / provides provides \u00b6 [common]\\ infix fun provides (circuitConfig: CircuitConfig ): ProvidedValue < CircuitConfig ?> Associates a LocalCircuitConfig key to a value in a call to CompositionLocalProvider .","title":"Provides"},{"location":"api/0.x/circuit/com.slack.circuit/-local-circuit-owner/provides/#provides","text":"[common]\\ infix fun provides (circuitConfig: CircuitConfig ): ProvidedValue < CircuitConfig ?> Associates a LocalCircuitConfig key to a value in a call to CompositionLocalProvider .","title":"provides"},{"location":"api/0.x/circuit/com.slack.circuit/-nav-event/","text":"// circuit / com.slack.circuit / NavEvent NavEvent \u00b6 [common]\\ interface NavEvent : CircuitUiEvent A sealed navigation interface intended to be used when making a navigation call back.","title":"Index"},{"location":"api/0.x/circuit/com.slack.circuit/-nav-event/#navevent","text":"[common]\\ interface NavEvent : CircuitUiEvent A sealed navigation interface intended to be used when making a navigation call back.","title":"NavEvent"},{"location":"api/0.x/circuit/com.slack.circuit/-navigator/","text":"// circuit / com.slack.circuit / Navigator Navigator \u00b6 [common]\\ @ Stable interface Navigator A basic navigation interface for navigating between screens . Types \u00b6 Name Summary NoOp [common] object NoOp : Navigator Functions \u00b6 Name Summary goTo [common] abstract fun goTo (screen: Screen ) pop [common] abstract fun pop (): Screen ? Inheritors \u00b6 Name NoOp Extensions \u00b6 Name Summary onNavEvent [common] fun Navigator . onNavEvent (event: NavEvent ) A Circuit call back to help navigate to different screens. Intended to be used when forwarding NavEvent s from nested Presenter s. popUntil [common] fun Navigator . popUntil (predicate: ( Screen ) -> Boolean ) Calls Navigator.pop until the given predicate is matched or it pops the root.","title":"Index"},{"location":"api/0.x/circuit/com.slack.circuit/-navigator/#navigator","text":"[common]\\ @ Stable interface Navigator A basic navigation interface for navigating between screens .","title":"Navigator"},{"location":"api/0.x/circuit/com.slack.circuit/-navigator/#types","text":"Name Summary NoOp [common] object NoOp : Navigator","title":"Types"},{"location":"api/0.x/circuit/com.slack.circuit/-navigator/#functions","text":"Name Summary goTo [common] abstract fun goTo (screen: Screen ) pop [common] abstract fun pop (): Screen ?","title":"Functions"},{"location":"api/0.x/circuit/com.slack.circuit/-navigator/#inheritors","text":"Name NoOp","title":"Inheritors"},{"location":"api/0.x/circuit/com.slack.circuit/-navigator/#extensions","text":"Name Summary onNavEvent [common] fun Navigator . onNavEvent (event: NavEvent ) A Circuit call back to help navigate to different screens. Intended to be used when forwarding NavEvent s from nested Presenter s. popUntil [common] fun Navigator . popUntil (predicate: ( Screen ) -> Boolean ) Calls Navigator.pop until the given predicate is matched or it pops the root.","title":"Extensions"},{"location":"api/0.x/circuit/com.slack.circuit/-navigator/go-to/","text":"// circuit / com.slack.circuit / Navigator / goTo goTo \u00b6 [common]\\ abstract fun goTo (screen: Screen )","title":"Go to"},{"location":"api/0.x/circuit/com.slack.circuit/-navigator/go-to/#goto","text":"[common]\\ abstract fun goTo (screen: Screen )","title":"goTo"},{"location":"api/0.x/circuit/com.slack.circuit/-navigator/pop/","text":"// circuit / com.slack.circuit / Navigator / pop pop \u00b6 [common]\\ abstract fun pop (): Screen ?","title":"Pop"},{"location":"api/0.x/circuit/com.slack.circuit/-navigator/pop/#pop","text":"[common]\\ abstract fun pop (): Screen ?","title":"pop"},{"location":"api/0.x/circuit/com.slack.circuit/-navigator/-no-op/","text":"// circuit / com.slack.circuit / Navigator / NoOp NoOp \u00b6 [common]\\ object NoOp : Navigator Functions \u00b6 Name Summary goTo [common] open override fun goTo (screen: Screen ) pop [common] open override fun pop (): Screen ? Extensions \u00b6 Name Summary onNavEvent [common] fun Navigator . onNavEvent (event: NavEvent ) A Circuit call back to help navigate to different screens. Intended to be used when forwarding NavEvent s from nested Presenter s. popUntil [common] fun Navigator . popUntil (predicate: ( Screen ) -> Boolean ) Calls Navigator.pop until the given predicate is matched or it pops the root.","title":"Index"},{"location":"api/0.x/circuit/com.slack.circuit/-navigator/-no-op/#noop","text":"[common]\\ object NoOp : Navigator","title":"NoOp"},{"location":"api/0.x/circuit/com.slack.circuit/-navigator/-no-op/#functions","text":"Name Summary goTo [common] open override fun goTo (screen: Screen ) pop [common] open override fun pop (): Screen ?","title":"Functions"},{"location":"api/0.x/circuit/com.slack.circuit/-navigator/-no-op/#extensions","text":"Name Summary onNavEvent [common] fun Navigator . onNavEvent (event: NavEvent ) A Circuit call back to help navigate to different screens. Intended to be used when forwarding NavEvent s from nested Presenter s. popUntil [common] fun Navigator . popUntil (predicate: ( Screen ) -> Boolean ) Calls Navigator.pop until the given predicate is matched or it pops the root.","title":"Extensions"},{"location":"api/0.x/circuit/com.slack.circuit/-navigator/-no-op/go-to/","text":"// circuit / com.slack.circuit / Navigator / NoOp / goTo goTo \u00b6 [common]\\ open override fun goTo (screen: Screen )","title":"Go to"},{"location":"api/0.x/circuit/com.slack.circuit/-navigator/-no-op/go-to/#goto","text":"[common]\\ open override fun goTo (screen: Screen )","title":"goTo"},{"location":"api/0.x/circuit/com.slack.circuit/-navigator/-no-op/pop/","text":"// circuit / com.slack.circuit / Navigator / NoOp / pop pop \u00b6 [common]\\ open override fun pop (): Screen ?","title":"Pop"},{"location":"api/0.x/circuit/com.slack.circuit/-navigator/-no-op/pop/#pop","text":"[common]\\ open override fun pop (): Screen ?","title":"pop"},{"location":"api/0.x/circuit/com.slack.circuit/-navigator-defaults/","text":"// circuit / com.slack.circuit / NavigatorDefaults NavigatorDefaults \u00b6 [android]\\ object NavigatorDefaults Default values and common alternatives used by navigable composables. Types \u00b6 Name Summary DefaultDecoration [android] object DefaultDecoration : NavDecoration The default NavDecoration used in navigation. EmptyDecoration [android] object EmptyDecoration : NavDecoration An empty NavDecoration that emits the content with no surrounding decoration or logic. Properties \u00b6 Name Summary UnavailableRoute [android] val UnavailableRoute : @ Composable ( String ) -> Unit Bright ugly error text telling a developer they didn\u2019t provide a route that a BackStack asked for.","title":"Index"},{"location":"api/0.x/circuit/com.slack.circuit/-navigator-defaults/#navigatordefaults","text":"[android]\\ object NavigatorDefaults Default values and common alternatives used by navigable composables.","title":"NavigatorDefaults"},{"location":"api/0.x/circuit/com.slack.circuit/-navigator-defaults/#types","text":"Name Summary DefaultDecoration [android] object DefaultDecoration : NavDecoration The default NavDecoration used in navigation. EmptyDecoration [android] object EmptyDecoration : NavDecoration An empty NavDecoration that emits the content with no surrounding decoration or logic.","title":"Types"},{"location":"api/0.x/circuit/com.slack.circuit/-navigator-defaults/#properties","text":"Name Summary UnavailableRoute [android] val UnavailableRoute : @ Composable ( String ) -> Unit Bright ugly error text telling a developer they didn\u2019t provide a route that a BackStack asked for.","title":"Properties"},{"location":"api/0.x/circuit/com.slack.circuit/-navigator-defaults/-unavailable-route/","text":"// circuit / com.slack.circuit / NavigatorDefaults / UnavailableRoute UnavailableRoute \u00b6 [android]\\ val UnavailableRoute : @ Composable ( String ) -> Unit Bright ugly error text telling a developer they didn\u2019t provide a route that a BackStack asked for.","title":" unavailable route"},{"location":"api/0.x/circuit/com.slack.circuit/-navigator-defaults/-unavailable-route/#unavailableroute","text":"[android]\\ val UnavailableRoute : @ Composable ( String ) -> Unit Bright ugly error text telling a developer they didn\u2019t provide a route that a BackStack asked for.","title":"UnavailableRoute"},{"location":"api/0.x/circuit/com.slack.circuit/-navigator-defaults/-default-decoration/","text":"// circuit / com.slack.circuit / NavigatorDefaults / DefaultDecoration DefaultDecoration \u00b6 [android]\\ object DefaultDecoration : NavDecoration The default NavDecoration used in navigation. Functions \u00b6 Name Summary DecoratedContent [android] @ Composable open override fun < T > DecoratedContent (arg: T , backStackDepth: Int , modifier: Modifier , content: @ Composable ( T ) -> Unit )","title":"Index"},{"location":"api/0.x/circuit/com.slack.circuit/-navigator-defaults/-default-decoration/#defaultdecoration","text":"[android]\\ object DefaultDecoration : NavDecoration The default NavDecoration used in navigation.","title":"DefaultDecoration"},{"location":"api/0.x/circuit/com.slack.circuit/-navigator-defaults/-default-decoration/#functions","text":"Name Summary DecoratedContent [android] @ Composable open override fun < T > DecoratedContent (arg: T , backStackDepth: Int , modifier: Modifier , content: @ Composable ( T ) -> Unit )","title":"Functions"},{"location":"api/0.x/circuit/com.slack.circuit/-navigator-defaults/-default-decoration/-decorated-content/","text":"// circuit / com.slack.circuit / NavigatorDefaults / DefaultDecoration / DecoratedContent DecoratedContent \u00b6 [android]\\ @ Composable open override fun < T > DecoratedContent (arg: T , backStackDepth: Int , modifier: Modifier , content: @ Composable ( T ) -> Unit )","title":" decorated content"},{"location":"api/0.x/circuit/com.slack.circuit/-navigator-defaults/-default-decoration/-decorated-content/#decoratedcontent","text":"[android]\\ @ Composable open override fun < T > DecoratedContent (arg: T , backStackDepth: Int , modifier: Modifier , content: @ Composable ( T ) -> Unit )","title":"DecoratedContent"},{"location":"api/0.x/circuit/com.slack.circuit/-navigator-defaults/-empty-decoration/","text":"// circuit / com.slack.circuit / NavigatorDefaults / EmptyDecoration EmptyDecoration \u00b6 [android]\\ object EmptyDecoration : NavDecoration An empty NavDecoration that emits the content with no surrounding decoration or logic. Functions \u00b6 Name Summary DecoratedContent [android] @ Composable open override fun < T > DecoratedContent (arg: T , backStackDepth: Int , modifier: Modifier , content: @ Composable ( T ) -> Unit )","title":"Index"},{"location":"api/0.x/circuit/com.slack.circuit/-navigator-defaults/-empty-decoration/#emptydecoration","text":"[android]\\ object EmptyDecoration : NavDecoration An empty NavDecoration that emits the content with no surrounding decoration or logic.","title":"EmptyDecoration"},{"location":"api/0.x/circuit/com.slack.circuit/-navigator-defaults/-empty-decoration/#functions","text":"Name Summary DecoratedContent [android] @ Composable open override fun < T > DecoratedContent (arg: T , backStackDepth: Int , modifier: Modifier , content: @ Composable ( T ) -> Unit )","title":"Functions"},{"location":"api/0.x/circuit/com.slack.circuit/-navigator-defaults/-empty-decoration/-decorated-content/","text":"// circuit / com.slack.circuit / NavigatorDefaults / EmptyDecoration / DecoratedContent DecoratedContent \u00b6 [android]\\ @ Composable open override fun < T > DecoratedContent (arg: T , backStackDepth: Int , modifier: Modifier , content: @ Composable ( T ) -> Unit )","title":" decorated content"},{"location":"api/0.x/circuit/com.slack.circuit/-navigator-defaults/-empty-decoration/-decorated-content/#decoratedcontent","text":"[android]\\ @ Composable open override fun < T > DecoratedContent (arg: T , backStackDepth: Int , modifier: Modifier , content: @ Composable ( T ) -> Unit )","title":"DecoratedContent"},{"location":"api/0.x/circuit/com.slack.circuit/-presenter/","text":"// circuit / com.slack.circuit / Presenter Presenter \u00b6 [common]\\ interface Presenter < UiState : CircuitUiState > Presents a given UiState . Events (if any) should be a part of the UiState itself as an eventSink: (Event) -> Unit property. If a given Presenter only ever emits the same state, you can define a single value-less object type for the state. See also \u00b6 common Presenter.present for more thorough documentation. Types \u00b6 Name Summary Factory [common] fun interface Factory A factory that produces presenters for a given Screen . CircuitConfig instances use the created presenter and connects it to a given Ui for the same Screen . Functions \u00b6 Name Summary present [common] @ Composable abstract fun present (): UiState The primary Composable entry point to present a UiState . In production, a Navigator is used to automatically connect this with a corresponding Ui to render the state returned by this function.","title":"Index"},{"location":"api/0.x/circuit/com.slack.circuit/-presenter/#presenter","text":"[common]\\ interface Presenter < UiState : CircuitUiState > Presents a given UiState . Events (if any) should be a part of the UiState itself as an eventSink: (Event) -> Unit property. If a given Presenter only ever emits the same state, you can define a single value-less object type for the state.","title":"Presenter"},{"location":"api/0.x/circuit/com.slack.circuit/-presenter/#see-also","text":"common Presenter.present for more thorough documentation.","title":"See also"},{"location":"api/0.x/circuit/com.slack.circuit/-presenter/#types","text":"Name Summary Factory [common] fun interface Factory A factory that produces presenters for a given Screen . CircuitConfig instances use the created presenter and connects it to a given Ui for the same Screen .","title":"Types"},{"location":"api/0.x/circuit/com.slack.circuit/-presenter/#functions","text":"Name Summary present [common] @ Composable abstract fun present (): UiState The primary Composable entry point to present a UiState . In production, a Navigator is used to automatically connect this with a corresponding Ui to render the state returned by this function.","title":"Functions"},{"location":"api/0.x/circuit/com.slack.circuit/-presenter/present/","text":"// circuit / com.slack.circuit / Presenter / present present \u00b6 [common]\\ @ Composable abstract fun present (): UiState The primary Composable entry point to present a UiState . In production, a Navigator is used to automatically connect this with a corresponding Ui to render the state returned by this function. When handling events, embed a eventSink: (Event) -> Unit property in the state as needed. data class State ( val favorites : List < Favorite > , eventSink : ( Event ) -> Unit ) : CircuitUiState class FavoritesPresenter (...) : Presenter < State , Event > { @Composable override fun present (): State { // ... return State (...) { event -> // Handle UI events here } } } Dependency Injection \u00b6 Presenters should use dependency injection, usually assisted injection to accept Navigator or Screen instances as inputs. Their corresponding assisted factories should then be used by hand-written presenter factories . class FavoritesPresenter @AssistedInject constructor ( @Assisted private val screen : FavoritesScreen , @Assisted private val navigator : Navigator , private val favoritesRepository : FavoritesRepository ) : Presenter < State > { @Composable override fun present (): State { // ... } @AssistedFactory fun interface Factory { fun create ( screen : FavoritesScreen , navigator : Navigator ): FavoritesPresenter } } Testing \u00b6 When testing, simply drive UI events with a MutableSharedFlow use Molecule+Turbine to drive this function. @Test fun `emit initial state and refresh` () = runTest { val favorites = listOf ( \"Moose\" , \"Reeses\" , \"Lola\" ) val repository = FakeFavoritesRepository ( favorites ) val presenter = FavoritesPresenter ( repository ) moleculeFlow ( Immediate ) { presenter . present () } . test { assertThat ( awaitItem ()). isEqualTo ( State . Loading ) val successState = awaitItem () assertThat ( successState ). isEqualTo ( State . Success ( favorites )) successState . eventSink ( Event . Refresh ) assertThat ( awaitItem ()). isEqualTo ( State . Success ( favorites )) } } Note that Circuit\u2019s test artifact has a Presenter.test() helper extension function for the above case.","title":"Present"},{"location":"api/0.x/circuit/com.slack.circuit/-presenter/present/#present","text":"[common]\\ @ Composable abstract fun present (): UiState The primary Composable entry point to present a UiState . In production, a Navigator is used to automatically connect this with a corresponding Ui to render the state returned by this function. When handling events, embed a eventSink: (Event) -> Unit property in the state as needed. data class State ( val favorites : List < Favorite > , eventSink : ( Event ) -> Unit ) : CircuitUiState class FavoritesPresenter (...) : Presenter < State , Event > { @Composable override fun present (): State { // ... return State (...) { event -> // Handle UI events here } } }","title":"present"},{"location":"api/0.x/circuit/com.slack.circuit/-presenter/present/#dependency-injection","text":"Presenters should use dependency injection, usually assisted injection to accept Navigator or Screen instances as inputs. Their corresponding assisted factories should then be used by hand-written presenter factories . class FavoritesPresenter @AssistedInject constructor ( @Assisted private val screen : FavoritesScreen , @Assisted private val navigator : Navigator , private val favoritesRepository : FavoritesRepository ) : Presenter < State > { @Composable override fun present (): State { // ... } @AssistedFactory fun interface Factory { fun create ( screen : FavoritesScreen , navigator : Navigator ): FavoritesPresenter } }","title":"Dependency Injection"},{"location":"api/0.x/circuit/com.slack.circuit/-presenter/present/#testing","text":"When testing, simply drive UI events with a MutableSharedFlow use Molecule+Turbine to drive this function. @Test fun `emit initial state and refresh` () = runTest { val favorites = listOf ( \"Moose\" , \"Reeses\" , \"Lola\" ) val repository = FakeFavoritesRepository ( favorites ) val presenter = FavoritesPresenter ( repository ) moleculeFlow ( Immediate ) { presenter . present () } . test { assertThat ( awaitItem ()). isEqualTo ( State . Loading ) val successState = awaitItem () assertThat ( successState ). isEqualTo ( State . Success ( favorites )) successState . eventSink ( Event . Refresh ) assertThat ( awaitItem ()). isEqualTo ( State . Success ( favorites )) } } Note that Circuit\u2019s test artifact has a Presenter.test() helper extension function for the above case.","title":"Testing"},{"location":"api/0.x/circuit/com.slack.circuit/-presenter/-factory/","text":"// circuit / com.slack.circuit / Presenter / Factory Factory \u00b6 [common]\\ fun interface Factory A factory that produces presenters for a given Screen . CircuitConfig instances use the created presenter and connects it to a given Ui for the same Screen . Factories should be simple aggregate multiple presenters for a canonical \"whole screen\". That is to say, they should be hand-written and aggregate all the presenters responsible for the UI visible within the surface this presents on. Example \u00b6 Consider this example of a Profile UI. \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u25c4\u2500\u2500\u2510 \u2502 \u2502 X \u2502 \u2502 \u2502 \u2502 \u2502 ProfileHeaderPresenter \u2502 \u2502 Fred Rogers \u2502 \u2502 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u25c4\u2500\u2500\u2518 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2510 \u2502 ProfilePresenterFactory \u2502 \u2502 Message \u2502 \u2502 Call \u2502\u25c4\u2500\u253c\u2500\u2500\u2500 ProfileActionsPresenter \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 - - - - - - - - \u25c4\u2500\u253c\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 - - - - - - - - \u2502 \u2502 \u2502 \u2502 - - - - - - - - \u2502 ProfileDetailsPresenter \u2502 \u2502 - - - - - - - - \u25c4\u2500\u253c\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 This would be represented by the following factory implementation: class ProfilePresenter . Factory @Inject constructor ( val headerPresenter : ProfilerHeaderPresenter . Factory , val actionsPresenter : ProfilerActionsPresenter . Factory , val detailsPresenter : ProfilerDetailsPresenter . Factory , val callScreenRouter : CallScreenRouter . Factory ) : Presenter . Factory { override fun create ( screen : Screen , navigator : Navigator , circuitConfig : CircuitConfig ): Presenter <* , *>? { return when ( screen ) { is ProfileHeader -> headerPresenter . create ( screen ) is ProfileActions -> actionsPresenter . create ( screen , callScreenRouter . create ( navigator )) is ProfileDetails -> detailsPresenter . create ( screen ) else -> null } } } Functions \u00b6 Name Summary create [common] abstract fun create (screen: Screen , navigator: Navigator , circuitConfig: CircuitConfig ): Presenter <*>? Creates a Presenter for the given screen if it can handle it, or returns null if it cannot handle the given screen .","title":"Index"},{"location":"api/0.x/circuit/com.slack.circuit/-presenter/-factory/#factory","text":"[common]\\ fun interface Factory A factory that produces presenters for a given Screen . CircuitConfig instances use the created presenter and connects it to a given Ui for the same Screen . Factories should be simple aggregate multiple presenters for a canonical \"whole screen\". That is to say, they should be hand-written and aggregate all the presenters responsible for the UI visible within the surface this presents on.","title":"Factory"},{"location":"api/0.x/circuit/com.slack.circuit/-presenter/-factory/#example","text":"Consider this example of a Profile UI. \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u25c4\u2500\u2500\u2510 \u2502 \u2502 X \u2502 \u2502 \u2502 \u2502 \u2502 ProfileHeaderPresenter \u2502 \u2502 Fred Rogers \u2502 \u2502 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u25c4\u2500\u2500\u2518 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2510 \u2502 ProfilePresenterFactory \u2502 \u2502 Message \u2502 \u2502 Call \u2502\u25c4\u2500\u253c\u2500\u2500\u2500 ProfileActionsPresenter \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 - - - - - - - - \u25c4\u2500\u253c\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 - - - - - - - - \u2502 \u2502 \u2502 \u2502 - - - - - - - - \u2502 ProfileDetailsPresenter \u2502 \u2502 - - - - - - - - \u25c4\u2500\u253c\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 This would be represented by the following factory implementation: class ProfilePresenter . Factory @Inject constructor ( val headerPresenter : ProfilerHeaderPresenter . Factory , val actionsPresenter : ProfilerActionsPresenter . Factory , val detailsPresenter : ProfilerDetailsPresenter . Factory , val callScreenRouter : CallScreenRouter . Factory ) : Presenter . Factory { override fun create ( screen : Screen , navigator : Navigator , circuitConfig : CircuitConfig ): Presenter <* , *>? { return when ( screen ) { is ProfileHeader -> headerPresenter . create ( screen ) is ProfileActions -> actionsPresenter . create ( screen , callScreenRouter . create ( navigator )) is ProfileDetails -> detailsPresenter . create ( screen ) else -> null } } }","title":"Example"},{"location":"api/0.x/circuit/com.slack.circuit/-presenter/-factory/#functions","text":"Name Summary create [common] abstract fun create (screen: Screen , navigator: Navigator , circuitConfig: CircuitConfig ): Presenter <*>? Creates a Presenter for the given screen if it can handle it, or returns null if it cannot handle the given screen .","title":"Functions"},{"location":"api/0.x/circuit/com.slack.circuit/-presenter/-factory/create/","text":"// circuit / com.slack.circuit / Presenter / Factory / create create \u00b6 [common]\\ abstract fun create (screen: Screen , navigator: Navigator , circuitConfig: CircuitConfig ): Presenter <*>? Creates a Presenter for the given screen if it can handle it, or returns null if it cannot handle the given screen .","title":"Create"},{"location":"api/0.x/circuit/com.slack.circuit/-presenter/-factory/create/#create","text":"[common]\\ abstract fun create (screen: Screen , navigator: Navigator , circuitConfig: CircuitConfig ): Presenter <*>? Creates a Presenter for the given screen if it can handle it, or returns null if it cannot handle the given screen .","title":"create"},{"location":"api/0.x/circuit/com.slack.circuit/-screen/","text":"// circuit / com.slack.circuit / Screen Screen \u00b6 [common]\\ expect interface Screen Represents an individual screen, used as a key for Presenter.Factory and Ui.Factory . Screens can be simple sentinel object types or data classes with information to share. Screens with information should contain the minimum amount of data needed for the target presenter to begin presenting state. data class AddFavorites ( val externalId : UUID , ) : Screen Screens are then passed into Navigators to navigate to them. fun showAddFavorites () { navigator . goTo ( AddFavorites ( externalId = uuidGenerator . generate () ) ) } [android]\\ actual interface Screen : Parcelable [jvm]\\ actual interface Screen Functions \u00b6 Name Summary describeContents [android] abstract fun describeContents (): Int writeToParcel [android] abstract fun writeToParcel (p0: Parcel , p1: Int )","title":"Index"},{"location":"api/0.x/circuit/com.slack.circuit/-screen/#screen","text":"[common]\\ expect interface Screen Represents an individual screen, used as a key for Presenter.Factory and Ui.Factory . Screens can be simple sentinel object types or data classes with information to share. Screens with information should contain the minimum amount of data needed for the target presenter to begin presenting state. data class AddFavorites ( val externalId : UUID , ) : Screen Screens are then passed into Navigators to navigate to them. fun showAddFavorites () { navigator . goTo ( AddFavorites ( externalId = uuidGenerator . generate () ) ) } [android]\\ actual interface Screen : Parcelable [jvm]\\ actual interface Screen","title":"Screen"},{"location":"api/0.x/circuit/com.slack.circuit/-screen/#functions","text":"Name Summary describeContents [android] abstract fun describeContents (): Int writeToParcel [android] abstract fun writeToParcel (p0: Parcel , p1: Int )","title":"Functions"},{"location":"api/0.x/circuit/com.slack.circuit/-screen-ui/","text":"// circuit / com.slack.circuit / ScreenUi ScreenUi \u00b6 [common]\\ data class ScreenUi (val ui: Ui <*>) Constructors \u00b6 ScreenUi [common] fun ScreenUi (ui: Ui <*>) Properties \u00b6 Name Summary ui [common] val ui : Ui <*>","title":"Index"},{"location":"api/0.x/circuit/com.slack.circuit/-screen-ui/#screenui","text":"[common]\\ data class ScreenUi (val ui: Ui <*>)","title":"ScreenUi"},{"location":"api/0.x/circuit/com.slack.circuit/-screen-ui/#constructors","text":"ScreenUi [common] fun ScreenUi (ui: Ui <*>)","title":"Constructors"},{"location":"api/0.x/circuit/com.slack.circuit/-screen-ui/#properties","text":"Name Summary ui [common] val ui : Ui <*>","title":"Properties"},{"location":"api/0.x/circuit/com.slack.circuit/-screen-ui/-screen-ui/","text":"// circuit / com.slack.circuit / ScreenUi / ScreenUi ScreenUi \u00b6 [common]\\ fun ScreenUi (ui: Ui <*>)","title":" screen ui"},{"location":"api/0.x/circuit/com.slack.circuit/-screen-ui/-screen-ui/#screenui","text":"[common]\\ fun ScreenUi (ui: Ui <*>)","title":"ScreenUi"},{"location":"api/0.x/circuit/com.slack.circuit/-screen-ui/ui/","text":"// circuit / com.slack.circuit / ScreenUi / ui ui \u00b6 [common]\\ val ui : Ui <*>","title":"Ui"},{"location":"api/0.x/circuit/com.slack.circuit/-screen-ui/ui/#ui","text":"[common]\\ val ui : Ui <*>","title":"ui"},{"location":"api/0.x/circuit/com.slack.circuit/-ui/","text":"// circuit / com.slack.circuit / Ui Ui \u00b6 [common]\\ interface Ui < UiState : CircuitUiState > Represents a composable UI for the given UiState . Conventionally, this should just be the return type of a ui function and a thin shim over a \"real\" implementation. This has two main benefits: Discouraging properties and general non-composable state that writing a class may invite. Ensuring separation of Ui instance from Screen specific ui composables allows for and encourages easy UI previews via Compose\u2019s Preview annotations. Usage: internal fun tacoUi (): Ui < State > = ui { state -> Tacos ( state ) } @Composable private fun Tacos ( state : State ) {...} @Preview @Composable private fun PreviewTacos () = Tacos (...) This could be a class, but isn\u2019t necessary unless you\u2019re using dependency injection. Most UIs don\u2019t use dependency injection at all however, unless maybe getting assisted injections of things like image loaders. If a given Presenter only ever emits the same state, you can define a single value-less object type for the state. Note that due to a bug in studio, we can\u2019t make this a fun interface yet . Instead, use ui . See also \u00b6 common ui Types \u00b6 Name Summary Factory [common] fun interface Factory A factory that creates ScreenUis , which in turn contain the desired Ui for a given Screen . Functions \u00b6 Name Summary Content [common] @ Composable abstract fun Content (state: UiState )","title":"Index"},{"location":"api/0.x/circuit/com.slack.circuit/-ui/#ui","text":"[common]\\ interface Ui < UiState : CircuitUiState > Represents a composable UI for the given UiState . Conventionally, this should just be the return type of a ui function and a thin shim over a \"real\" implementation. This has two main benefits: Discouraging properties and general non-composable state that writing a class may invite. Ensuring separation of Ui instance from Screen specific ui composables allows for and encourages easy UI previews via Compose\u2019s Preview annotations. Usage: internal fun tacoUi (): Ui < State > = ui { state -> Tacos ( state ) } @Composable private fun Tacos ( state : State ) {...} @Preview @Composable private fun PreviewTacos () = Tacos (...) This could be a class, but isn\u2019t necessary unless you\u2019re using dependency injection. Most UIs don\u2019t use dependency injection at all however, unless maybe getting assisted injections of things like image loaders. If a given Presenter only ever emits the same state, you can define a single value-less object type for the state. Note that due to a bug in studio, we can\u2019t make this a fun interface yet . Instead, use ui .","title":"Ui"},{"location":"api/0.x/circuit/com.slack.circuit/-ui/#see-also","text":"common ui","title":"See also"},{"location":"api/0.x/circuit/com.slack.circuit/-ui/#types","text":"Name Summary Factory [common] fun interface Factory A factory that creates ScreenUis , which in turn contain the desired Ui for a given Screen .","title":"Types"},{"location":"api/0.x/circuit/com.slack.circuit/-ui/#functions","text":"Name Summary Content [common] @ Composable abstract fun Content (state: UiState )","title":"Functions"},{"location":"api/0.x/circuit/com.slack.circuit/-ui/-content/","text":"// circuit / com.slack.circuit / Ui / Content Content \u00b6 [common]\\ @ Composable abstract fun Content (state: UiState )","title":" content"},{"location":"api/0.x/circuit/com.slack.circuit/-ui/-content/#content","text":"[common]\\ @ Composable abstract fun Content (state: UiState )","title":"Content"},{"location":"api/0.x/circuit/com.slack.circuit/-ui/-factory/","text":"// circuit / com.slack.circuit / Ui / Factory Factory \u00b6 [common]\\ fun interface Factory A factory that creates ScreenUis , which in turn contain the desired Ui for a given Screen . Note that individual UIs should just be top-level ui function calls that factories simply call into. This allows easily standing up composable preview functions. class FavoritesUiFactory @Inject constructor () : Ui . Factory { override fun create ( screen : Screen , circuitConfig : CircuitConfig ): ScreenUi? { val ui = when ( screen ) { is AddFavorites -> { addFavoritesUi () } else -> return null } return ScreenUi ( ui = ui as Ui <* , *> , ) } } private fun addFavoritesUi () = ui < AddFavorites . State > { state -> Favorites ( state ) } @Composable private fun Favorites ( state : State ) {...} Functions \u00b6 Name Summary create [common] abstract fun create (screen: Screen , circuitConfig: CircuitConfig ): ScreenUi ?","title":"Index"},{"location":"api/0.x/circuit/com.slack.circuit/-ui/-factory/#factory","text":"[common]\\ fun interface Factory A factory that creates ScreenUis , which in turn contain the desired Ui for a given Screen . Note that individual UIs should just be top-level ui function calls that factories simply call into. This allows easily standing up composable preview functions. class FavoritesUiFactory @Inject constructor () : Ui . Factory { override fun create ( screen : Screen , circuitConfig : CircuitConfig ): ScreenUi? { val ui = when ( screen ) { is AddFavorites -> { addFavoritesUi () } else -> return null } return ScreenUi ( ui = ui as Ui <* , *> , ) } } private fun addFavoritesUi () = ui < AddFavorites . State > { state -> Favorites ( state ) } @Composable private fun Favorites ( state : State ) {...}","title":"Factory"},{"location":"api/0.x/circuit/com.slack.circuit/-ui/-factory/#functions","text":"Name Summary create [common] abstract fun create (screen: Screen , circuitConfig: CircuitConfig ): ScreenUi ?","title":"Functions"},{"location":"api/0.x/circuit/com.slack.circuit/-ui/-factory/create/","text":"// circuit / com.slack.circuit / Ui / Factory / create create \u00b6 [common]\\ abstract fun create (screen: Screen , circuitConfig: CircuitConfig ): ScreenUi ?","title":"Create"},{"location":"api/0.x/circuit/com.slack.circuit/-ui/-factory/create/#create","text":"[common]\\ abstract fun create (screen: Screen , circuitConfig: CircuitConfig ): ScreenUi ?","title":"create"},{"location":"api/0.x/circuit-codegen/com.slack.circuit.codegen/","text":"// circuit-codegen / com.slack.circuit.codegen Package-level declarations \u00b6 Types \u00b6 Name Summary CircuitSymbolProcessorProvider [jvm] @AutoService(value = [SymbolProcessorProvider::class]) class CircuitSymbolProcessorProvider : SymbolProcessorProvider","title":"Index"},{"location":"api/0.x/circuit-codegen/com.slack.circuit.codegen/#package-level-declarations","text":"","title":"Package-level declarations"},{"location":"api/0.x/circuit-codegen/com.slack.circuit.codegen/#types","text":"Name Summary CircuitSymbolProcessorProvider [jvm] @AutoService(value = [SymbolProcessorProvider::class]) class CircuitSymbolProcessorProvider : SymbolProcessorProvider","title":"Types"},{"location":"api/0.x/circuit-codegen/com.slack.circuit.codegen/-circuit-symbol-processor-provider/","text":"// circuit-codegen / com.slack.circuit.codegen / CircuitSymbolProcessorProvider CircuitSymbolProcessorProvider \u00b6 [jvm]\\ @AutoService(value = [SymbolProcessorProvider::class]) class CircuitSymbolProcessorProvider : SymbolProcessorProvider Constructors \u00b6 CircuitSymbolProcessorProvider [jvm] fun CircuitSymbolProcessorProvider () Functions \u00b6 Name Summary create [jvm] open override fun create (environment: SymbolProcessorEnvironment): SymbolProcessor","title":"Index"},{"location":"api/0.x/circuit-codegen/com.slack.circuit.codegen/-circuit-symbol-processor-provider/#circuitsymbolprocessorprovider","text":"[jvm]\\ @AutoService(value = [SymbolProcessorProvider::class]) class CircuitSymbolProcessorProvider : SymbolProcessorProvider","title":"CircuitSymbolProcessorProvider"},{"location":"api/0.x/circuit-codegen/com.slack.circuit.codegen/-circuit-symbol-processor-provider/#constructors","text":"CircuitSymbolProcessorProvider [jvm] fun CircuitSymbolProcessorProvider ()","title":"Constructors"},{"location":"api/0.x/circuit-codegen/com.slack.circuit.codegen/-circuit-symbol-processor-provider/#functions","text":"Name Summary create [jvm] open override fun create (environment: SymbolProcessorEnvironment): SymbolProcessor","title":"Functions"},{"location":"api/0.x/circuit-codegen/com.slack.circuit.codegen/-circuit-symbol-processor-provider/-circuit-symbol-processor-provider/","text":"// circuit-codegen / com.slack.circuit.codegen / CircuitSymbolProcessorProvider / CircuitSymbolProcessorProvider CircuitSymbolProcessorProvider \u00b6 [jvm]\\ fun CircuitSymbolProcessorProvider ()","title":" circuit symbol processor provider"},{"location":"api/0.x/circuit-codegen/com.slack.circuit.codegen/-circuit-symbol-processor-provider/-circuit-symbol-processor-provider/#circuitsymbolprocessorprovider","text":"[jvm]\\ fun CircuitSymbolProcessorProvider ()","title":"CircuitSymbolProcessorProvider"},{"location":"api/0.x/circuit-codegen/com.slack.circuit.codegen/-circuit-symbol-processor-provider/create/","text":"// circuit-codegen / com.slack.circuit.codegen / CircuitSymbolProcessorProvider / create create \u00b6 [jvm]\\ open override fun create (environment: SymbolProcessorEnvironment): SymbolProcessor","title":"Create"},{"location":"api/0.x/circuit-codegen/com.slack.circuit.codegen/-circuit-symbol-processor-provider/create/#create","text":"[jvm]\\ open override fun create (environment: SymbolProcessorEnvironment): SymbolProcessor","title":"create"},{"location":"api/0.x/circuit-codegen-annotations/com.slack.circuit.codegen.annotations/","text":"// circuit-codegen-annotations / com.slack.circuit.codegen.annotations Package-level declarations \u00b6 Types \u00b6 Name Summary CircuitInject [common] @ Target (allowedTargets = [ AnnotationTarget.CLASS , AnnotationTarget.FUNCTION ]) annotation class CircuitInject (val screen: KClass <out <Error class: unknown class>>, val scope: KClass <*>) This annotation is used to mark a UI or presenter class or function for code generation. When annotated, the type\u2019s corresponding factory will be generated and keyed with the defined screen .","title":"circuit-codegen-annotations"},{"location":"api/0.x/circuit-codegen-annotations/com.slack.circuit.codegen.annotations/#package-level-declarations","text":"","title":"Package-level declarations"},{"location":"api/0.x/circuit-codegen-annotations/com.slack.circuit.codegen.annotations/#types","text":"Name Summary CircuitInject [common] @ Target (allowedTargets = [ AnnotationTarget.CLASS , AnnotationTarget.FUNCTION ]) annotation class CircuitInject (val screen: KClass <out <Error class: unknown class>>, val scope: KClass <*>) This annotation is used to mark a UI or presenter class or function for code generation. When annotated, the type\u2019s corresponding factory will be generated and keyed with the defined screen .","title":"Types"},{"location":"api/0.x/circuit-codegen-annotations/com.slack.circuit.codegen.annotations/-circuit-inject/","text":"// circuit-codegen-annotations / com.slack.circuit.codegen.annotations / CircuitInject CircuitInject \u00b6 [common]\\ @ Target (allowedTargets = [ AnnotationTarget.CLASS , AnnotationTarget.FUNCTION ]) annotation class CircuitInject (val screen: KClass <out <Error class: unknown class>>, val scope: KClass <*>) This annotation is used to mark a UI or presenter class or function for code generation. When annotated, the type\u2019s corresponding factory will be generated and keyed with the defined screen . The generated factories are then contributed to Anvil via ContributesMultibinding and scoped with the provided scope key. Classes \u00b6 Presenter and Ui classes can be annotated and have their corresponding Presenter.Factory or Ui.Factory classes generated for them. Presenter @CircuitInject ( HomeScreen :: class , AppScope :: class ) class HomePresenter @Inject constructor (...) : Presenter < HomeState > { ... } // Generates @ContributesMultibinding ( AppScope :: class ) class HomePresenterFactory @Inject constructor () : Presenter . Factory { ... } UI @CircuitInject ( HomeScreen :: class , AppScope :: class ) class HomeUi @Inject constructor (...) : Ui < HomeState > { ... } // Generates @ContributesMultibinding ( AppScope :: class ) class HomeUiFactory @Inject constructor () : Ui . Factory { ... } Functions \u00b6 Simple functions can be annotated and have a corresponding Presenter.Factory generated. This is primarily useful for simple cases where a class is just technical tedium. Requirements Presenter function names must end in Presenter , otherwise they will be treated as UI functions. Presenter functions must return a CircuitUiState type. UI functions can optionally accept a CircuitUiState type as a parameter, but it is not required. UI functions must return Unit . Both presenter and UI functions must be Composable . Presenter @CircuitInject ( HomeScreen :: class , AppScope :: class ) @Composable fun HomePresenter (): HomeState { ... } // Generates @ContributesMultibinding ( AppScope :: class ) class HomePresenterFactory @Inject constructor () : Presenter . Factory { ... } UI @CircuitInject ( HomeScreen :: class , AppScope :: class ) @Composable fun Home ( state : HomeState ) { ... } // Generates @ContributesMultibinding ( AppScope :: class ) class HomeUiFactory @Inject constructor () : Ui . Factory { ... } Assisted injection \u00b6 Any type that is offered in Presenter.Factory and Ui.Factory can be offered as an assisted injection to types using Dagger AssistedInject. For these cases, the AssistedFactory -annotated interface should be annotated with CircuitInject instead of the enclosing class. Types available for assisted injection are: Screen \u2013 the screen key used to create the Presenter or Ui. Navigator \u2013 (presenters only) CircuitConfig Each should only be defined at-most once. Examples // Function example @CircuitInject ( HomeScreen :: class , AppScope :: class ) @Composable fun HomePresenter ( screen : Screen , navigator : Navigator ): HomeState { ... } // Class example class HomePresenter @AssistedInject constructor ( @Assisted screen : Screen , @Assisted navigator : Navigator , ... ) : Presenter < HomeState > { // ... @CircuitInject ( HomeScreen :: class , AppScope :: class ) @AssistedFactory fun interface Factory { fun create ( screen : Screen , navigator : Navigator ): HomePresenter } } Properties \u00b6 Name Summary scope [common] val scope : KClass <*> screen [common] val screen : KClass <out <Error class: unknown class>>","title":"Index"},{"location":"api/0.x/circuit-codegen-annotations/com.slack.circuit.codegen.annotations/-circuit-inject/#circuitinject","text":"[common]\\ @ Target (allowedTargets = [ AnnotationTarget.CLASS , AnnotationTarget.FUNCTION ]) annotation class CircuitInject (val screen: KClass <out <Error class: unknown class>>, val scope: KClass <*>) This annotation is used to mark a UI or presenter class or function for code generation. When annotated, the type\u2019s corresponding factory will be generated and keyed with the defined screen . The generated factories are then contributed to Anvil via ContributesMultibinding and scoped with the provided scope key.","title":"CircuitInject"},{"location":"api/0.x/circuit-codegen-annotations/com.slack.circuit.codegen.annotations/-circuit-inject/#classes","text":"Presenter and Ui classes can be annotated and have their corresponding Presenter.Factory or Ui.Factory classes generated for them. Presenter @CircuitInject ( HomeScreen :: class , AppScope :: class ) class HomePresenter @Inject constructor (...) : Presenter < HomeState > { ... } // Generates @ContributesMultibinding ( AppScope :: class ) class HomePresenterFactory @Inject constructor () : Presenter . Factory { ... } UI @CircuitInject ( HomeScreen :: class , AppScope :: class ) class HomeUi @Inject constructor (...) : Ui < HomeState > { ... } // Generates @ContributesMultibinding ( AppScope :: class ) class HomeUiFactory @Inject constructor () : Ui . Factory { ... }","title":"Classes"},{"location":"api/0.x/circuit-codegen-annotations/com.slack.circuit.codegen.annotations/-circuit-inject/#functions","text":"Simple functions can be annotated and have a corresponding Presenter.Factory generated. This is primarily useful for simple cases where a class is just technical tedium. Requirements Presenter function names must end in Presenter , otherwise they will be treated as UI functions. Presenter functions must return a CircuitUiState type. UI functions can optionally accept a CircuitUiState type as a parameter, but it is not required. UI functions must return Unit . Both presenter and UI functions must be Composable . Presenter @CircuitInject ( HomeScreen :: class , AppScope :: class ) @Composable fun HomePresenter (): HomeState { ... } // Generates @ContributesMultibinding ( AppScope :: class ) class HomePresenterFactory @Inject constructor () : Presenter . Factory { ... } UI @CircuitInject ( HomeScreen :: class , AppScope :: class ) @Composable fun Home ( state : HomeState ) { ... } // Generates @ContributesMultibinding ( AppScope :: class ) class HomeUiFactory @Inject constructor () : Ui . Factory { ... }","title":"Functions"},{"location":"api/0.x/circuit-codegen-annotations/com.slack.circuit.codegen.annotations/-circuit-inject/#assisted-injection","text":"Any type that is offered in Presenter.Factory and Ui.Factory can be offered as an assisted injection to types using Dagger AssistedInject. For these cases, the AssistedFactory -annotated interface should be annotated with CircuitInject instead of the enclosing class. Types available for assisted injection are: Screen \u2013 the screen key used to create the Presenter or Ui. Navigator \u2013 (presenters only) CircuitConfig Each should only be defined at-most once. Examples // Function example @CircuitInject ( HomeScreen :: class , AppScope :: class ) @Composable fun HomePresenter ( screen : Screen , navigator : Navigator ): HomeState { ... } // Class example class HomePresenter @AssistedInject constructor ( @Assisted screen : Screen , @Assisted navigator : Navigator , ... ) : Presenter < HomeState > { // ... @CircuitInject ( HomeScreen :: class , AppScope :: class ) @AssistedFactory fun interface Factory { fun create ( screen : Screen , navigator : Navigator ): HomePresenter } }","title":"Assisted injection"},{"location":"api/0.x/circuit-codegen-annotations/com.slack.circuit.codegen.annotations/-circuit-inject/#properties","text":"Name Summary scope [common] val scope : KClass <*> screen [common] val screen : KClass <out <Error class: unknown class>>","title":"Properties"},{"location":"api/0.x/circuit-codegen-annotations/com.slack.circuit.codegen.annotations/-circuit-inject/scope/","text":"// circuit-codegen-annotations / com.slack.circuit.codegen.annotations / CircuitInject / scope scope \u00b6 [common]\\ val scope : KClass <*>","title":"Scope"},{"location":"api/0.x/circuit-codegen-annotations/com.slack.circuit.codegen.annotations/-circuit-inject/scope/#scope","text":"[common]\\ val scope : KClass <*>","title":"scope"},{"location":"api/0.x/circuit-codegen-annotations/com.slack.circuit.codegen.annotations/-circuit-inject/screen/","text":"// circuit-codegen-annotations / com.slack.circuit.codegen.annotations / CircuitInject / screen screen \u00b6 [common]\\ val screen : KClass <out <Error class: unknown class>>","title":"Screen"},{"location":"api/0.x/circuit-codegen-annotations/com.slack.circuit.codegen.annotations/-circuit-inject/screen/#screen","text":"[common]\\ val screen : KClass <out <Error class: unknown class>>","title":"screen"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/","text":"// circuit-overlay / com.slack.circuit.overlay Package-level declarations \u00b6 Types \u00b6 Name Summary Overlay [common] interface Overlay < Result : Any > An Overlay is composable content that can be shown on top of other content via an OverlayHost . Overlays are typically used for one-off request/result flows and should not usually attempt to do any sort of external navigation or make any assumptions about the state of the app. They should only emit a Result to the given OverlayNavigator when they are done. OverlayHost [common] @ Stable interface OverlayHost An OverlayHost can be used overlays Overlay with content on top of other content. This is useful for one-off request/result flows such as: OverlayHostData [common] @ Stable interface OverlayHostData < Result : Any > Data managed by an OverlayHost to track the current overlay state. This should rarely be implemented by consumers! OverlayNavigator [common] @ Stable fun interface OverlayNavigator < Result : Any > An OverlayNavigator is a simple API offered to overlays to call finish with a result when they are done. Functions \u00b6 Name Summary ContentWithOverlays [android] @ Composable fun ContentWithOverlays (modifier: Modifier = Modifier, overlayHost: OverlayHost = rememberOverlayHost(), content: @ Composable () -> Unit ) Renders the given content with the ability to show overlays on top of it. This works by exposing an OverlayHost via LocalOverlayHost. rememberOverlayHost [common] @ Composable fun rememberOverlayHost (): OverlayHost Returns a remembered an OverlayHost that can be used to show overlays. Properties \u00b6 Name Summary LocalOverlayHost [common] val LocalOverlayHost : ProvidableCompositionLocal < OverlayHost > A ProvidableCompositionLocal to expose the current OverlayHost in the composition tree.","title":"circuit-overlay"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/#package-level-declarations","text":"","title":"Package-level declarations"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/#types","text":"Name Summary Overlay [common] interface Overlay < Result : Any > An Overlay is composable content that can be shown on top of other content via an OverlayHost . Overlays are typically used for one-off request/result flows and should not usually attempt to do any sort of external navigation or make any assumptions about the state of the app. They should only emit a Result to the given OverlayNavigator when they are done. OverlayHost [common] @ Stable interface OverlayHost An OverlayHost can be used overlays Overlay with content on top of other content. This is useful for one-off request/result flows such as: OverlayHostData [common] @ Stable interface OverlayHostData < Result : Any > Data managed by an OverlayHost to track the current overlay state. This should rarely be implemented by consumers! OverlayNavigator [common] @ Stable fun interface OverlayNavigator < Result : Any > An OverlayNavigator is a simple API offered to overlays to call finish with a result when they are done.","title":"Types"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/#functions","text":"Name Summary ContentWithOverlays [android] @ Composable fun ContentWithOverlays (modifier: Modifier = Modifier, overlayHost: OverlayHost = rememberOverlayHost(), content: @ Composable () -> Unit ) Renders the given content with the ability to show overlays on top of it. This works by exposing an OverlayHost via LocalOverlayHost. rememberOverlayHost [common] @ Composable fun rememberOverlayHost (): OverlayHost Returns a remembered an OverlayHost that can be used to show overlays.","title":"Functions"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/#properties","text":"Name Summary LocalOverlayHost [common] val LocalOverlayHost : ProvidableCompositionLocal < OverlayHost > A ProvidableCompositionLocal to expose the current OverlayHost in the composition tree.","title":"Properties"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-content-with-overlays/","text":"// circuit-overlay / com.slack.circuit.overlay / ContentWithOverlays ContentWithOverlays \u00b6 [android]\\ @ Composable fun ContentWithOverlays (modifier: Modifier = Modifier, overlayHost: OverlayHost = rememberOverlayHost(), content: @ Composable () -> Unit ) Renders the given content with the ability to show overlays on top of it. This works by exposing an OverlayHost via LocalOverlayHost. Parameters \u00b6 android modifier The modifier to be applied to the layout. overlayHost the OverlayHost to use for managing overlays. content The regular content to render. Any overlays will be rendered over them.","title":" content with overlays"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-content-with-overlays/#contentwithoverlays","text":"[android]\\ @ Composable fun ContentWithOverlays (modifier: Modifier = Modifier, overlayHost: OverlayHost = rememberOverlayHost(), content: @ Composable () -> Unit ) Renders the given content with the ability to show overlays on top of it. This works by exposing an OverlayHost via LocalOverlayHost.","title":"ContentWithOverlays"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-content-with-overlays/#parameters","text":"android modifier The modifier to be applied to the layout. overlayHost the OverlayHost to use for managing overlays. content The regular content to render. Any overlays will be rendered over them.","title":"Parameters"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-local-overlay-host/","text":"// circuit-overlay / com.slack.circuit.overlay / LocalOverlayHost LocalOverlayHost \u00b6 [common]\\ val LocalOverlayHost : ProvidableCompositionLocal < OverlayHost > A ProvidableCompositionLocal to expose the current OverlayHost in the composition tree.","title":" local overlay host"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-local-overlay-host/#localoverlayhost","text":"[common]\\ val LocalOverlayHost : ProvidableCompositionLocal < OverlayHost > A ProvidableCompositionLocal to expose the current OverlayHost in the composition tree.","title":"LocalOverlayHost"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/remember-overlay-host/","text":"// circuit-overlay / com.slack.circuit.overlay / rememberOverlayHost rememberOverlayHost \u00b6 [common]\\ @ Composable fun rememberOverlayHost (): OverlayHost Returns a remembered an OverlayHost that can be used to show overlays.","title":"Remember overlay host"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/remember-overlay-host/#rememberoverlayhost","text":"[common]\\ @ Composable fun rememberOverlayHost (): OverlayHost Returns a remembered an OverlayHost that can be used to show overlays.","title":"rememberOverlayHost"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-overlay/","text":"// circuit-overlay / com.slack.circuit.overlay / Overlay Overlay \u00b6 [common]\\ interface Overlay < Result : Any > An Overlay is composable content that can be shown on top of other content via an OverlayHost . Overlays are typically used for one-off request/result flows and should not usually attempt to do any sort of external navigation or make any assumptions about the state of the app. They should only emit a Result to the given OverlayNavigator when they are done. For common overlays, it\u2019s useful to create a common Overlay subtype that can be reused. For example: BottomSheetOverlay , ModalOverlay , TooltipOverlay , etc. Functions \u00b6 Name Summary Content [common] @ Composable abstract fun Content (navigator: OverlayNavigator < Result >)","title":"Index"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-overlay/#overlay","text":"[common]\\ interface Overlay < Result : Any > An Overlay is composable content that can be shown on top of other content via an OverlayHost . Overlays are typically used for one-off request/result flows and should not usually attempt to do any sort of external navigation or make any assumptions about the state of the app. They should only emit a Result to the given OverlayNavigator when they are done. For common overlays, it\u2019s useful to create a common Overlay subtype that can be reused. For example: BottomSheetOverlay , ModalOverlay , TooltipOverlay , etc.","title":"Overlay"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-overlay/#functions","text":"Name Summary Content [common] @ Composable abstract fun Content (navigator: OverlayNavigator < Result >)","title":"Functions"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-overlay/-content/","text":"// circuit-overlay / com.slack.circuit.overlay / Overlay / Content Content \u00b6 [common]\\ @ Composable abstract fun Content (navigator: OverlayNavigator < Result >)","title":" content"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-overlay/-content/#content","text":"[common]\\ @ Composable abstract fun Content (navigator: OverlayNavigator < Result >)","title":"Content"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-overlay-host/","text":"// circuit-overlay / com.slack.circuit.overlay / OverlayHost OverlayHost \u00b6 [common]\\ @ Stable interface OverlayHost An OverlayHost can be used overlays Overlay with content on top of other content. This is useful for one-off request/result flows such as: Bottom sheets Modals/dialogs Tooltips Full-screen takeover prompts etc. The suspend show function is generically typed and can be suspended on to await the result of whatever overlay was launched. currentOverlayData is read-only and can be used to observe the current overlay data. This is generally intended to be used wherever the OverlayHost is provided via LocalOverlayHost . In Android, this can be managed via the ContentWithOverlays composable function. To avoid accidentally capturing unnecessary state, it\u2019s recommended to create extension functions on OverlayHost that call show with the appropriate overlay and result type. private suspend fun OverlayHost . confirm ( message : String ): ConfirmationResult { return show ( ConfirmationOverlay ( message )) } Functions \u00b6 Name Summary show [common] abstract suspend fun < Result : Any > show (overlay: Overlay < Result >): Result Shows the given overlay and suspends until the overlay is finished with a Result . The overlay should always signal a result (even if it\u2019s just something like Result.Dismissed ) so that the OverlayHost can properly clear its currentOverlayData . Properties \u00b6 Name Summary currentOverlayData [common] abstract val currentOverlayData : OverlayHostData < Any >? The current OverlayHostData or null if no overlay is currently showing.","title":"Index"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-overlay-host/#overlayhost","text":"[common]\\ @ Stable interface OverlayHost An OverlayHost can be used overlays Overlay with content on top of other content. This is useful for one-off request/result flows such as: Bottom sheets Modals/dialogs Tooltips Full-screen takeover prompts etc. The suspend show function is generically typed and can be suspended on to await the result of whatever overlay was launched. currentOverlayData is read-only and can be used to observe the current overlay data. This is generally intended to be used wherever the OverlayHost is provided via LocalOverlayHost . In Android, this can be managed via the ContentWithOverlays composable function. To avoid accidentally capturing unnecessary state, it\u2019s recommended to create extension functions on OverlayHost that call show with the appropriate overlay and result type. private suspend fun OverlayHost . confirm ( message : String ): ConfirmationResult { return show ( ConfirmationOverlay ( message )) }","title":"OverlayHost"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-overlay-host/#functions","text":"Name Summary show [common] abstract suspend fun < Result : Any > show (overlay: Overlay < Result >): Result Shows the given overlay and suspends until the overlay is finished with a Result . The overlay should always signal a result (even if it\u2019s just something like Result.Dismissed ) so that the OverlayHost can properly clear its currentOverlayData .","title":"Functions"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-overlay-host/#properties","text":"Name Summary currentOverlayData [common] abstract val currentOverlayData : OverlayHostData < Any >? The current OverlayHostData or null if no overlay is currently showing.","title":"Properties"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-overlay-host/current-overlay-data/","text":"// circuit-overlay / com.slack.circuit.overlay / OverlayHost / currentOverlayData currentOverlayData \u00b6 [common]\\ abstract val currentOverlayData : OverlayHostData < Any >? The current OverlayHostData or null if no overlay is currently showing. val overlayHostData by rememberUpdatedState ( overlayHost . currentOverlayData ) Box ( modifier ) { content () // The regular content key ( overlayHostData ) { overlayHostData ?. let { data -> data . overlay . Content ( data :: finish ) } } }","title":"Current overlay data"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-overlay-host/current-overlay-data/#currentoverlaydata","text":"[common]\\ abstract val currentOverlayData : OverlayHostData < Any >? The current OverlayHostData or null if no overlay is currently showing. val overlayHostData by rememberUpdatedState ( overlayHost . currentOverlayData ) Box ( modifier ) { content () // The regular content key ( overlayHostData ) { overlayHostData ?. let { data -> data . overlay . Content ( data :: finish ) } } }","title":"currentOverlayData"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-overlay-host/show/","text":"// circuit-overlay / com.slack.circuit.overlay / OverlayHost / show show \u00b6 [common]\\ abstract suspend fun < Result : Any > show (overlay: Overlay < Result >): Result Shows the given overlay and suspends until the overlay is finished with a Result . The overlay should always signal a result (even if it\u2019s just something like Result.Dismissed ) so that the OverlayHost can properly clear its currentOverlayData . If no data is needed in a result, use Unit for the result type. This function should only be called from UI contexts and not presenters, as overlays are a UI concern.","title":"Show"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-overlay-host/show/#show","text":"[common]\\ abstract suspend fun < Result : Any > show (overlay: Overlay < Result >): Result Shows the given overlay and suspends until the overlay is finished with a Result . The overlay should always signal a result (even if it\u2019s just something like Result.Dismissed ) so that the OverlayHost can properly clear its currentOverlayData . If no data is needed in a result, use Unit for the result type. This function should only be called from UI contexts and not presenters, as overlays are a UI concern.","title":"show"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-overlay-host-data/","text":"// circuit-overlay / com.slack.circuit.overlay / OverlayHostData OverlayHostData \u00b6 [common]\\ @ Stable interface OverlayHostData < Result : Any > Data managed by an OverlayHost to track the current overlay state. This should rarely be implemented by consumers! Functions \u00b6 Name Summary finish [common] abstract fun finish (result: Result ) Invoked to finish the current overlay with the given result . This should be called by wherever the OverlayHost is being managed. Properties \u00b6 Name Summary overlay [common] abstract val overlay : Overlay < Result > The Overlay that is currently being shown. Read-only.","title":"Index"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-overlay-host-data/#overlayhostdata","text":"[common]\\ @ Stable interface OverlayHostData < Result : Any > Data managed by an OverlayHost to track the current overlay state. This should rarely be implemented by consumers!","title":"OverlayHostData"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-overlay-host-data/#functions","text":"Name Summary finish [common] abstract fun finish (result: Result ) Invoked to finish the current overlay with the given result . This should be called by wherever the OverlayHost is being managed.","title":"Functions"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-overlay-host-data/#properties","text":"Name Summary overlay [common] abstract val overlay : Overlay < Result > The Overlay that is currently being shown. Read-only.","title":"Properties"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-overlay-host-data/finish/","text":"// circuit-overlay / com.slack.circuit.overlay / OverlayHostData / finish finish \u00b6 [common]\\ abstract fun finish (result: Result ) Invoked to finish the current overlay with the given result . This should be called by wherever the OverlayHost is being managed.","title":"Finish"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-overlay-host-data/finish/#finish","text":"[common]\\ abstract fun finish (result: Result ) Invoked to finish the current overlay with the given result . This should be called by wherever the OverlayHost is being managed.","title":"finish"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-overlay-host-data/overlay/","text":"// circuit-overlay / com.slack.circuit.overlay / OverlayHostData / overlay overlay \u00b6 [common]\\ abstract val overlay : Overlay < Result > The Overlay that is currently being shown. Read-only.","title":"Overlay"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-overlay-host-data/overlay/#overlay","text":"[common]\\ abstract val overlay : Overlay < Result > The Overlay that is currently being shown. Read-only.","title":"overlay"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-overlay-navigator/","text":"// circuit-overlay / com.slack.circuit.overlay / OverlayNavigator OverlayNavigator \u00b6 [common]\\ @ Stable fun interface OverlayNavigator < Result : Any > An OverlayNavigator is a simple API offered to overlays to call finish with a result when they are done. Functions \u00b6 Name Summary finish [common] abstract fun finish (result: Result ) Called by the Overlay with a result it\u2019s done.","title":"Index"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-overlay-navigator/#overlaynavigator","text":"[common]\\ @ Stable fun interface OverlayNavigator < Result : Any > An OverlayNavigator is a simple API offered to overlays to call finish with a result when they are done.","title":"OverlayNavigator"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-overlay-navigator/#functions","text":"Name Summary finish [common] abstract fun finish (result: Result ) Called by the Overlay with a result it\u2019s done.","title":"Functions"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-overlay-navigator/finish/","text":"// circuit-overlay / com.slack.circuit.overlay / OverlayNavigator / finish finish \u00b6 [common]\\ abstract fun finish (result: Result ) Called by the Overlay with a result it\u2019s done.","title":"Finish"},{"location":"api/0.x/circuit-overlay/com.slack.circuit.overlay/-overlay-navigator/finish/#finish","text":"[common]\\ abstract fun finish (result: Result ) Called by the Overlay with a result it\u2019s done.","title":"finish"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/","text":"// circuit-retained / com.slack.circuit.retained Package-level declarations \u00b6 Types \u00b6 Name Summary Continuity [android] class Continuity : ViewModel , RetainedStateRegistry LocalRetainedStateRegistryOwner [common] object LocalRetainedStateRegistryOwner CompositionLocal with a current RetainedStateRegistry instance. RetainedStateRegistry [common] interface RetainedStateRegistry Allows components to save and restore their state using the onRetainNonConfigurationInstance mechanism. Functions \u00b6 Name Summary continuityRetainedStateRegistry [android] @ Composable fun continuityRetainedStateRegistry (factory: ViewModelProvider.Factory ? = null): RetainedStateRegistry Provides a RetainedStateRegistry. produceRetainedState [common] @ Composable fun < T > produceRetainedState (initialValue: T , producer: suspend ProduceStateScope < T >.() -> Unit ): State < T > Return an observable snapshot State that produces values over time without a defined data source. [common] @ Composable fun < T > produceRetainedState (initialValue: T , key1: Any ?, producer: suspend ProduceStateScope < T >.() -> Unit ): State < T > Return an observable snapshot State that produces values over time from key1 . [common] @ Composable fun < T > produceRetainedState (initialValue: T , vararg keys: Any ?, producer: suspend ProduceStateScope < T >.() -> Unit ): State < T > Return an observable snapshot State that produces values over time from keys . [common] @ Composable fun < T > produceRetainedState (initialValue: T , key1: Any ?, key2: Any ?, producer: suspend ProduceStateScope < T >.() -> Unit ): State < T > Return an observable snapshot State that produces values over time from key1 and key2 . [common] @ Composable fun < T > produceRetainedState (initialValue: T , key1: Any ?, key2: Any ?, key3: Any ?, producer: suspend ProduceStateScope < T >.() -> Unit ): State < T > Return an observable snapshot State that produces values over time from key1 , key2 and key3 . rememberRetained [common] @ Composable fun < T : Any > rememberRetained (vararg inputs: Any ?, key: String ? = null, init: () -> T ): T Remember the value produced by init . RetainedStateRegistry [common] fun RetainedStateRegistry (values: Map < String , List < Any ?>>?): RetainedStateRegistry Creates RetainedStateRegistry .","title":"circuit-retained"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/#package-level-declarations","text":"","title":"Package-level declarations"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/#types","text":"Name Summary Continuity [android] class Continuity : ViewModel , RetainedStateRegistry LocalRetainedStateRegistryOwner [common] object LocalRetainedStateRegistryOwner CompositionLocal with a current RetainedStateRegistry instance. RetainedStateRegistry [common] interface RetainedStateRegistry Allows components to save and restore their state using the onRetainNonConfigurationInstance mechanism.","title":"Types"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/#functions","text":"Name Summary continuityRetainedStateRegistry [android] @ Composable fun continuityRetainedStateRegistry (factory: ViewModelProvider.Factory ? = null): RetainedStateRegistry Provides a RetainedStateRegistry. produceRetainedState [common] @ Composable fun < T > produceRetainedState (initialValue: T , producer: suspend ProduceStateScope < T >.() -> Unit ): State < T > Return an observable snapshot State that produces values over time without a defined data source. [common] @ Composable fun < T > produceRetainedState (initialValue: T , key1: Any ?, producer: suspend ProduceStateScope < T >.() -> Unit ): State < T > Return an observable snapshot State that produces values over time from key1 . [common] @ Composable fun < T > produceRetainedState (initialValue: T , vararg keys: Any ?, producer: suspend ProduceStateScope < T >.() -> Unit ): State < T > Return an observable snapshot State that produces values over time from keys . [common] @ Composable fun < T > produceRetainedState (initialValue: T , key1: Any ?, key2: Any ?, producer: suspend ProduceStateScope < T >.() -> Unit ): State < T > Return an observable snapshot State that produces values over time from key1 and key2 . [common] @ Composable fun < T > produceRetainedState (initialValue: T , key1: Any ?, key2: Any ?, key3: Any ?, producer: suspend ProduceStateScope < T >.() -> Unit ): State < T > Return an observable snapshot State that produces values over time from key1 , key2 and key3 . rememberRetained [common] @ Composable fun < T : Any > rememberRetained (vararg inputs: Any ?, key: String ? = null, init: () -> T ): T Remember the value produced by init . RetainedStateRegistry [common] fun RetainedStateRegistry (values: Map < String , List < Any ?>>?): RetainedStateRegistry Creates RetainedStateRegistry .","title":"Functions"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/","text":"// circuit-retained / com.slack.circuit.retained / RetainedStateRegistry RetainedStateRegistry \u00b6 [common]\\ fun RetainedStateRegistry (values: Map < String , List < Any ?>>?): RetainedStateRegistry Creates RetainedStateRegistry . Parameters \u00b6 common values The map of the restored values","title":" retained state registry"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/#retainedstateregistry","text":"[common]\\ fun RetainedStateRegistry (values: Map < String , List < Any ?>>?): RetainedStateRegistry Creates RetainedStateRegistry .","title":"RetainedStateRegistry"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/#parameters","text":"common values The map of the restored values","title":"Parameters"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/continuity-retained-state-registry/","text":"// circuit-retained / com.slack.circuit.retained / continuityRetainedStateRegistry continuityRetainedStateRegistry \u00b6 [android]\\ @ Composable fun continuityRetainedStateRegistry (factory: ViewModelProvider.Factory ? = null): RetainedStateRegistry Provides a RetainedStateRegistry. Parameters \u00b6 android factory an optional ViewModelProvider.Factory to use when creating the Continuity instance.","title":"Continuity retained state registry"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/continuity-retained-state-registry/#continuityretainedstateregistry","text":"[android]\\ @ Composable fun continuityRetainedStateRegistry (factory: ViewModelProvider.Factory ? = null): RetainedStateRegistry Provides a RetainedStateRegistry.","title":"continuityRetainedStateRegistry"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/continuity-retained-state-registry/#parameters","text":"android factory an optional ViewModelProvider.Factory to use when creating the Continuity instance.","title":"Parameters"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/produce-retained-state/","text":"// circuit-retained / com.slack.circuit.retained / produceRetainedState produceRetainedState \u00b6 [common]\\ @ Composable fun < T > produceRetainedState (initialValue: T , producer: suspend ProduceStateScope < T >.() -> Unit ): State < T > Return an observable snapshot State that produces values over time without a defined data source. producer is launched when produceRetainedState enters the composition and is cancelled when produceRetainedState leaves the composition. producer should use ProduceStateScope.value to set new values on the returned State . The returned State conflates values; no change will be observable if ProduceStateScope.value is used to set a value that is equal to its old value, and observers may only see the latest value if several values are set in rapid succession. produceRetainedState may be used to observe either suspending or non-suspending sources of external data, for example: @Composable fun FavoritesPresenter ( favoritesRepository : FavoritesRepository ): State { val state by produceRetainedState < UiState < List < Person >>> ( UiState . Loading , favoritesRepository ) { favoritesRepository . people . map { UiState . Data ( it ) } . collect { value = it } } return state } [common]\\ @ Composable fun < T > produceRetainedState (initialValue: T , key1: Any ?, producer: suspend ProduceStateScope < T >.() -> Unit ): State < T > Return an observable snapshot State that produces values over time from key1 . producer is launched when produceRetainedState enters the composition and is cancelled when produceRetainedState leaves the composition. If key1 changes, a running producer will be cancelled and re-launched for the new source. producer should use ProduceStateScope.value to set new values on the returned State . The returned State conflates values; no change will be observable if ProduceStateScope.value is used to set a value that is equal to its old value, and observers may only see the latest value if several values are set in rapid succession. produceRetainedState may be used to observe either suspending or non-suspending sources of external data, for example: @Composable fun FavoritesPresenter ( favoritesRepository : FavoritesRepository ): State { val state by produceRetainedState < UiState < List < Person >>> ( UiState . Loading , favoritesRepository ) { favoritesRepository . people . map { UiState . Data ( it ) } . collect { value = it } } return state } [common]\\ @ Composable fun < T > produceRetainedState (initialValue: T , key1: Any ?, key2: Any ?, producer: suspend ProduceStateScope < T >.() -> Unit ): State < T > Return an observable snapshot State that produces values over time from key1 and key2 . producer is launched when produceRetainedState enters the composition and is cancelled when produceRetainedState leaves the composition. If key1 or key2 change, a running producer will be cancelled and re-launched for the new source. producer should use ProduceStateScope.value to set new values on the returned State . The returned State conflates values; no change will be observable if ProduceStateScope.value is used to set a value that is equal to its old value, and observers may only see the latest value if several values are set in rapid succession. produceRetainedState may be used to observe either suspending or non-suspending sources of external data, for example: @Composable fun FavoritesPresenter ( favoritesRepository : FavoritesRepository ): State { val state by produceRetainedState < UiState < List < Person >>> ( UiState . Loading , favoritesRepository ) { favoritesRepository . people . map { UiState . Data ( it ) } . collect { value = it } } return state } [common]\\ @ Composable fun < T > produceRetainedState (initialValue: T , key1: Any ?, key2: Any ?, key3: Any ?, producer: suspend ProduceStateScope < T >.() -> Unit ): State < T > Return an observable snapshot State that produces values over time from key1 , key2 and key3 . producer is launched when produceRetainedState enters the composition and is cancelled when produceRetainedState leaves the composition. If key1 , key2 or key3 change, a running producer will be cancelled and re-launched for the new source. [producer should use ProduceStateScope.value to set new values on the returned State . The returned State conflates values; no change will be observable if ProduceStateScope.value is used to set a value that is equal to its old value, and observers may only see the latest value if several values are set in rapid succession. produceRetainedState may be used to observe either suspending or non-suspending sources of external data, for example: @Composable fun FavoritesPresenter ( favoritesRepository : FavoritesRepository ): State { val state by produceRetainedState < UiState < List < Person >>> ( UiState . Loading , favoritesRepository ) { favoritesRepository . people . map { UiState . Data ( it ) } . collect { value = it } } return state } [common]\\ @ Composable fun < T > produceRetainedState (initialValue: T , vararg keys: Any ?, producer: suspend ProduceStateScope < T >.() -> Unit ): State < T > Return an observable snapshot State that produces values over time from keys . producer is launched when produceRetainedState enters the composition and is cancelled when produceRetainedState leaves the composition. If keys change, a running producer will be cancelled and re-launched for the new source. producer should use ProduceStateScope.value to set new values on the returned State . The returned State conflates values; no change will be observable if ProduceStateScope.value is used to set a value that is equal to its old value, and observers may only see the latest value if several values are set in rapid succession. produceRetainedState may be used to observe either suspending or non-suspending sources of external data, for example: @Composable fun FavoritesPresenter ( favoritesRepository : FavoritesRepository ): State { val state by produceRetainedState < UiState < List < Person >>> ( UiState . Loading , favoritesRepository ) { favoritesRepository . people . map { UiState . Data ( it ) } . collect { value = it } } return state }","title":"Produce retained state"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/produce-retained-state/#produceretainedstate","text":"[common]\\ @ Composable fun < T > produceRetainedState (initialValue: T , producer: suspend ProduceStateScope < T >.() -> Unit ): State < T > Return an observable snapshot State that produces values over time without a defined data source. producer is launched when produceRetainedState enters the composition and is cancelled when produceRetainedState leaves the composition. producer should use ProduceStateScope.value to set new values on the returned State . The returned State conflates values; no change will be observable if ProduceStateScope.value is used to set a value that is equal to its old value, and observers may only see the latest value if several values are set in rapid succession. produceRetainedState may be used to observe either suspending or non-suspending sources of external data, for example: @Composable fun FavoritesPresenter ( favoritesRepository : FavoritesRepository ): State { val state by produceRetainedState < UiState < List < Person >>> ( UiState . Loading , favoritesRepository ) { favoritesRepository . people . map { UiState . Data ( it ) } . collect { value = it } } return state } [common]\\ @ Composable fun < T > produceRetainedState (initialValue: T , key1: Any ?, producer: suspend ProduceStateScope < T >.() -> Unit ): State < T > Return an observable snapshot State that produces values over time from key1 . producer is launched when produceRetainedState enters the composition and is cancelled when produceRetainedState leaves the composition. If key1 changes, a running producer will be cancelled and re-launched for the new source. producer should use ProduceStateScope.value to set new values on the returned State . The returned State conflates values; no change will be observable if ProduceStateScope.value is used to set a value that is equal to its old value, and observers may only see the latest value if several values are set in rapid succession. produceRetainedState may be used to observe either suspending or non-suspending sources of external data, for example: @Composable fun FavoritesPresenter ( favoritesRepository : FavoritesRepository ): State { val state by produceRetainedState < UiState < List < Person >>> ( UiState . Loading , favoritesRepository ) { favoritesRepository . people . map { UiState . Data ( it ) } . collect { value = it } } return state } [common]\\ @ Composable fun < T > produceRetainedState (initialValue: T , key1: Any ?, key2: Any ?, producer: suspend ProduceStateScope < T >.() -> Unit ): State < T > Return an observable snapshot State that produces values over time from key1 and key2 . producer is launched when produceRetainedState enters the composition and is cancelled when produceRetainedState leaves the composition. If key1 or key2 change, a running producer will be cancelled and re-launched for the new source. producer should use ProduceStateScope.value to set new values on the returned State . The returned State conflates values; no change will be observable if ProduceStateScope.value is used to set a value that is equal to its old value, and observers may only see the latest value if several values are set in rapid succession. produceRetainedState may be used to observe either suspending or non-suspending sources of external data, for example: @Composable fun FavoritesPresenter ( favoritesRepository : FavoritesRepository ): State { val state by produceRetainedState < UiState < List < Person >>> ( UiState . Loading , favoritesRepository ) { favoritesRepository . people . map { UiState . Data ( it ) } . collect { value = it } } return state } [common]\\ @ Composable fun < T > produceRetainedState (initialValue: T , key1: Any ?, key2: Any ?, key3: Any ?, producer: suspend ProduceStateScope < T >.() -> Unit ): State < T > Return an observable snapshot State that produces values over time from key1 , key2 and key3 . producer is launched when produceRetainedState enters the composition and is cancelled when produceRetainedState leaves the composition. If key1 , key2 or key3 change, a running producer will be cancelled and re-launched for the new source. [producer should use ProduceStateScope.value to set new values on the returned State . The returned State conflates values; no change will be observable if ProduceStateScope.value is used to set a value that is equal to its old value, and observers may only see the latest value if several values are set in rapid succession. produceRetainedState may be used to observe either suspending or non-suspending sources of external data, for example: @Composable fun FavoritesPresenter ( favoritesRepository : FavoritesRepository ): State { val state by produceRetainedState < UiState < List < Person >>> ( UiState . Loading , favoritesRepository ) { favoritesRepository . people . map { UiState . Data ( it ) } . collect { value = it } } return state } [common]\\ @ Composable fun < T > produceRetainedState (initialValue: T , vararg keys: Any ?, producer: suspend ProduceStateScope < T >.() -> Unit ): State < T > Return an observable snapshot State that produces values over time from keys . producer is launched when produceRetainedState enters the composition and is cancelled when produceRetainedState leaves the composition. If keys change, a running producer will be cancelled and re-launched for the new source. producer should use ProduceStateScope.value to set new values on the returned State . The returned State conflates values; no change will be observable if ProduceStateScope.value is used to set a value that is equal to its old value, and observers may only see the latest value if several values are set in rapid succession. produceRetainedState may be used to observe either suspending or non-suspending sources of external data, for example: @Composable fun FavoritesPresenter ( favoritesRepository : FavoritesRepository ): State { val state by produceRetainedState < UiState < List < Person >>> ( UiState . Loading , favoritesRepository ) { favoritesRepository . people . map { UiState . Data ( it ) } . collect { value = it } } return state }","title":"produceRetainedState"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/remember-retained/","text":"// circuit-retained / com.slack.circuit.retained / rememberRetained rememberRetained \u00b6 [common]\\ @ Composable fun < T : Any > rememberRetained (vararg inputs: Any ?, key: String ? = null, init: () -> T ): T Remember the value produced by init . It behaves similarly to remember , but the stored value will survive configuration changes, such as a screen rotation. You can use it with a value stored inside androidx.compose.runtime.mutableStateOf . This differs from rememberSaveable by not being tied to Android bundles or parcelable. You should take care to ensure that the state computed by init does not capture anything that is not save to persist across reconfiguration, such as Navigators. The same caveats of rememberSaveable also still apply (i.e. do not retain Android Contexts, Views, etc). However, it does not participate in saved instance state either, so care should be taken to choose the right retention mechanism for your use case. Consider the below two examples. The first case will retain state across configuration changes but will not survive process death. @Composable override fun present (): CounterState { var state by rememberRetained { mutableStateOf ( CounterState ( 0 )) } return CounterState ( count ) { event -> when ( event ) { is CounterEvent . Increment -> state = state . copy ( count = state . count + 1 ) is CounterEvent . Decrement -> state = state . copy ( count = state . count - 1 ) } } } This second case will retain count across configuration changes and survive process death. However, it only works with primitives or Parcelable state types. @Composable override fun present (): CounterState { var count by rememberSaveable { mutableStateOf ( 0 ) } return CounterState ( count ) { event -> when ( event ) { is CounterEvent . Increment -> state = count ++ is CounterEvent . Decrement -> state = count -- } } } Parameters \u00b6 common inputs A set of inputs such that, when any of them have changed, will cause the state to reset and init to be rerun key An optional key to be used as a key for the saved value. If not provided we use the automatically generated by the Compose runtime which is unique for the every exact code location in the composition tree init A factory function to create the initial value of this state","title":"Remember retained"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/remember-retained/#rememberretained","text":"[common]\\ @ Composable fun < T : Any > rememberRetained (vararg inputs: Any ?, key: String ? = null, init: () -> T ): T Remember the value produced by init . It behaves similarly to remember , but the stored value will survive configuration changes, such as a screen rotation. You can use it with a value stored inside androidx.compose.runtime.mutableStateOf . This differs from rememberSaveable by not being tied to Android bundles or parcelable. You should take care to ensure that the state computed by init does not capture anything that is not save to persist across reconfiguration, such as Navigators. The same caveats of rememberSaveable also still apply (i.e. do not retain Android Contexts, Views, etc). However, it does not participate in saved instance state either, so care should be taken to choose the right retention mechanism for your use case. Consider the below two examples. The first case will retain state across configuration changes but will not survive process death. @Composable override fun present (): CounterState { var state by rememberRetained { mutableStateOf ( CounterState ( 0 )) } return CounterState ( count ) { event -> when ( event ) { is CounterEvent . Increment -> state = state . copy ( count = state . count + 1 ) is CounterEvent . Decrement -> state = state . copy ( count = state . count - 1 ) } } } This second case will retain count across configuration changes and survive process death. However, it only works with primitives or Parcelable state types. @Composable override fun present (): CounterState { var count by rememberSaveable { mutableStateOf ( 0 ) } return CounterState ( count ) { event -> when ( event ) { is CounterEvent . Increment -> state = count ++ is CounterEvent . Decrement -> state = count -- } } }","title":"rememberRetained"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/remember-retained/#parameters","text":"common inputs A set of inputs such that, when any of them have changed, will cause the state to reset and init to be rerun key An optional key to be used as a key for the saved value. If not provided we use the automatically generated by the Compose runtime which is unique for the every exact code location in the composition tree init A factory function to create the initial value of this state","title":"Parameters"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-continuity/","text":"// circuit-retained / com.slack.circuit.retained / Continuity Continuity \u00b6 [android]\\ class Continuity : ViewModel , RetainedStateRegistry Constructors \u00b6 Continuity [android] fun Continuity () Functions \u00b6 Name Summary addCloseable [android] open fun addCloseable (@ NonNull p0: Closeable ) consumeValue [android] open override fun consumeValue (key: String ): Any ? Returns the restored value for the given key. Once being restored the value is cleared, so you can\u2019t restore the same key twice. forgetUnclaimedValues [android] open override fun forgetUnclaimedValues () Releases all currently unconsumed values. Useful as a GC mechanism for the registry. performSave [android] open override fun performSave () Executes all the registered value providers and combines these values into a map. We have a list of values for each key as it is allowed to have multiple providers for the same key. registerValue [android] open override fun registerValue (key: String , valueProvider: () -> Any ?): RetainedStateRegistry.Entry Registers the value provider.","title":"Index"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-continuity/#continuity","text":"[android]\\ class Continuity : ViewModel , RetainedStateRegistry","title":"Continuity"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-continuity/#constructors","text":"Continuity [android] fun Continuity ()","title":"Constructors"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-continuity/#functions","text":"Name Summary addCloseable [android] open fun addCloseable (@ NonNull p0: Closeable ) consumeValue [android] open override fun consumeValue (key: String ): Any ? Returns the restored value for the given key. Once being restored the value is cleared, so you can\u2019t restore the same key twice. forgetUnclaimedValues [android] open override fun forgetUnclaimedValues () Releases all currently unconsumed values. Useful as a GC mechanism for the registry. performSave [android] open override fun performSave () Executes all the registered value providers and combines these values into a map. We have a list of values for each key as it is allowed to have multiple providers for the same key. registerValue [android] open override fun registerValue (key: String , valueProvider: () -> Any ?): RetainedStateRegistry.Entry Registers the value provider.","title":"Functions"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-continuity/-continuity/","text":"// circuit-retained / com.slack.circuit.retained / Continuity / Continuity Continuity \u00b6 [android]\\ fun Continuity ()","title":" continuity"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-continuity/-continuity/#continuity","text":"[android]\\ fun Continuity ()","title":"Continuity"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-continuity/consume-value/","text":"// circuit-retained / com.slack.circuit.retained / Continuity / consumeValue consumeValue \u00b6 [android]\\ open override fun consumeValue (key: String ): Any ? Returns the restored value for the given key. Once being restored the value is cleared, so you can\u2019t restore the same key twice. Parameters \u00b6 android key Key used to save the value","title":"Consume value"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-continuity/consume-value/#consumevalue","text":"[android]\\ open override fun consumeValue (key: String ): Any ? Returns the restored value for the given key. Once being restored the value is cleared, so you can\u2019t restore the same key twice.","title":"consumeValue"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-continuity/consume-value/#parameters","text":"android key Key used to save the value","title":"Parameters"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-continuity/forget-unclaimed-values/","text":"// circuit-retained / com.slack.circuit.retained / Continuity / forgetUnclaimedValues forgetUnclaimedValues \u00b6 [android]\\ open override fun forgetUnclaimedValues () Releases all currently unconsumed values. Useful as a GC mechanism for the registry.","title":"Forget unclaimed values"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-continuity/forget-unclaimed-values/#forgetunclaimedvalues","text":"[android]\\ open override fun forgetUnclaimedValues () Releases all currently unconsumed values. Useful as a GC mechanism for the registry.","title":"forgetUnclaimedValues"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-continuity/perform-save/","text":"// circuit-retained / com.slack.circuit.retained / Continuity / performSave performSave \u00b6 [android]\\ open override fun performSave () Executes all the registered value providers and combines these values into a map. We have a list of values for each key as it is allowed to have multiple providers for the same key.","title":"Perform save"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-continuity/perform-save/#performsave","text":"[android]\\ open override fun performSave () Executes all the registered value providers and combines these values into a map. We have a list of values for each key as it is allowed to have multiple providers for the same key.","title":"performSave"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-continuity/register-value/","text":"// circuit-retained / com.slack.circuit.retained / Continuity / registerValue registerValue \u00b6 [android]\\ open override fun registerValue (key: String , valueProvider: () -> Any ?): RetainedStateRegistry.Entry Registers the value provider. There are could be multiple providers registered for the same key . In this case the order in which they were registered matters. Say we registered two values for the key. One provides \"1\", second provides \"2\". this case will have listOf(\"1\", \"2) as a value for the key in the underlying map. And later, when the registry will be recreated with the previously saved values, the first execution of consumeValue would consume \"1\" and the second one \"2\". Return \u00b6 the registry entry which you can use to unregister the provider Parameters \u00b6 android key Key to use for storing the value valueProvider The value to provide","title":"Register value"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-continuity/register-value/#registervalue","text":"[android]\\ open override fun registerValue (key: String , valueProvider: () -> Any ?): RetainedStateRegistry.Entry Registers the value provider. There are could be multiple providers registered for the same key . In this case the order in which they were registered matters. Say we registered two values for the key. One provides \"1\", second provides \"2\". this case will have listOf(\"1\", \"2) as a value for the key in the underlying map. And later, when the registry will be recreated with the previously saved values, the first execution of consumeValue would consume \"1\" and the second one \"2\".","title":"registerValue"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-continuity/register-value/#return","text":"the registry entry which you can use to unregister the provider","title":"Return"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-continuity/register-value/#parameters","text":"android key Key to use for storing the value valueProvider The value to provide","title":"Parameters"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-local-retained-state-registry-owner/","text":"// circuit-retained / com.slack.circuit.retained / LocalRetainedStateRegistryOwner LocalRetainedStateRegistryOwner \u00b6 [common]\\ object LocalRetainedStateRegistryOwner CompositionLocal with a current RetainedStateRegistry instance. Functions \u00b6 Name Summary provides [common] @ Composable infix fun provides (registry: RetainedStateRegistry ): ProvidedValue < RetainedStateRegistry > Associates a LocalRetainedStateRegistry key to a value in a call to CompositionLocalProvider . Properties \u00b6 Name Summary current [common] @get: Composable val current : RetainedStateRegistry Returns current composition local value for the owner or errors if one has not been provided.","title":"Index"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-local-retained-state-registry-owner/#localretainedstateregistryowner","text":"[common]\\ object LocalRetainedStateRegistryOwner CompositionLocal with a current RetainedStateRegistry instance.","title":"LocalRetainedStateRegistryOwner"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-local-retained-state-registry-owner/#functions","text":"Name Summary provides [common] @ Composable infix fun provides (registry: RetainedStateRegistry ): ProvidedValue < RetainedStateRegistry > Associates a LocalRetainedStateRegistry key to a value in a call to CompositionLocalProvider .","title":"Functions"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-local-retained-state-registry-owner/#properties","text":"Name Summary current [common] @get: Composable val current : RetainedStateRegistry Returns current composition local value for the owner or errors if one has not been provided.","title":"Properties"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-local-retained-state-registry-owner/current/","text":"// circuit-retained / com.slack.circuit.retained / LocalRetainedStateRegistryOwner / current current \u00b6 [common]\\ @get: Composable val current : RetainedStateRegistry Returns current composition local value for the owner or errors if one has not been provided.","title":"Current"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-local-retained-state-registry-owner/current/#current","text":"[common]\\ @get: Composable val current : RetainedStateRegistry Returns current composition local value for the owner or errors if one has not been provided.","title":"current"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-local-retained-state-registry-owner/provides/","text":"// circuit-retained / com.slack.circuit.retained / LocalRetainedStateRegistryOwner / provides provides \u00b6 [common]\\ @ Composable infix fun provides (registry: RetainedStateRegistry ): ProvidedValue < RetainedStateRegistry > Associates a LocalRetainedStateRegistry key to a value in a call to CompositionLocalProvider .","title":"Provides"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-local-retained-state-registry-owner/provides/#provides","text":"[common]\\ @ Composable infix fun provides (registry: RetainedStateRegistry ): ProvidedValue < RetainedStateRegistry > Associates a LocalRetainedStateRegistry key to a value in a call to CompositionLocalProvider .","title":"provides"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/","text":"// circuit-retained / com.slack.circuit.retained / RetainedStateRegistry RetainedStateRegistry \u00b6 [common]\\ interface RetainedStateRegistry Allows components to save and restore their state using the onRetainNonConfigurationInstance mechanism. Types \u00b6 Name Summary Entry [common] interface Entry The registry entry which you get when you use registerValue . Functions \u00b6 Name Summary consumeValue [common] abstract fun consumeValue (key: String ): Any ? Returns the restored value for the given key. Once being restored the value is cleared, so you can\u2019t restore the same key twice. forgetUnclaimedValues [common] abstract fun forgetUnclaimedValues () Releases all currently unconsumed values. Useful as a GC mechanism for the registry. performSave [common] abstract fun performSave () Executes all the registered value providers and combines these values into a map. We have a list of values for each key as it is allowed to have multiple providers for the same key. registerValue [common] abstract fun registerValue (key: String , valueProvider: () -> Any ?): RetainedStateRegistry.Entry Registers the value provider. Inheritors \u00b6 Name Continuity","title":"Index"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/#retainedstateregistry","text":"[common]\\ interface RetainedStateRegistry Allows components to save and restore their state using the onRetainNonConfigurationInstance mechanism.","title":"RetainedStateRegistry"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/#types","text":"Name Summary Entry [common] interface Entry The registry entry which you get when you use registerValue .","title":"Types"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/#functions","text":"Name Summary consumeValue [common] abstract fun consumeValue (key: String ): Any ? Returns the restored value for the given key. Once being restored the value is cleared, so you can\u2019t restore the same key twice. forgetUnclaimedValues [common] abstract fun forgetUnclaimedValues () Releases all currently unconsumed values. Useful as a GC mechanism for the registry. performSave [common] abstract fun performSave () Executes all the registered value providers and combines these values into a map. We have a list of values for each key as it is allowed to have multiple providers for the same key. registerValue [common] abstract fun registerValue (key: String , valueProvider: () -> Any ?): RetainedStateRegistry.Entry Registers the value provider.","title":"Functions"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/#inheritors","text":"Name Continuity","title":"Inheritors"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/consume-value/","text":"// circuit-retained / com.slack.circuit.retained / RetainedStateRegistry / consumeValue consumeValue \u00b6 [common]\\ abstract fun consumeValue (key: String ): Any ? Returns the restored value for the given key. Once being restored the value is cleared, so you can\u2019t restore the same key twice. Parameters \u00b6 common key Key used to save the value","title":"Consume value"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/consume-value/#consumevalue","text":"[common]\\ abstract fun consumeValue (key: String ): Any ? Returns the restored value for the given key. Once being restored the value is cleared, so you can\u2019t restore the same key twice.","title":"consumeValue"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/consume-value/#parameters","text":"common key Key used to save the value","title":"Parameters"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/forget-unclaimed-values/","text":"// circuit-retained / com.slack.circuit.retained / RetainedStateRegistry / forgetUnclaimedValues forgetUnclaimedValues \u00b6 [common]\\ abstract fun forgetUnclaimedValues () Releases all currently unconsumed values. Useful as a GC mechanism for the registry.","title":"Forget unclaimed values"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/forget-unclaimed-values/#forgetunclaimedvalues","text":"[common]\\ abstract fun forgetUnclaimedValues () Releases all currently unconsumed values. Useful as a GC mechanism for the registry.","title":"forgetUnclaimedValues"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/perform-save/","text":"// circuit-retained / com.slack.circuit.retained / RetainedStateRegistry / performSave performSave \u00b6 [common]\\ abstract fun performSave () Executes all the registered value providers and combines these values into a map. We have a list of values for each key as it is allowed to have multiple providers for the same key.","title":"Perform save"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/perform-save/#performsave","text":"[common]\\ abstract fun performSave () Executes all the registered value providers and combines these values into a map. We have a list of values for each key as it is allowed to have multiple providers for the same key.","title":"performSave"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/register-value/","text":"// circuit-retained / com.slack.circuit.retained / RetainedStateRegistry / registerValue registerValue \u00b6 [common]\\ abstract fun registerValue (key: String , valueProvider: () -> Any ?): RetainedStateRegistry.Entry Registers the value provider. There are could be multiple providers registered for the same key . In this case the order in which they were registered matters. Say we registered two values for the key. One provides \"1\", second provides \"2\". this case will have listOf(\"1\", \"2) as a value for the key in the underlying map. And later, when the registry will be recreated with the previously saved values, the first execution of consumeValue would consume \"1\" and the second one \"2\". Return \u00b6 the registry entry which you can use to unregister the provider Parameters \u00b6 common key Key to use for storing the value valueProvider The value to provide","title":"Register value"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/register-value/#registervalue","text":"[common]\\ abstract fun registerValue (key: String , valueProvider: () -> Any ?): RetainedStateRegistry.Entry Registers the value provider. There are could be multiple providers registered for the same key . In this case the order in which they were registered matters. Say we registered two values for the key. One provides \"1\", second provides \"2\". this case will have listOf(\"1\", \"2) as a value for the key in the underlying map. And later, when the registry will be recreated with the previously saved values, the first execution of consumeValue would consume \"1\" and the second one \"2\".","title":"registerValue"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/register-value/#return","text":"the registry entry which you can use to unregister the provider","title":"Return"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/register-value/#parameters","text":"common key Key to use for storing the value valueProvider The value to provide","title":"Parameters"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/-entry/","text":"// circuit-retained / com.slack.circuit.retained / RetainedStateRegistry / Entry Entry \u00b6 [common]\\ interface Entry The registry entry which you get when you use registerValue . Functions \u00b6 Name Summary unregister [common] abstract fun unregister () Unregister previously registered entry.","title":"Index"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/-entry/#entry","text":"[common]\\ interface Entry The registry entry which you get when you use registerValue .","title":"Entry"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/-entry/#functions","text":"Name Summary unregister [common] abstract fun unregister () Unregister previously registered entry.","title":"Functions"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/-entry/unregister/","text":"// circuit-retained / com.slack.circuit.retained / RetainedStateRegistry / Entry / unregister unregister \u00b6 [common]\\ abstract fun unregister () Unregister previously registered entry.","title":"Unregister"},{"location":"api/0.x/circuit-retained/com.slack.circuit.retained/-retained-state-registry/-entry/unregister/#unregister","text":"[common]\\ abstract fun unregister () Unregister previously registered entry.","title":"unregister"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/","text":"// circuit-test / com.slack.circuit.test Package-level declarations \u00b6 Types \u00b6 Name Summary FakeNavigator [android] class FakeNavigator : Navigator A fake Navigator that can be used in tests to record and assert navigation events. Functions \u00b6 Name Summary presenterTestOf [android] suspend fun < UiState : CircuitUiState> presenterTestOf (presentFunction: @ Composable () -> UiState , timeout: Duration ? = null, name: String ? = null, block: suspend ReceiveTurbine< UiState >.() -> Unit ) Presents this presentFunction and invokes a suspend ReceiveTurbine that can be used to assert state emissions from it. test [android] suspend fun < UiState : CircuitUiState> Presenter< UiState >. test (timeout: Duration ? = null, name: String ? = null, block: suspend ReceiveTurbine< UiState >.() -> Unit ) Presents this Presenter and invokes a suspend ReceiveTurbine that can be used to assert state emissions from this presenter.","title":"circuit-test"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/#package-level-declarations","text":"","title":"Package-level declarations"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/#types","text":"Name Summary FakeNavigator [android] class FakeNavigator : Navigator A fake Navigator that can be used in tests to record and assert navigation events.","title":"Types"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/#functions","text":"Name Summary presenterTestOf [android] suspend fun < UiState : CircuitUiState> presenterTestOf (presentFunction: @ Composable () -> UiState , timeout: Duration ? = null, name: String ? = null, block: suspend ReceiveTurbine< UiState >.() -> Unit ) Presents this presentFunction and invokes a suspend ReceiveTurbine that can be used to assert state emissions from it. test [android] suspend fun < UiState : CircuitUiState> Presenter< UiState >. test (timeout: Duration ? = null, name: String ? = null, block: suspend ReceiveTurbine< UiState >.() -> Unit ) Presents this Presenter and invokes a suspend ReceiveTurbine that can be used to assert state emissions from this presenter.","title":"Functions"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/presenter-test-of/","text":"// circuit-test / com.slack.circuit.test / presenterTestOf presenterTestOf \u00b6 [android]\\ suspend fun < UiState : CircuitUiState> presenterTestOf (presentFunction: @ Composable () -> UiState , timeout: Duration ? = null, name: String ? = null, block: suspend ReceiveTurbine< UiState >.() -> Unit ) Presents this presentFunction and invokes a suspend ReceiveTurbine that can be used to assert state emissions from it. See also \u00b6 android moleculeFlow test Parameters \u00b6 android presentFunction the Composable present function being tested. timeout an optional timeout for the test. Defaults to 1 second (in Turbine) if undefined. block the block to invoke.","title":"Presenter test of"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/presenter-test-of/#presentertestof","text":"[android]\\ suspend fun < UiState : CircuitUiState> presenterTestOf (presentFunction: @ Composable () -> UiState , timeout: Duration ? = null, name: String ? = null, block: suspend ReceiveTurbine< UiState >.() -> Unit ) Presents this presentFunction and invokes a suspend ReceiveTurbine that can be used to assert state emissions from it.","title":"presenterTestOf"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/presenter-test-of/#see-also","text":"android moleculeFlow test","title":"See also"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/presenter-test-of/#parameters","text":"android presentFunction the Composable present function being tested. timeout an optional timeout for the test. Defaults to 1 second (in Turbine) if undefined. block the block to invoke.","title":"Parameters"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/test/","text":"// circuit-test / com.slack.circuit.test / test test \u00b6 [android]\\ suspend fun < UiState : CircuitUiState> Presenter< UiState >. test (timeout: Duration ? = null, name: String ? = null, block: suspend ReceiveTurbine< UiState >.() -> Unit ) Presents this Presenter and invokes a suspend ReceiveTurbine that can be used to assert state emissions from this presenter. See also \u00b6 android moleculeFlow test Parameters \u00b6 android timeout an optional timeout for the test. Defaults to 1 second (in Turbine) if undefined. block the block to invoke.","title":"Test"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/test/#test","text":"[android]\\ suspend fun < UiState : CircuitUiState> Presenter< UiState >. test (timeout: Duration ? = null, name: String ? = null, block: suspend ReceiveTurbine< UiState >.() -> Unit ) Presents this Presenter and invokes a suspend ReceiveTurbine that can be used to assert state emissions from this presenter.","title":"test"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/test/#see-also","text":"android moleculeFlow test","title":"See also"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/test/#parameters","text":"android timeout an optional timeout for the test. Defaults to 1 second (in Turbine) if undefined. block the block to invoke.","title":"Parameters"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/-fake-navigator/","text":"// circuit-test / com.slack.circuit.test / FakeNavigator FakeNavigator \u00b6 [android]\\ class FakeNavigator : Navigator A fake Navigator that can be used in tests to record and assert navigation events. Example val navigator = FakeNavigator () val presenter = FavoritesPresenter ( navigator ) presenter . test { val state = awaitItem () state . eventSink ( AddFavoriteClick ) assertThat ( navigator . awaitNextScreen ()) . isEqualTo ( AddFavoriteScreen ) } Constructors \u00b6 FakeNavigator [android] fun FakeNavigator () Functions \u00b6 Name Summary assertIsEmpty [android] fun assertIsEmpty () Asserts that all events so far have been consumed. awaitNextScreen [android] suspend fun awaitNextScreen (): Screen Awaits the next Screen that was navigated to or throws if no screens were navigated to. awaitPop [android] suspend fun awaitPop () Awaits the next navigation pop event or throws if no pops are performed. expectNoEvents [android] fun expectNoEvents () Asserts that no events have been emitted. goTo [android] open override fun goTo (screen: Screen) pop [android] open override fun pop (): Screen? takeNextScreen [android] fun takeNextScreen (): Screen Returns the next Screen that was navigated to or throws if no screens were navigated to.","title":"Index"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/-fake-navigator/#fakenavigator","text":"[android]\\ class FakeNavigator : Navigator A fake Navigator that can be used in tests to record and assert navigation events. Example val navigator = FakeNavigator () val presenter = FavoritesPresenter ( navigator ) presenter . test { val state = awaitItem () state . eventSink ( AddFavoriteClick ) assertThat ( navigator . awaitNextScreen ()) . isEqualTo ( AddFavoriteScreen ) }","title":"FakeNavigator"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/-fake-navigator/#constructors","text":"FakeNavigator [android] fun FakeNavigator ()","title":"Constructors"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/-fake-navigator/#functions","text":"Name Summary assertIsEmpty [android] fun assertIsEmpty () Asserts that all events so far have been consumed. awaitNextScreen [android] suspend fun awaitNextScreen (): Screen Awaits the next Screen that was navigated to or throws if no screens were navigated to. awaitPop [android] suspend fun awaitPop () Awaits the next navigation pop event or throws if no pops are performed. expectNoEvents [android] fun expectNoEvents () Asserts that no events have been emitted. goTo [android] open override fun goTo (screen: Screen) pop [android] open override fun pop (): Screen? takeNextScreen [android] fun takeNextScreen (): Screen Returns the next Screen that was navigated to or throws if no screens were navigated to.","title":"Functions"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/-fake-navigator/-fake-navigator/","text":"// circuit-test / com.slack.circuit.test / FakeNavigator / FakeNavigator FakeNavigator \u00b6 [android]\\ fun FakeNavigator ()","title":" fake navigator"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/-fake-navigator/-fake-navigator/#fakenavigator","text":"[android]\\ fun FakeNavigator ()","title":"FakeNavigator"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/-fake-navigator/assert-is-empty/","text":"// circuit-test / com.slack.circuit.test / FakeNavigator / assertIsEmpty assertIsEmpty \u00b6 [android]\\ fun assertIsEmpty () Asserts that all events so far have been consumed.","title":"Assert is empty"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/-fake-navigator/assert-is-empty/#assertisempty","text":"[android]\\ fun assertIsEmpty () Asserts that all events so far have been consumed.","title":"assertIsEmpty"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/-fake-navigator/await-next-screen/","text":"// circuit-test / com.slack.circuit.test / FakeNavigator / awaitNextScreen awaitNextScreen \u00b6 [android]\\ suspend fun awaitNextScreen (): Screen Awaits the next Screen that was navigated to or throws if no screens were navigated to.","title":"Await next screen"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/-fake-navigator/await-next-screen/#awaitnextscreen","text":"[android]\\ suspend fun awaitNextScreen (): Screen Awaits the next Screen that was navigated to or throws if no screens were navigated to.","title":"awaitNextScreen"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/-fake-navigator/await-pop/","text":"// circuit-test / com.slack.circuit.test / FakeNavigator / awaitPop awaitPop \u00b6 [android]\\ suspend fun awaitPop () Awaits the next navigation pop event or throws if no pops are performed.","title":"Await pop"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/-fake-navigator/await-pop/#awaitpop","text":"[android]\\ suspend fun awaitPop () Awaits the next navigation pop event or throws if no pops are performed.","title":"awaitPop"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/-fake-navigator/expect-no-events/","text":"// circuit-test / com.slack.circuit.test / FakeNavigator / expectNoEvents expectNoEvents \u00b6 [android]\\ fun expectNoEvents () Asserts that no events have been emitted.","title":"Expect no events"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/-fake-navigator/expect-no-events/#expectnoevents","text":"[android]\\ fun expectNoEvents () Asserts that no events have been emitted.","title":"expectNoEvents"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/-fake-navigator/go-to/","text":"// circuit-test / com.slack.circuit.test / FakeNavigator / goTo goTo \u00b6 [android]\\ open override fun goTo (screen: Screen)","title":"Go to"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/-fake-navigator/go-to/#goto","text":"[android]\\ open override fun goTo (screen: Screen)","title":"goTo"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/-fake-navigator/pop/","text":"// circuit-test / com.slack.circuit.test / FakeNavigator / pop pop \u00b6 [android]\\ open override fun pop (): Screen?","title":"Pop"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/-fake-navigator/pop/#pop","text":"[android]\\ open override fun pop (): Screen?","title":"pop"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/-fake-navigator/take-next-screen/","text":"// circuit-test / com.slack.circuit.test / FakeNavigator / takeNextScreen takeNextScreen \u00b6 [android]\\ fun takeNextScreen (): Screen Returns the next Screen that was navigated to or throws if no screens were navigated to. For non-coroutines users only.","title":"Take next screen"},{"location":"api/0.x/circuit-test/com.slack.circuit.test/-fake-navigator/take-next-screen/#takenextscreen","text":"[android]\\ fun takeNextScreen (): Screen Returns the next Screen that was navigated to or throws if no screens were navigated to. For non-coroutines users only.","title":"takeNextScreen"}]}